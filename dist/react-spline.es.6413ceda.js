// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kn9T2":[function(require,module,exports) {
var Refresh = require('react-refresh/runtime');
Refresh.injectIntoGlobalHook(window);
window.$RefreshReg$ = function() {};
window.$RefreshSig$ = function() {
    return function(type) {
        return type;
    };
};

},{"react-refresh/runtime":"786KC"}],"1t1vh":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "ddf91b346413ceda";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else if ('reload' in location) location.reload();
            else {
                // Web extension context
                var ext = typeof chrome === 'undefined' ? typeof browser === 'undefined' ? null : browser : chrome;
                if (ext && ext.runtime && ext.runtime.reload) ext.runtime.reload();
            }
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"hmtzL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Spline
);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _runtime = require("@splinetool/runtime");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value
;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(b))if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) {
        for (var prop of __getOwnPropSymbols(source))if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
function mergeRefs(refs) {
    return function(value) {
        refs.forEach(function(ref) {
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        });
    };
}
var jsxRuntime = {
    exports: {}
};
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f = _reactDefault.default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = {
    key: true,
    ref: true,
    __self: true,
    __source: true
};
function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    g !== void 0 && (e = "" + g);
    a.key !== void 0 && (e = "" + a.key);
    a.ref !== void 0 && (h = a.ref);
    for(b in a)m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for(b in a = c.defaultProps, a)d[b] === void 0 && (d[b] = a[b]);
    return {
        $$typeof: k,
        type: c,
        key: e,
        ref: h,
        props: d,
        _owner: n.current
    };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
jsxRuntime.exports = reactJsxRuntime_production_min;
const jsx = jsxRuntime.exports.jsx;
const Spline = _react.forwardRef((_a, ref)=>{
    var _b = _a, { scene , style , onMouseDown , onMouseUp , onMouseHover , onKeyDown , onKeyUp , onStart , onLookAt , onFollow , onWheel , onLoad , autoRender =false  } = _b, props = __objRest(_b, [
        "scene",
        "style",
        "onMouseDown",
        "onMouseUp",
        "onMouseHover",
        "onKeyDown",
        "onKeyUp",
        "onStart",
        "onLookAt",
        "onFollow",
        "onWheel",
        "onLoad",
        "autoRender"
    ]);
    const canvasRef = _react.useRef(null);
    const [isLoading, setIsLoading] = _react.useState(true);
    _react.useEffect(()=>{
        setIsLoading(true);
        let speApp;
        const events = [
            {
                name: "mouseDown",
                cb: onMouseDown
            },
            {
                name: "mouseUp",
                cb: onMouseUp
            },
            {
                name: "mouseHover",
                cb: onMouseHover
            },
            {
                name: "keyDown",
                cb: onKeyDown
            },
            {
                name: "keyUp",
                cb: onKeyUp
            },
            {
                name: "start",
                cb: onStart
            },
            {
                name: "lookAt",
                cb: onLookAt
            },
            {
                name: "follow",
                cb: onFollow
            },
            {
                name: "scroll",
                cb: onWheel
            }
        ];
        if (canvasRef.current) {
            speApp = new _runtime.Application(canvasRef.current, {
                autoRender
            });
            async function init() {
                await speApp.load(scene);
                for (let event of events)if (event.cb) speApp.addEventListener(event.name, event.cb);
                setIsLoading(false);
                onLoad == null || onLoad(speApp);
            }
            init();
        }
        return ()=>{
            for (let event of events)if (event.cb) speApp.removeEventListener(event.name, event.cb);
            speApp.dispose();
        };
    }, [
        scene
    ]);
    return /* @__PURE__ */ jsx("canvas", __spreadValues({
        ref: mergeRefs([
            ref,
            canvasRef
        ]),
        style: __spreadValues({
            display: isLoading ? "none" : "block"
        }, style)
    }, props));
});

},{"react":"21dqq","@splinetool/runtime":"dUFrn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dUFrn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Application", ()=>CT
);
var global = arguments[3];
var process = require("process");
var Buffer = require("buffer").Buffer;
var DT = Object.create;
var Tu = Object.defineProperty, PT = Object.defineProperties, LT = Object.getOwnPropertyDescriptor, IT = Object.getOwnPropertyDescriptors, RT = Object.getOwnPropertyNames, Au = Object.getOwnPropertySymbols, BT = Object.getPrototypeOf, gm = Object.prototype.hasOwnProperty, Ax = Object.prototype.propertyIsEnumerable;
var Mx = (i9, e, t)=>e in i9 ? Tu(i9, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : i9[e] = t
, ie = (i10, e)=>{
    for(var t in e || (e = {}))gm.call(e, t) && Mx(i10, t, e[t]);
    if (Au) for (var t of Au(e))Ax.call(e, t) && Mx(i10, t, e[t]);
    return i10;
}, xe = (i11, e)=>PT(i11, IT(e))
;
var Eu = (i12, e)=>{
    var t = {};
    for(var r in i12)gm.call(i12, r) && e.indexOf(r) < 0 && (t[r] = i12[r]);
    if (i12 != null && Au) for (var r of Au(i12))e.indexOf(r) < 0 && Ax.call(i12, r) && (t[r] = i12[r]);
    return t;
};
var NT = (i13, e)=>()=>(e || i13((e = {
            exports: {}
        }).exports, e), e.exports)
, Tx = (i14, e)=>{
    for(var t in e)Tu(i14, t, {
        get: e[t],
        enumerable: !0
    });
}, OT = (i15, e, t, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of RT(e))!gm.call(i15, n) && n !== t && Tu(i15, n, {
        get: ()=>e[n]
        ,
        enumerable: !(r = LT(e, n)) || r.enumerable
    });
    return i15;
};
var FT = (i16, e, t)=>(t = i16 != null ? DT(BT(i16)) : {}, OT(e || !i16 || !i16.__esModule ? Tu(t, "default", {
        value: i16,
        enumerable: !0
    }) : t, i16))
;
var aA = NT((Yp, oA)=>{
    (function(i17, e) {
        typeof Yp == "object" && typeof oA < "u" ? e(Yp) : typeof define == "function" && define.amd ? define([
            "exports"
        ], e) : e((i17 = typeof globalThis < "u" ? globalThis : i17 || self).SVDJS = {});
    })(Yp, function(i18) {
        "use strict";
        i18.SVD = function(e, t, r, n, s) {
            if (t = t === void 0 || t, r = r === void 0 || r, s = 1e-64 / (n = n || Math.pow(2, -52)), !e) throw new TypeError("Matrix a is not defined");
            var o, a, l, c, h, u, f, d, p, m, g, v, y = e[0].length, w = e.length;
            if (w < y) throw new TypeError("Invalid matrix: m < n");
            for(var b = [], S = [], T = [], A = t === "f" ? w : y, x = m = f = 0; x < w; x++)S[x] = new Array(A).fill(0);
            for(x = 0; x < y; x++)T[x] = new Array(y).fill(0);
            var E, _ = new Array(y).fill(0);
            for(x = 0; x < w; x++)for(o = 0; o < y; o++)S[x][o] = e[x][o];
            for(x = 0; x < y; x++){
                for(b[x] = f, p = 0, l = x + 1, o = x; o < w; o++)p += Math.pow(S[o][x], 2);
                if (p < s) f = 0;
                else for(d = (u = S[x][x]) * (f = u < 0 ? Math.sqrt(p) : -Math.sqrt(p)) - p, S[x][x] = u - f, o = l; o < y; o++){
                    for(p = 0, a = x; a < w; a++)p += S[a][x] * S[a][o];
                    for(u = p / d, a = x; a < w; a++)S[a][o] = S[a][o] + u * S[a][x];
                }
                for(_[x] = f, p = 0, o = l; o < y; o++)p += Math.pow(S[x][o], 2);
                if (p < s) f = 0;
                else {
                    for(d = (u = S[x][x + 1]) * (f = u < 0 ? Math.sqrt(p) : -Math.sqrt(p)) - p, S[x][x + 1] = u - f, o = l; o < y; o++)b[o] = S[x][o] / d;
                    for(o = l; o < w; o++){
                        for(p = 0, a = l; a < y; a++)p += S[o][a] * S[x][a];
                        for(a = l; a < y; a++)S[o][a] = S[o][a] + p * b[a];
                    }
                }
                m < (g = Math.abs(_[x]) + Math.abs(b[x])) && (m = g);
            }
            if (r) for(x = y - 1; 0 <= x; x--){
                if (f !== 0) {
                    for(d = S[x][x + 1] * f, o = l; o < y; o++)T[o][x] = S[x][o] / d;
                    for(o = l; o < y; o++){
                        for(p = 0, a = l; a < y; a++)p += S[x][a] * T[a][o];
                        for(a = l; a < y; a++)T[a][o] = T[a][o] + p * T[a][x];
                    }
                }
                for(o = l; o < y; o++)T[x][o] = 0, T[o][x] = 0;
                T[x][x] = 1, f = b[x], l = x;
            }
            if (t) {
                if (t === "f") for(x = y; x < w; x++){
                    for(o = y; o < w; o++)S[x][o] = 0;
                    S[x][x] = 1;
                }
                for(x = y - 1; 0 <= x; x--){
                    for(l = x + 1, f = _[x], o = l; o < A; o++)S[x][o] = 0;
                    if (f !== 0) {
                        for(d = S[x][x] * f, o = l; o < A; o++){
                            for(p = 0, a = l; a < w; a++)p += S[a][x] * S[a][o];
                            for(u = p / d, a = x; a < w; a++)S[a][o] = S[a][o] + u * S[a][x];
                        }
                        for(o = x; o < w; o++)S[o][x] = S[o][x] / f;
                    } else for(o = x; o < w; o++)S[o][x] = 0;
                    S[x][x] = S[x][x] + 1;
                }
            }
            for(n *= m, a = y - 1; 0 <= a; a--)for(var C = 0; C < 50; C++){
                for(E = !1, l = a; 0 <= l; l--){
                    if (Math.abs(b[l]) <= n) {
                        E = !0;
                        break;
                    }
                    if (Math.abs(_[l - 1]) <= n) break;
                }
                if (!E) {
                    for(h = 0, c = l - (p = 1), x = l; x < a + 1 && (u = p * b[x], b[x] = h * b[x], !(Math.abs(u) <= n)); x++)if (f = _[x], _[x] = Math.sqrt(u * u + f * f), h = f / (d = _[x]), p = -u / d, t) for(o = 0; o < w; o++)g = S[o][c], v = S[o][x], S[o][c] = g * h + v * p, S[o][x] = -g * p + v * h;
                }
                if (v = _[a], l === a) {
                    if (v < 0 && (_[a] = -v, r)) for(o = 0; o < y; o++)T[o][a] = -T[o][a];
                    break;
                }
                for(m = _[l], u = (((g = _[a - 1]) - v) * (g + v) + ((f = b[a - 1]) - (d = b[a])) * (f + d)) / (2 * d * g), f = Math.sqrt(u * u + 1), u = ((m - v) * (m + v) + d * (g / (u < 0 ? u - f : u + f) - d)) / m, x = l + (p = h = 1); x < a + 1; x++){
                    if (f = b[x], g = _[x], d = p * f, f *= h, v = Math.sqrt(u * u + d * d), u = m * (h = u / (b[x - 1] = v)) + f * (p = d / v), f = -m * p + f * h, d = g * p, g *= h, r) for(o = 0; o < y; o++)m = T[o][x - 1], v = T[o][x], T[o][x - 1] = m * h + v * p, T[o][x] = -m * p + v * h;
                    if (v = Math.sqrt(u * u + d * d), u = (h = u / (_[x - 1] = v)) * f + (p = d / v) * g, m = -p * f + h * g, t) for(o = 0; o < w; o++)g = S[o][x - 1], v = S[o][x], S[o][x - 1] = g * h + v * p, S[o][x] = -g * p + v * h;
                }
                b[l] = 0, b[a] = u, _[a] = m;
            }
            for(x = 0; x < y; x++)_[x] < n && (_[x] = 0);
            return {
                u: S,
                q: _,
                v: T
            };
        }, i18.VERSION = "1.1.1", Object.defineProperty(i18, "__esModule", {
            value: !0
        });
    });
});
var Uo = "140";
var Cn = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}, UT = 0, Ex = 1, zT = 2;
var ub = 1, Zg = 2, Bc = 3, ii = 0, Pr = 1, or = 2, fb = 1;
var Ht = 0, Ps = 1, _x = 2, Cx = 3, Dx = 4, GT = 5, Ea = 100, kT = 101, VT = 102, Px = 103, Lx = 104, HT = 200, WT = 201, jT = 202, qT = 203, db = 204, pb = 205, YT = 206, XT = 207, QT = 208, JT = 209, KT = 210, ZT = 0, $T = 1, eE = 2, tg = 3, tE = 4, rE = 5, nE = 6, iE = 7, $f = 0, sE = 1, oE = 2, rs = 0, aE = 1, lE = 2, cE = 3, hE = 4, uE = 5, mb = 300, Rs = 301, Bs = 302, rg = 303, ng = 304, Ya = 306, Ia = 1e3, Dr = 1001, ig = 1002, hr = 1003, Ix = 1004;
var Rx = 1005;
var ct = 1006, fE = 1007;
var js = 1008;
var qt = 1009, dE = 1010, pE = 1011, kc = 1012, mE = 1013, La = 1014, Ds = 1015, Vc = 1016, gE = 1017, yE = 1018, Ls = 1020, vE = 1021, xE = 1022, Fn = 1023, bE = 1024, wE = 1025, Eo = 1026, Ns = 1027, SE = 1028, ME = 1029, AE = 1030, TE = 1031, EE = 1033, ym = 33776, vm = 33777, xm = 33778, bm = 33779, Bx = 35840, Nx = 35841, Ox = 35842, Fx = 35843, _E = 36196, Ux = 37492, zx = 37496, Gx = 37808, kx = 37809, Vx = 37810, Hx = 37811, Wx = 37812, jx = 37813, qx = 37814, Yx = 37815, Xx = 37816, Qx = 37817, Jx = 37818, Kx = 37819, Zx = 37820, $x = 37821, e0 = 36492, CE = 2200, DE = 2201, PE = 2202, uf = 2300, ff = 2301, wm = 2302, _a = 2400, Ca = 2401, df = 2402, $g = 2500, gb = 2501, yb = 0;
var gn = 3e3, je = 3001, Ir = 3200, LE = 3201, Xa = 0, IE = 1;
var es = "srgb", To = "srgb-linear";
var Sm = 7680;
var RE = 519, Hc = 35044, pf = 35048;
var t0 = "300 es", sg = 1035, Yt = class {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        let r = this._listeners;
        r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        let r = this._listeners;
        return r[e] !== void 0 && r[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        let n = this._listeners[e];
        if (n !== void 0) {
            let s = n.indexOf(t);
            s !== -1 && n.splice(s, 1);
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        let r = this._listeners[e.type];
        if (r !== void 0) {
            e.target = this;
            let n = r.slice(0);
            for(let s = 0, o = n.length; s < o; s++)n[s].call(this, e);
            e.target = null;
        }
    }
}, zr = [];
for(let i46 = 0; i46 < 256; i46++)zr[i46] = (i46 < 16 ? "0" : "") + i46.toString(16);
var r0 = 1234567, Oc = Math.PI / 180, Wc = 180 / Math.PI;
function Un() {
    let i19 = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
    return (zr[i19 & 255] + zr[i19 >> 8 & 255] + zr[i19 >> 16 & 255] + zr[i19 >> 24 & 255] + "-" + zr[e & 255] + zr[e >> 8 & 255] + "-" + zr[e >> 16 & 15 | 64] + zr[e >> 24 & 255] + "-" + zr[t & 63 | 128] + zr[t >> 8 & 255] + "-" + zr[t >> 16 & 255] + zr[t >> 24 & 255] + zr[r & 255] + zr[r >> 8 & 255] + zr[r >> 16 & 255] + zr[r >> 24 & 255]).toLowerCase();
}
function xr(i20, e, t) {
    return Math.max(e, Math.min(t, i20));
}
function ey(i21, e) {
    return (i21 % e + e) % e;
}
function BE(i22, e, t, r, n) {
    return r + (i22 - e) * (n - r) / (t - e);
}
function NE(i23, e, t) {
    return i23 !== e ? (t - i23) / (e - i23) : 0;
}
function Fc(i24, e, t) {
    return (1 - t) * i24 + t * e;
}
function OE(i25, e, t, r) {
    return Fc(i25, e, 1 - Math.exp(-t * r));
}
function FE(i26, e = 1) {
    return e - Math.abs(ey(i26, e * 2) - e);
}
function UE(i27, e, t) {
    return i27 <= e ? 0 : i27 >= t ? 1 : (i27 = (i27 - e) / (t - e), i27 * i27 * (3 - 2 * i27));
}
function zE(i28, e, t) {
    return i28 <= e ? 0 : i28 >= t ? 1 : (i28 = (i28 - e) / (t - e), i28 * i28 * i28 * (i28 * (i28 * 6 - 15) + 10));
}
function GE(i29, e) {
    return i29 + Math.floor(Math.random() * (e - i29 + 1));
}
function kE(i30, e) {
    return i30 + Math.random() * (e - i30);
}
function VE(i31) {
    return i31 * (.5 - Math.random());
}
function HE(i32) {
    i32 !== void 0 && (r0 = i32);
    let e = r0 += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function WE(i33) {
    return i33 * Oc;
}
function jE(i34) {
    return i34 * Wc;
}
function og(i35) {
    return (i35 & i35 - 1) === 0 && i35 !== 0;
}
function qE(i36) {
    return Math.pow(2, Math.ceil(Math.log(i36) / Math.LN2));
}
function mf(i37) {
    return Math.pow(2, Math.floor(Math.log(i37) / Math.LN2));
}
function YE(i38, e, t, r, n) {
    let s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), c = s((e + r) / 2), h = o((e + r) / 2), u = s((e - r) / 2), f = o((e - r) / 2), d = s((r - e) / 2), p = o((r - e) / 2);
    switch(n){
        case "XYX":
            i38.set(a * h, l * u, l * f, a * c);
            break;
        case "YZY":
            i38.set(l * f, a * h, l * u, a * c);
            break;
        case "ZXZ":
            i38.set(l * u, l * f, a * h, a * c);
            break;
        case "XZX":
            i38.set(a * h, l * p, l * d, a * c);
            break;
        case "YXY":
            i38.set(l * d, a * h, l * p, a * c);
            break;
        case "ZYZ":
            i38.set(l * p, l * d, a * h, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
    }
}
function XE(i39, e) {
    switch(e.constructor){
        case Float32Array:
            return i39;
        case Uint16Array:
            return i39 / 65535;
        case Uint8Array:
            return i39 / 255;
        case Int16Array:
            return Math.max(i39 / 32767, -1);
        case Int8Array:
            return Math.max(i39 / 127, -1);
        default:
            throw new Error("Invalid component type.");
    }
}
function QE(i40, e) {
    switch(e.constructor){
        case Float32Array:
            return i40;
        case Uint16Array:
            return Math.round(i40 * 65535);
        case Uint8Array:
            return Math.round(i40 * 255);
        case Int16Array:
            return Math.round(i40 * 32767);
        case Int8Array:
            return Math.round(i40 * 127);
        default:
            throw new Error("Invalid component type.");
    }
}
var et = Object.freeze({
    __proto__: null,
    DEG2RAD: Oc,
    RAD2DEG: Wc,
    generateUUID: Un,
    clamp: xr,
    euclideanModulo: ey,
    mapLinear: BE,
    inverseLerp: NE,
    lerp: Fc,
    damp: OE,
    pingpong: FE,
    smoothstep: UE,
    smootherstep: zE,
    randInt: GE,
    randFloat: kE,
    randFloatSpread: VE,
    seededRandom: HE,
    degToRad: WE,
    radToDeg: jE,
    isPowerOfTwo: og,
    ceilPowerOfTwo: qE,
    floorPowerOfTwo: mf,
    setQuaternionFromProperEuler: YE,
    normalize: QE,
    denormalize: XE
}), B = class {
    constructor(e = 0, t = 0){
        this.x = e, this.y = t;
    }
    get width() {
        return this.x;
    }
    set width(e) {
        this.x = e;
    }
    get height() {
        return this.y;
    }
    set height(e) {
        this.y = e;
    }
    set(e, t) {
        return this.x = e, this.y = t, this;
    }
    setScalar(e) {
        return this.x = e, this.y = e, this;
    }
    setX(e) {
        return this.x = e, this;
    }
    setY(e) {
        return this.y = e, this;
    }
    setComponent(e, t) {
        switch(e){
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e);
        }
        return this;
    }
    getComponent(e) {
        switch(e){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this;
    }
    add(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this);
    }
    addScalar(e) {
        return this.x += e, this.y += e, this;
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this);
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this;
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this;
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this;
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
        let t = this.x, r = this.y, n = e.elements;
        return this.x = n[0] * t + n[3] * r + n[6], this.y = n[1] * t + n[4] * r + n[7], this;
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
    }
    clampLength(e, t) {
        let r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y;
    }
    cross(e) {
        return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        let t = this.x - e.x, r = this.y - e.y;
        return t * t + r * r;
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this;
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t, r) {
        return r !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this;
    }
    rotateAround(e, t) {
        let r = Math.cos(t), n = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
        return this.x = s * r - o * n + e.x, this.y = s * n + o * r + e.y, this;
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y;
    }
};
B.prototype.isVector2 = !0;
var Ft = class {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(e, t, r, n, s, o, a, l, c) {
        let h = this.elements;
        return h[0] = e, h[1] = n, h[2] = a, h[3] = t, h[4] = s, h[5] = l, h[6] = r, h[7] = o, h[8] = c, this;
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
        let t = this.elements, r = e.elements;
        return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
    }
    extractBasis(e, t, r) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e) {
        let t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }
    multiply(e) {
        return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        let r = e.elements, n = t.elements, s = this.elements, o = r[0], a = r[3], l = r[6], c = r[1], h = r[4], u = r[7], f = r[2], d = r[5], p = r[8], m = n[0], g = n[3], v = n[6], y = n[1], w = n[4], b = n[7], S = n[2], T = n[5], A = n[8];
        return s[0] = o * m + a * y + l * S, s[3] = o * g + a * w + l * T, s[6] = o * v + a * b + l * A, s[1] = c * m + h * y + u * S, s[4] = c * g + h * w + u * T, s[7] = c * v + h * b + u * A, s[2] = f * m + d * y + p * S, s[5] = f * g + d * w + p * T, s[8] = f * v + d * b + p * A, this;
    }
    multiplyScalar(e) {
        let t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }
    determinant() {
        let e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8];
        return t * o * h - t * a * c - r * s * h + r * a * l + n * s * c - n * o * l;
    }
    invert() {
        let e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], u = h * o - a * c, f = a * l - h * s, d = c * s - o * l, p = t * u + r * f + n * d;
        if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        let m = 1 / p;
        return e[0] = u * m, e[1] = (n * c - h * r) * m, e[2] = (a * r - n * o) * m, e[3] = f * m, e[4] = (h * t - n * l) * m, e[5] = (n * s - a * t) * m, e[6] = d * m, e[7] = (r * l - c * t) * m, e[8] = (o * t - r * s) * m, this;
    }
    transpose() {
        let e, t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
        let t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }
    setUvTransform(e, t, r, n, s, o, a) {
        let l = Math.cos(s), c = Math.sin(s);
        return this.set(r * l, r * c, -r * (l * o + c * a) + o + e, -n * c, n * l, -n * (-c * o + l * a) + a + t, 0, 0, 1), this;
    }
    scale(e, t) {
        let r = this.elements;
        return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
    }
    rotate(e) {
        let t = Math.cos(e), r = Math.sin(e), n = this.elements, s = n[0], o = n[3], a = n[6], l = n[1], c = n[4], h = n[7];
        return n[0] = t * s + r * l, n[3] = t * o + r * c, n[6] = t * a + r * h, n[1] = -r * s + t * l, n[4] = -r * o + t * c, n[7] = -r * a + t * h, this;
    }
    translate(e, t) {
        let r = this.elements;
        return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
    }
    equals(e) {
        let t = this.elements, r = e.elements;
        for(let n = 0; n < 9; n++)if (t[n] !== r[n]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for(let r = 0; r < 9; r++)this.elements[r] = e[r + t];
        return this;
    }
    toArray(e = [], t = 0) {
        let r = this.elements;
        return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
};
Ft.prototype.isMatrix3 = !0;
function vb(i41) {
    for(let e = i41.length - 1; e >= 0; --e)if (i41[e] > 65535) return !0;
    return !1;
}
var JE = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function _u(i42, e) {
    return new JE[i42](e);
}
function jc(i43) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", i43);
}
function _o(i44) {
    return i44 < .04045 ? i44 * .0773993808 : Math.pow(i44 * .9478672986 + .0521327014, 2.4);
}
function hf(i45) {
    return i45 < .0031308 ? i45 * 12.92 : 1.055 * Math.pow(i45, .41666) - .055;
}
var Mm = {
    [es]: {
        [To]: _o
    },
    [To]: {
        [es]: hf
    }
}, $n = {
    legacyMode: !0,
    get workingColorSpace () {
        return To;
    },
    set workingColorSpace (i){
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function(i, e, t) {
        if (this.legacyMode || e === t || !e || !t) return i;
        if (Mm[e] && Mm[e][t] !== void 0) {
            let r = Mm[e][t];
            return i.r = r(i.r), i.g = r(i.g), i.b = r(i.b), i;
        }
        throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function(i, e) {
        return this.convert(i, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function(i, e) {
        return this.convert(i, e, this.workingColorSpace);
    }
}, xb = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, Mr = {
    r: 0,
    g: 0,
    b: 0
}, ei = {
    h: 0,
    s: 0,
    l: 0
}, Cu = {
    h: 0,
    s: 0,
    l: 0
};
function Am(i, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 0.5 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
}
function Du(i, e) {
    return e.r = i.r, e.g = i.g, e.b = i.b, e;
}
var be = class {
    constructor(e, t, r){
        return t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r);
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
    }
    setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this;
    }
    setHex(e, t = es) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, $n.toWorkingColorSpace(this, t), this;
    }
    setRGB(e, t, r, n = To) {
        return this.r = e, this.g = t, this.b = r, $n.toWorkingColorSpace(this, n), this;
    }
    setHSL(e, t, r, n = To) {
        if (e = ey(e, 1), t = xr(t, 0, 1), r = xr(r, 0, 1), t === 0) this.r = this.g = this.b = r;
        else {
            let s = r <= .5 ? r * (1 + t) : r + t - r * t, o = 2 * r - s;
            this.r = Am(o, s, e + 1 / 3), this.g = Am(o, s, e), this.b = Am(o, s, e - 1 / 3);
        }
        return $n.toWorkingColorSpace(this, n), this;
    }
    setStyle(e, t = es) {
        function r(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
        }
        let n;
        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let s, o = n[1], a = n[2];
            switch(o){
                case "rgb":
                case "rgba":
                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, $n.toWorkingColorSpace(this, t), r(s[4]), this;
                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, $n.toWorkingColorSpace(this, t), r(s[4]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                        let l = parseFloat(s[1]) / 360, c = parseInt(s[2], 10) / 100, h = parseInt(s[3], 10) / 100;
                        return r(s[4]), this.setHSL(l, c, h, t);
                    }
                    break;
            }
        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            let s = n[1], o = s.length;
            if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, $n.toWorkingColorSpace(this, t), this;
            if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, $n.toWorkingColorSpace(this, t), this;
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this;
    }
    setColorName(e, t = es) {
        let r = xb[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }
    copySRGBToLinear(e) {
        return this.r = _o(e.r), this.g = _o(e.g), this.b = _o(e.b), this;
    }
    copyLinearToSRGB(e) {
        return this.r = hf(e.r), this.g = hf(e.g), this.b = hf(e.b), this;
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
    }
    getHex(e = es) {
        return $n.fromWorkingColorSpace(Du(this, Mr), e), xr(Mr.r * 255, 0, 255) << 16 ^ xr(Mr.g * 255, 0, 255) << 8 ^ xr(Mr.b * 255, 0, 255) << 0;
    }
    getHexString(e = es) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = To) {
        $n.fromWorkingColorSpace(Du(this, Mr), t);
        let r = Mr.r, n = Mr.g, s = Mr.b, o = Math.max(r, n, s), a = Math.min(r, n, s), l, c, h = (a + o) / 2;
        if (a === o) l = 0, c = 0;
        else {
            let u = o - a;
            switch(c = h <= .5 ? u / (o + a) : u / (2 - o - a), o){
                case r:
                    l = (n - s) / u + (n < s ? 6 : 0);
                    break;
                case n:
                    l = (s - r) / u + 2;
                    break;
                case s:
                    l = (r - n) / u + 4;
                    break;
            }
            l /= 6;
        }
        return e.h = l, e.s = c, e.l = h, e;
    }
    getRGB(e, t = To) {
        return $n.fromWorkingColorSpace(Du(this, Mr), t), e.r = Mr.r, e.g = Mr.g, e.b = Mr.b, e;
    }
    getStyle(e = es) {
        return $n.fromWorkingColorSpace(Du(this, Mr), e), e !== es ? `color(${e} ${Mr.r} ${Mr.g} ${Mr.b})` : `rgb(${Mr.r * 255 | 0},${Mr.g * 255 | 0},${Mr.b * 255 | 0})`;
    }
    offsetHSL(e, t, r) {
        return this.getHSL(ei), ei.h += e, ei.s += t, ei.l += r, this.setHSL(ei.h, ei.s, ei.l), this;
    }
    add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }
    addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }
    addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this;
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }
    multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }
    multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this;
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }
    lerpColors(e, t, r) {
        return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
    }
    lerpHSL(e, t) {
        this.getHSL(ei), e.getHSL(Cu);
        let r = Fc(ei.h, Cu.h, t), n = Fc(ei.s, Cu.s, t), s = Fc(ei.l, Cu.l, t);
        return this.setHSL(r, n, s), this;
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
    toJSON() {
        return this.getHex();
    }
    *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
    }
};
be.NAMES = xb;
be.prototype.isColor = !0;
be.prototype.r = 1;
be.prototype.g = 1;
be.prototype.b = 1;
var la, ns = class {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            la === void 0 && (la = jc("canvas")), la.width = e.width, la.height = e.height;
            let r = la.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = la;
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            let t = jc("canvas");
            t.width = e.width, t.height = e.height;
            let r = t.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            let n = r.getImageData(0, 0, e.width, e.height), s = n.data;
            for(let o = 0; o < s.length; o++)s[o] = _o(s[o] / 255) * 255;
            return r.putImageData(n, 0, 0), t;
        } else if (e.data) {
            let t = e.data.slice(0);
            for(let r = 0; r < t.length; r++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(_o(t[r] / 255) * 255) : t[r] = _o(t[r]);
            return {
                data: t,
                width: e.width,
                height: e.height
            };
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
    }
}, gf = class {
    constructor(e = null){
        this.uuid = Un(), this.data = e, this.version = 0;
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        let r = {
            uuid: this.uuid,
            url: ""
        }, n = this.data;
        if (n !== null) {
            let s;
            if (Array.isArray(n)) {
                s = [];
                for(let o = 0, a = n.length; o < a; o++)n[o].isDataTexture ? s.push(Tm(n[o].image)) : s.push(Tm(n[o]));
            } else s = Tm(n);
            r.url = s;
        }
        return t || (e.images[this.uuid] = r), r;
    }
};
function Tm(i) {
    return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? ns.getDataURL(i) : i.data ? {
        data: Array.prototype.slice.call(i.data),
        width: i.width,
        height: i.height,
        type: i.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
gf.prototype.isSource = !0;
var KE = 0, Dt = class extends Yt {
    constructor(e = Dt.DEFAULT_IMAGE, t = Dt.DEFAULT_MAPPING, r = Dr, n = Dr, s = ct, o = js, a = Fn, l = qt, c = 1, h = gn){
        super(), Object.defineProperty(this, "id", {
            value: KE++
        }), this.uuid = Un(), this.name = "", this.source = new gf(e), this.mipmaps = [], this.mapping = t, this.wrapS = r, this.wrapT = n, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new B(0, 0), this.repeat = new B(1, 1), this.center = new B(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ft, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
    }
    get image() {
        return this.source.data;
    }
    set image(e) {
        this.source.data = e;
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        let r = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    transformUv(e) {
        if (this.mapping !== mb) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch(this.wrapS){
            case Ia:
                e.x = e.x - Math.floor(e.x);
                break;
            case Dr:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case ig:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break;
        }
        if (e.y < 0 || e.y > 1) switch(this.wrapT){
            case Ia:
                e.y = e.y - Math.floor(e.y);
                break;
            case Dr:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case ig:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break;
        }
        return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, this.source.needsUpdate = !0);
    }
};
Dt.DEFAULT_IMAGE = null;
Dt.DEFAULT_MAPPING = mb;
Dt.prototype.isTexture = !0;
var Je = class {
    constructor(e = 0, t = 0, r = 0, n = 1){
        this.x = e, this.y = t, this.z = r, this.w = n;
    }
    get width() {
        return this.z;
    }
    set width(e) {
        this.z = e;
    }
    get height() {
        return this.w;
    }
    set height(e) {
        this.w = e;
    }
    set(e, t, r, n) {
        return this.x = e, this.y = t, this.z = r, this.w = n, this;
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this;
    }
    setX(e) {
        return this.x = e, this;
    }
    setY(e) {
        return this.y = e, this;
    }
    setZ(e) {
        return this.z = e, this;
    }
    setW(e) {
        return this.w = e, this;
    }
    setComponent(e, t) {
        switch(e){
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e);
        }
        return this;
    }
    getComponent(e) {
        switch(e){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
    }
    add(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this);
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this;
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
    }
    sub(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this);
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
    }
    applyMatrix4(e) {
        let t = this.x, r = this.y, n = this.z, s = this.w, o = e.elements;
        return this.x = o[0] * t + o[4] * r + o[8] * n + o[12] * s, this.y = o[1] * t + o[5] * r + o[9] * n + o[13] * s, this.z = o[2] * t + o[6] * r + o[10] * n + o[14] * s, this.w = o[3] * t + o[7] * r + o[11] * n + o[15] * s, this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        let t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, r, n, s, l = e.elements, c = l[0], h = l[4], u = l[8], f = l[1], d = l[5], p = l[9], m = l[2], g = l[6], v = l[10];
        if (Math.abs(h - f) < .01 && Math.abs(u - m) < .01 && Math.abs(p - g) < .01) {
            if (Math.abs(h + f) < .1 && Math.abs(u + m) < .1 && Math.abs(p + g) < .1 && Math.abs(c + d + v - 3) < .1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            let w = (c + 1) / 2, b = (d + 1) / 2, S = (v + 1) / 2, T = (h + f) / 4, A = (u + m) / 4, x = (p + g) / 4;
            return w > b && w > S ? w < .01 ? (r = 0, n = .707106781, s = .707106781) : (r = Math.sqrt(w), n = T / r, s = A / r) : b > S ? b < .01 ? (r = .707106781, n = 0, s = .707106781) : (n = Math.sqrt(b), r = T / n, s = x / n) : S < .01 ? (r = .707106781, n = .707106781, s = 0) : (s = Math.sqrt(S), r = A / s, n = x / s), this.set(r, n, s, t), this;
        }
        let y = Math.sqrt((g - p) * (g - p) + (u - m) * (u - m) + (f - h) * (f - h));
        return Math.abs(y) < .001 && (y = 1), this.x = (g - p) / y, this.y = (u - m) / y, this.z = (f - h) / y, this.w = Math.acos((c + d + v - 1) / 2), this;
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
    }
    clampLength(e, t) {
        let r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
    }
    fromBufferAttribute(e, t, r) {
        return r !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
    }
};
Je.prototype.isVector4 = !0;
var mt = class extends Yt {
    constructor(e, t, r = {}){
        super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Je(0, 0, e, t), this.scissorTest = !1, this.viewport = new Je(0, 0, e, t);
        let n = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new Dt(n, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : ct, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0;
    }
    setSize(e, t, r = 1) {
        (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0, this.texture.image = Object.assign({}, e.texture.image), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};
mt.prototype.isWebGLRenderTarget = !0;
var Ra = class extends Dt {
    constructor(e = null, t = 1, r = 1, n = 1){
        super(null), this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
        }, this.magFilter = hr, this.minFilter = hr, this.wrapR = Dr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
};
Ra.prototype.isDataArrayTexture = !0;
var ag = class extends mt {
    constructor(e, t, r){
        super(e, t), this.depth = r, this.texture = new Ra(null, e, t, r), this.texture.isRenderTargetTexture = !0;
    }
};
ag.prototype.isWebGLArrayRenderTarget = !0;
var qc = class extends Dt {
    constructor(e = null, t = 1, r = 1, n = 1){
        super(null), this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
        }, this.magFilter = hr, this.minFilter = hr, this.wrapR = Dr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
};
qc.prototype.isData3DTexture = !0;
var lg = class extends mt {
    constructor(e, t, r){
        super(e, t), this.depth = r, this.texture = new qc(null, e, t, r), this.texture.isRenderTargetTexture = !0;
    }
};
lg.prototype.isWebGL3DRenderTarget = !0;
var cg = class extends mt {
    constructor(e, t, r, n = {}){
        super(e, t, n);
        let s = this.texture;
        this.texture = [];
        for(let o = 0; o < r; o++)this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0;
    }
    setSize(e, t, r = 1) {
        if (this.width !== e || this.height !== t || this.depth !== r) {
            this.width = e, this.height = t, this.depth = r;
            for(let n = 0, s = this.texture.length; n < s; n++)this.texture[n].image.width = e, this.texture[n].image.height = t, this.texture[n].image.depth = r;
            this.dispose();
        }
        return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
    }
    copy(e) {
        this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
        for(let t = 0, r = e.texture.length; t < r; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
        return this;
    }
};
cg.prototype.isWebGLMultipleRenderTargets = !0;
var zt = class {
    constructor(e = 0, t = 0, r = 0, n = 1){
        this._x = e, this._y = t, this._z = r, this._w = n;
    }
    static slerp(e, t, r, n) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), r.slerpQuaternions(e, t, n);
    }
    static slerpFlat(e, t, r, n, s, o, a) {
        let l = r[n + 0], c = r[n + 1], h = r[n + 2], u = r[n + 3], f = s[o + 0], d = s[o + 1], p = s[o + 2], m = s[o + 3];
        if (a === 0) {
            e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
            return;
        }
        if (a === 1) {
            e[t + 0] = f, e[t + 1] = d, e[t + 2] = p, e[t + 3] = m;
            return;
        }
        if (u !== m || l !== f || c !== d || h !== p) {
            let g = 1 - a, v = l * f + c * d + h * p + u * m, y = v >= 0 ? 1 : -1, w = 1 - v * v;
            if (w > Number.EPSILON) {
                let S = Math.sqrt(w), T = Math.atan2(S, v * y);
                g = Math.sin(g * T) / S, a = Math.sin(a * T) / S;
            }
            let b = a * y;
            if (l = l * g + f * b, c = c * g + d * b, h = h * g + p * b, u = u * g + m * b, g === 1 - a) {
                let S = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                l *= S, c *= S, h *= S, u *= S;
            }
        }
        e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = u;
    }
    static multiplyQuaternionsFlat(e, t, r, n, s, o) {
        let a = r[n], l = r[n + 1], c = r[n + 2], h = r[n + 3], u = s[o], f = s[o + 1], d = s[o + 2], p = s[o + 3];
        return e[t] = a * p + h * u + l * d - c * f, e[t + 1] = l * p + h * f + c * u - a * d, e[t + 2] = c * p + h * d + a * f - l * u, e[t + 3] = h * p - a * u - l * f - c * d, e;
    }
    get x() {
        return this._x;
    }
    set x(e) {
        this._x = e, this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        this._y = e, this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        this._z = e, this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(e) {
        this._w = e, this._onChangeCallback();
    }
    set(e, t, r, n) {
        return this._x = e, this._y = t, this._z = r, this._w = n, this._onChangeCallback(), this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
    }
    setFromEuler(e, t) {
        if (!(e && e.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        let r = e._x, n = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(r / 2), h = a(n / 2), u = a(s / 2), f = l(r / 2), d = l(n / 2), p = l(s / 2);
        switch(o){
            case "XYZ":
                this._x = f * h * u + c * d * p, this._y = c * d * u - f * h * p, this._z = c * h * p + f * d * u, this._w = c * h * u - f * d * p;
                break;
            case "YXZ":
                this._x = f * h * u + c * d * p, this._y = c * d * u - f * h * p, this._z = c * h * p - f * d * u, this._w = c * h * u + f * d * p;
                break;
            case "ZXY":
                this._x = f * h * u - c * d * p, this._y = c * d * u + f * h * p, this._z = c * h * p + f * d * u, this._w = c * h * u - f * d * p;
                break;
            case "ZYX":
                this._x = f * h * u - c * d * p, this._y = c * d * u + f * h * p, this._z = c * h * p - f * d * u, this._w = c * h * u + f * d * p;
                break;
            case "YZX":
                this._x = f * h * u + c * d * p, this._y = c * d * u + f * h * p, this._z = c * h * p - f * d * u, this._w = c * h * u - f * d * p;
                break;
            case "XZY":
                this._x = f * h * u - c * d * p, this._y = c * d * u - f * h * p, this._z = c * h * p + f * d * u, this._w = c * h * u + f * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
        }
        return t !== !1 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
        let r = t / 2, n = Math.sin(r);
        return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(r), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e) {
        let t = e.elements, r = t[0], n = t[4], s = t[8], o = t[1], a = t[5], l = t[9], c = t[2], h = t[6], u = t[10], f = r + a + u;
        if (f > 0) {
            let d = .5 / Math.sqrt(f + 1);
            this._w = .25 / d, this._x = (h - l) * d, this._y = (s - c) * d, this._z = (o - n) * d;
        } else if (r > a && r > u) {
            let d = 2 * Math.sqrt(1 + r - a - u);
            this._w = (h - l) / d, this._x = .25 * d, this._y = (n + o) / d, this._z = (s + c) / d;
        } else if (a > u) {
            let d = 2 * Math.sqrt(1 + a - r - u);
            this._w = (s - c) / d, this._x = (n + o) / d, this._y = .25 * d, this._z = (l + h) / d;
        } else {
            let d = 2 * Math.sqrt(1 + u - r - a);
            this._w = (o - n) / d, this._x = (s + c) / d, this._y = (l + h) / d, this._z = .25 * d;
        }
        return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
        let r = e.dot(t) + 1;
        return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(xr(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
        let r = this.angleTo(e);
        if (r === 0) return this;
        let n = Math.min(1, t / r);
        return this.slerp(e, n), this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        return this.conjugate();
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
    }
    multiply(e, t) {
        return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
        let r = e._x, n = e._y, s = e._z, o = e._w, a = t._x, l = t._y, c = t._z, h = t._w;
        return this._x = r * h + o * a + n * c - s * l, this._y = n * h + o * l + s * a - r * c, this._z = s * h + o * c + r * l - n * a, this._w = o * h - r * a - n * l - s * c, this._onChangeCallback(), this;
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        let r = this._x, n = this._y, s = this._z, o = this._w, a = o * e._w + r * e._x + n * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = r, this._y = n, this._z = s, this;
        let l = 1 - a * a;
        if (l <= Number.EPSILON) {
            let d = 1 - t;
            return this._w = d * o + t * this._w, this._x = d * r + t * this._x, this._y = d * n + t * this._y, this._z = d * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
        }
        let c = Math.sqrt(l), h = Math.atan2(c, a), u = Math.sin((1 - t) * h) / c, f = Math.sin(t * h) / c;
        return this._w = o * u + this._w * f, this._x = r * u + this._x * f, this._y = n * u + this._y * f, this._z = s * u + this._z * f, this._onChangeCallback(), this;
    }
    slerpQuaternions(e, t, r) {
        return this.copy(e).slerp(t, r);
    }
    random() {
        let e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), n = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(n), r * Math.sin(s), r * Math.cos(s), t * Math.sin(n));
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
    }
    fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
    }
    _onChange(e) {
        return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
    }
};
zt.prototype.isQuaternion = !0;
var M = class {
    constructor(e = 0, t = 0, r = 0){
        this.x = e, this.y = t, this.z = r;
    }
    set(e, t, r) {
        return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this;
    }
    setX(e) {
        return this.x = e, this;
    }
    setY(e) {
        return this.y = e, this;
    }
    setZ(e) {
        return this.z = e, this;
    }
    setComponent(e, t) {
        switch(e){
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e);
        }
        return this;
    }
    getComponent(e) {
        switch(e){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    add(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this);
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this;
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
    }
    sub(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this);
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this;
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
    }
    multiply(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this);
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this;
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
    }
    applyEuler(e) {
        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(n0.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(n0.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
        let t = this.x, r = this.y, n = this.z, s = e.elements;
        return this.x = s[0] * t + s[3] * r + s[6] * n, this.y = s[1] * t + s[4] * r + s[7] * n, this.z = s[2] * t + s[5] * r + s[8] * n, this;
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
        let t = this.x, r = this.y, n = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * r + s[11] * n + s[15]);
        return this.x = (s[0] * t + s[4] * r + s[8] * n + s[12]) * o, this.y = (s[1] * t + s[5] * r + s[9] * n + s[13]) * o, this.z = (s[2] * t + s[6] * r + s[10] * n + s[14]) * o, this;
    }
    applyQuaternion(e) {
        let t = this.x, r = this.y, n = this.z, s = e.x, o = e.y, a = e.z, l = e.w, c = l * t + o * n - a * r, h = l * r + a * t - s * n, u = l * n + s * r - o * t, f = -s * t - o * r - a * n;
        return this.x = c * l + f * -s + h * -a - u * -o, this.y = h * l + f * -o + u * -s - c * -a, this.z = u * l + f * -a + c * -o - h * -s, this;
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
    }
    transformDirection(e) {
        let t = this.x, r = this.y, n = this.z, s = e.elements;
        return this.x = s[0] * t + s[4] * r + s[8] * n, this.y = s[1] * t + s[5] * r + s[9] * n, this.z = s[2] * t + s[6] * r + s[10] * n, this.normalize();
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
    }
    clampLength(e, t) {
        let r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
    }
    cross(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e);
    }
    crossVectors(e, t) {
        let r = e.x, n = e.y, s = e.z, o = t.x, a = t.y, l = t.z;
        return this.x = n * l - s * a, this.y = s * o - r * l, this.z = r * a - n * o, this;
    }
    projectOnVector(e) {
        let t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        let r = e.dot(this) / t;
        return this.copy(e).multiplyScalar(r);
    }
    projectOnPlane(e) {
        return Em.copy(this).projectOnVector(e), this.sub(Em);
    }
    reflect(e) {
        return this.sub(Em.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
        let t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        let r = this.dot(e) / t;
        return Math.acos(xr(r, -1, 1));
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        let t = this.x - e.x, r = this.y - e.y, n = this.z - e.z;
        return t * t + r * r + n * n;
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, r) {
        let n = Math.sin(t) * e;
        return this.x = n * Math.sin(r), this.y = Math.cos(t) * e, this.z = n * Math.cos(r), this;
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, r) {
        return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
    }
    setFromMatrixPosition(e) {
        let t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this;
    }
    setFromMatrixScale(e) {
        let t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = r, this.z = n, this;
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this;
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
    }
    fromBufferAttribute(e, t, r) {
        return r !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
        let e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
        return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
    }
};
M.prototype.isVector3 = !0;
var Em = new M, n0 = new zt, Kt = class {
    constructor(e = new M(1 / 0, 1 / 0, 1 / 0), t = new M(-1 / 0, -1 / 0, -1 / 0)){
        this.min = e, this.max = t;
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
        let t = 1 / 0, r = 1 / 0, n = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0;
        for(let l = 0, c = e.length; l < c; l += 3){
            let h = e[l], u = e[l + 1], f = e[l + 2];
            h < t && (t = h), u < r && (r = u), f < n && (n = f), h > s && (s = h), u > o && (o = u), f > a && (a = f);
        }
        return this.min.set(t, r, n), this.max.set(s, o, a), this;
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0, r = 1 / 0, n = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0;
        for(let l = 0, c = e.count; l < c; l++){
            let h = e.getX(l), u = e.getY(l), f = e.getZ(l);
            h < t && (t = h), u < r && (r = u), f < n && (n = f), h > s && (s = h), u > o && (o = u), f > a && (a = f);
        }
        return this.min.set(t, r, n), this.max.set(s, o, a), this;
    }
    setFromPoints(e) {
        this.makeEmpty();
        for(let t = 0, r = e.length; t < r; t++)this.expandByPoint(e[t]);
        return this;
    }
    setFromCenterAndSize(e, t) {
        let r = bo.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        let r = e.geometry;
        if (r !== void 0) {
            if (t && r.attributes != null && r.attributes.position !== void 0) {
                let s = r.attributes.position;
                for(let o = 0, a = s.count; o < a; o++)bo.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(bo);
            } else r.boundingBox === null && r.computeBoundingBox(), _m.copy(r.boundingBox), _m.applyMatrix4(e.matrixWorld), this.union(_m);
        }
        let n = e.children;
        for(let s = 0, o = n.length; s < o; s++)this.expandByObject(n[s], t);
        return this;
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, bo), bo.distanceToSquared(e.center) <= e.radius * e.radius;
    }
    intersectsPlane(e) {
        let t, r;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(Ec), Pu.subVectors(this.max, Ec), ca.subVectors(e.a, Ec), ha.subVectors(e.b, Ec), ua.subVectors(e.c, Ec), ws.subVectors(ha, ca), Ss.subVectors(ua, ha), wo.subVectors(ca, ua);
        let t = [
            0,
            -ws.z,
            ws.y,
            0,
            -Ss.z,
            Ss.y,
            0,
            -wo.z,
            wo.y,
            ws.z,
            0,
            -ws.x,
            Ss.z,
            0,
            -Ss.x,
            wo.z,
            0,
            -wo.x,
            -ws.y,
            ws.x,
            0,
            -Ss.y,
            Ss.x,
            0,
            -wo.y,
            wo.x,
            0
        ];
        return !Cm(t, ca, ha, ua, Pu) || (t = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ], !Cm(t, ca, ha, ua, Pu)) ? !1 : (Lu.crossVectors(ws, Ss), t = [
            Lu.x,
            Lu.y,
            Lu.z
        ], Cm(t, ca, ha, ua, Pu));
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
        return bo.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center), e.radius = this.getSize(bo).length() * .5, e;
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Xi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Xi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Xi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Xi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Xi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Xi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Xi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Xi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Xi), this);
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
    }
};
Kt.prototype.isBox3 = !0;
var Xi = [
    new M,
    new M,
    new M,
    new M,
    new M,
    new M,
    new M,
    new M
], bo = new M, _m = new Kt, ca = new M, ha = new M, ua = new M, ws = new M, Ss = new M, wo = new M, Ec = new M, Pu = new M, Lu = new M, So = new M;
function Cm(i, e, t, r, n) {
    for(let s = 0, o = i.length - 3; s <= o; s += 3){
        So.fromArray(i, s);
        let a = n.x * Math.abs(So.x) + n.y * Math.abs(So.y) + n.z * Math.abs(So.z), l = e.dot(So), c = t.dot(So), h = r.dot(So);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
    }
    return !0;
}
var ZE = new Kt, i0 = new M, Iu = new M, Dm = new M, Lr = class {
    constructor(e = new M, t = -1){
        this.center = e, this.radius = t;
    }
    set(e, t) {
        return this.center.copy(e), this.radius = t, this;
    }
    setFromPoints(e, t) {
        let r = this.center;
        t !== void 0 ? r.copy(t) : ZE.setFromPoints(e).getCenter(r);
        let n = 0;
        for(let s = 0, o = e.length; s < o; s++)n = Math.max(n, r.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(n), this;
    }
    copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
        let t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
        return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
        let r = this.center.distanceToSquared(e);
        return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
    }
    translate(e) {
        return this.center.add(e), this;
    }
    expandByPoint(e) {
        Dm.subVectors(e, this.center);
        let t = Dm.lengthSq();
        if (t > this.radius * this.radius) {
            let r = Math.sqrt(t), n = (r - this.radius) * .5;
            this.center.add(Dm.multiplyScalar(n / r)), this.radius += n;
        }
        return this;
    }
    union(e) {
        return this.center.equals(e.center) === !0 ? Iu.set(0, 0, 1).multiplyScalar(e.radius) : Iu.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(i0.copy(e.center).add(Iu)), this.expandByPoint(i0.copy(e.center).sub(Iu)), this;
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}, Qi = new M, Pm = new M, Ru = new M, Ms = new M, Lm = new M, Bu = new M, Im = new M, si = class {
    constructor(e = new M, t = new M(0, 0, -1)){
        this.origin = e, this.direction = t;
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin);
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
        return this.origin.copy(this.at(e, Qi)), this;
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        let r = t.dot(this.direction);
        return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin);
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
        let t = Qi.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Qi.copy(this.direction).multiplyScalar(t).add(this.origin), Qi.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, r, n) {
        Pm.copy(e).add(t).multiplyScalar(.5), Ru.copy(t).sub(e).normalize(), Ms.copy(this.origin).sub(Pm);
        let s = e.distanceTo(t) * .5, o = -this.direction.dot(Ru), a = Ms.dot(this.direction), l = -Ms.dot(Ru), c = Ms.lengthSq(), h = Math.abs(1 - o * o), u, f, d, p;
        if (h > 0) {
            if (u = o * l - a, f = o * a - l, p = s * h, u >= 0) {
                if (f >= -p) {
                    if (f <= p) {
                        let m = 1 / h;
                        u *= m, f *= m, d = u * (u + o * f + 2 * a) + f * (o * u + f + 2 * l) + c;
                    } else f = s, u = Math.max(0, -(o * f + a)), d = -u * u + f * (f + 2 * l) + c;
                } else f = -s, u = Math.max(0, -(o * f + a)), d = -u * u + f * (f + 2 * l) + c;
            } else f <= -p ? (u = Math.max(0, -(-o * s + a)), f = u > 0 ? -s : Math.min(Math.max(-s, -l), s), d = -u * u + f * (f + 2 * l) + c) : f <= p ? (u = 0, f = Math.min(Math.max(-s, -l), s), d = f * (f + 2 * l) + c) : (u = Math.max(0, -(o * s + a)), f = u > 0 ? s : Math.min(Math.max(-s, -l), s), d = -u * u + f * (f + 2 * l) + c);
        } else f = o > 0 ? -s : s, u = Math.max(0, -(o * f + a)), d = -u * u + f * (f + 2 * l) + c;
        return r && r.copy(this.direction).multiplyScalar(u).add(this.origin), n && n.copy(Ru).multiplyScalar(f).add(Pm), d;
    }
    intersectSphere(e, t) {
        Qi.subVectors(e.center, this.origin);
        let r = Qi.dot(this.direction), n = Qi.dot(Qi) - r * r, s = e.radius * e.radius;
        if (n > s) return null;
        let o = Math.sqrt(s - n), a = r - o, l = r + o;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
        let t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        let r = -(this.origin.dot(e.normal) + e.constant) / t;
        return r >= 0 ? r : null;
    }
    intersectPlane(e, t) {
        let r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, t);
    }
    intersectsPlane(e) {
        let t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
        let r, n, s, o, a, l, c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, f = this.origin;
        return c >= 0 ? (r = (e.min.x - f.x) * c, n = (e.max.x - f.x) * c) : (r = (e.max.x - f.x) * c, n = (e.min.x - f.x) * c), h >= 0 ? (s = (e.min.y - f.y) * h, o = (e.max.y - f.y) * h) : (s = (e.max.y - f.y) * h, o = (e.min.y - f.y) * h), r > o || s > n || ((s > r || r !== r) && (r = s), (o < n || n !== n) && (n = o), u >= 0 ? (a = (e.min.z - f.z) * u, l = (e.max.z - f.z) * u) : (a = (e.max.z - f.z) * u, l = (e.min.z - f.z) * u), r > l || a > n) || ((a > r || r !== r) && (r = a), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(r >= 0 ? r : n, t);
    }
    intersectsBox(e) {
        return this.intersectBox(e, Qi) !== null;
    }
    intersectTriangle(e, t, r, n, s) {
        Lm.subVectors(t, e), Bu.subVectors(r, e), Im.crossVectors(Lm, Bu);
        let o = this.direction.dot(Im), a;
        if (o > 0) {
            if (n) return null;
            a = 1;
        } else if (o < 0) a = -1, o = -o;
        else return null;
        Ms.subVectors(this.origin, e);
        let l = a * this.direction.dot(Bu.crossVectors(Ms, Bu));
        if (l < 0) return null;
        let c = a * this.direction.dot(Lm.cross(Ms));
        if (c < 0 || l + c > o) return null;
        let h = -a * Ms.dot(Im);
        return h < 0 ? null : this.at(h / o, s);
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}, Ae = class {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(e, t, r, n, s, o, a, l, c, h, u, f, d, p, m, g) {
        let v = this.elements;
        return v[0] = e, v[4] = t, v[8] = r, v[12] = n, v[1] = s, v[5] = o, v[9] = a, v[13] = l, v[2] = c, v[6] = h, v[10] = u, v[14] = f, v[3] = d, v[7] = p, v[11] = m, v[15] = g, this;
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
        return new Ae().fromArray(this.elements);
    }
    copy(e) {
        let t = this.elements, r = e.elements;
        return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
    }
    copyPosition(e) {
        let t = this.elements, r = e.elements;
        return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
    }
    setFromMatrix3(e) {
        let t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e, t, r) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e, t, r) {
        return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e) {
        let t = this.elements, r = e.elements, n = 1 / fa.setFromMatrixColumn(e, 0).length(), s = 1 / fa.setFromMatrixColumn(e, 1).length(), o = 1 / fa.setFromMatrixColumn(e, 2).length();
        return t[0] = r[0] * n, t[1] = r[1] * n, t[2] = r[2] * n, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromEuler(e) {
        e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        let t = this.elements, r = e.x, n = e.y, s = e.z, o = Math.cos(r), a = Math.sin(r), l = Math.cos(n), c = Math.sin(n), h = Math.cos(s), u = Math.sin(s);
        if (e.order === "XYZ") {
            let f = o * h, d = o * u, p = a * h, m = a * u;
            t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = d + p * c, t[5] = f - m * c, t[9] = -a * l, t[2] = m - f * c, t[6] = p + d * c, t[10] = o * l;
        } else if (e.order === "YXZ") {
            let f = l * h, d = l * u, p = c * h, m = c * u;
            t[0] = f + m * a, t[4] = p * a - d, t[8] = o * c, t[1] = o * u, t[5] = o * h, t[9] = -a, t[2] = d * a - p, t[6] = m + f * a, t[10] = o * l;
        } else if (e.order === "ZXY") {
            let f = l * h, d = l * u, p = c * h, m = c * u;
            t[0] = f - m * a, t[4] = -o * u, t[8] = p + d * a, t[1] = d + p * a, t[5] = o * h, t[9] = m - f * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
        } else if (e.order === "ZYX") {
            let f = o * h, d = o * u, p = a * h, m = a * u;
            t[0] = l * h, t[4] = p * c - d, t[8] = f * c + m, t[1] = l * u, t[5] = m * c + f, t[9] = d * c - p, t[2] = -c, t[6] = a * l, t[10] = o * l;
        } else if (e.order === "YZX") {
            let f = o * l, d = o * c, p = a * l, m = a * c;
            t[0] = l * h, t[4] = m - f * u, t[8] = p * u + d, t[1] = u, t[5] = o * h, t[9] = -a * h, t[2] = -c * h, t[6] = d * u + p, t[10] = f - m * u;
        } else if (e.order === "XZY") {
            let f = o * l, d = o * c, p = a * l, m = a * c;
            t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = f * u + m, t[5] = o * h, t[9] = d * u - p, t[2] = p * u - d, t[6] = a * h, t[10] = m * u + f;
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromQuaternion(e) {
        return this.compose($E, e, e_);
    }
    lookAt(e, t, r) {
        let n = this.elements;
        return En.subVectors(e, t), En.lengthSq() === 0 && (En.z = 1), En.normalize(), As.crossVectors(r, En), As.lengthSq() === 0 && (Math.abs(r.z) === 1 ? En.x += 1e-4 : En.z += 1e-4, En.normalize(), As.crossVectors(r, En)), As.normalize(), Nu.crossVectors(En, As), n[0] = As.x, n[4] = Nu.x, n[8] = En.x, n[1] = As.y, n[5] = Nu.y, n[9] = En.y, n[2] = As.z, n[6] = Nu.z, n[10] = En.z, this;
    }
    multiply(e, t) {
        return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        let r = e.elements, n = t.elements, s = this.elements, o = r[0], a = r[4], l = r[8], c = r[12], h = r[1], u = r[5], f = r[9], d = r[13], p = r[2], m = r[6], g = r[10], v = r[14], y = r[3], w = r[7], b = r[11], S = r[15], T = n[0], A = n[4], x = n[8], E = n[12], _ = n[1], C = n[5], I = n[9], N = n[13], R = n[2], k = n[6], G = n[10], te = n[14], Q = n[3], Y = n[7], F = n[11], z = n[15];
        return s[0] = o * T + a * _ + l * R + c * Q, s[4] = o * A + a * C + l * k + c * Y, s[8] = o * x + a * I + l * G + c * F, s[12] = o * E + a * N + l * te + c * z, s[1] = h * T + u * _ + f * R + d * Q, s[5] = h * A + u * C + f * k + d * Y, s[9] = h * x + u * I + f * G + d * F, s[13] = h * E + u * N + f * te + d * z, s[2] = p * T + m * _ + g * R + v * Q, s[6] = p * A + m * C + g * k + v * Y, s[10] = p * x + m * I + g * G + v * F, s[14] = p * E + m * N + g * te + v * z, s[3] = y * T + w * _ + b * R + S * Q, s[7] = y * A + w * C + b * k + S * Y, s[11] = y * x + w * I + b * G + S * F, s[15] = y * E + w * N + b * te + S * z, this;
    }
    multiplyScalar(e) {
        let t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
    }
    determinant() {
        let e = this.elements, t = e[0], r = e[4], n = e[8], s = e[12], o = e[1], a = e[5], l = e[9], c = e[13], h = e[2], u = e[6], f = e[10], d = e[14], p = e[3], m = e[7], g = e[11], v = e[15];
        return p * (+s * l * u - n * c * u - s * a * f + r * c * f + n * a * d - r * l * d) + m * (+t * l * d - t * c * f + s * o * f - n * o * d + n * c * h - s * l * h) + g * (+t * c * u - t * a * d - s * o * u + r * o * d + s * a * h - r * c * h) + v * (-n * a * h - t * l * u + t * a * f + n * o * u - r * o * f + r * l * h);
    }
    transpose() {
        let e = this.elements, t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
    }
    setPosition(e, t, r) {
        let n = this.elements;
        return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = r), this;
    }
    invert() {
        let e = this.elements, t = e[0], r = e[1], n = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], u = e[9], f = e[10], d = e[11], p = e[12], m = e[13], g = e[14], v = e[15], y = u * g * c - m * f * c + m * l * d - a * g * d - u * l * v + a * f * v, w = p * f * c - h * g * c - p * l * d + o * g * d + h * l * v - o * f * v, b = h * m * c - p * u * c + p * a * d - o * m * d - h * a * v + o * u * v, S = p * u * l - h * m * l - p * a * f + o * m * f + h * a * g - o * u * g, T = t * y + r * w + n * b + s * S;
        if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        let A = 1 / T;
        return e[0] = y * A, e[1] = (m * f * s - u * g * s - m * n * d + r * g * d + u * n * v - r * f * v) * A, e[2] = (a * g * s - m * l * s + m * n * c - r * g * c - a * n * v + r * l * v) * A, e[3] = (u * l * s - a * f * s - u * n * c + r * f * c + a * n * d - r * l * d) * A, e[4] = w * A, e[5] = (h * g * s - p * f * s + p * n * d - t * g * d - h * n * v + t * f * v) * A, e[6] = (p * l * s - o * g * s - p * n * c + t * g * c + o * n * v - t * l * v) * A, e[7] = (o * f * s - h * l * s + h * n * c - t * f * c - o * n * d + t * l * d) * A, e[8] = b * A, e[9] = (p * u * s - h * m * s - p * r * d + t * m * d + h * r * v - t * u * v) * A, e[10] = (o * m * s - p * a * s + p * r * c - t * m * c - o * r * v + t * a * v) * A, e[11] = (h * a * s - o * u * s - h * r * c + t * u * c + o * r * d - t * a * d) * A, e[12] = S * A, e[13] = (h * m * n - p * u * n + p * r * f - t * m * f - h * r * g + t * u * g) * A, e[14] = (p * a * n - o * m * n - p * r * l + t * m * l + o * r * g - t * a * g) * A, e[15] = (o * u * n - h * a * n + h * r * l - t * u * l - o * r * f + t * a * f) * A, this;
    }
    scale(e) {
        let t = this.elements, r = e.x, n = e.y, s = e.z;
        return t[0] *= r, t[4] *= n, t[8] *= s, t[1] *= r, t[5] *= n, t[9] *= s, t[2] *= r, t[6] *= n, t[10] *= s, t[3] *= r, t[7] *= n, t[11] *= s, this;
    }
    getMaxScaleOnAxis() {
        let e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, r, n));
    }
    makeTranslation(e, t, r) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
        let t = Math.cos(e), r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
        let t = Math.cos(e), r = Math.sin(e);
        return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
        let t = Math.cos(e), r = Math.sin(e);
        return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
        let r = Math.cos(t), n = Math.sin(t), s = 1 - r, o = e.x, a = e.y, l = e.z, c = s * o, h = s * a;
        return this.set(c * o + r, c * a - n * l, c * l + n * a, 0, c * a + n * l, h * a + r, h * l - n * o, 0, c * l - n * a, h * l + n * o, s * l * l + r, 0, 0, 0, 0, 1), this;
    }
    makeScale(e, t, r) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, r, n, s, o) {
        return this.set(1, r, s, 0, e, 1, o, 0, t, n, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, r) {
        let n = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, c = s + s, h = o + o, u = a + a, f = s * c, d = s * h, p = s * u, m = o * h, g = o * u, v = a * u, y = l * c, w = l * h, b = l * u, S = r.x, T = r.y, A = r.z;
        return n[0] = (1 - (m + v)) * S, n[1] = (d + b) * S, n[2] = (p - w) * S, n[3] = 0, n[4] = (d - b) * T, n[5] = (1 - (f + v)) * T, n[6] = (g + y) * T, n[7] = 0, n[8] = (p + w) * A, n[9] = (g - y) * A, n[10] = (1 - (f + m)) * A, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
    }
    decompose(e, t, r) {
        let n = this.elements, s = fa.set(n[0], n[1], n[2]).length(), o = fa.set(n[4], n[5], n[6]).length(), a = fa.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], ti.copy(this);
        let c = 1 / s, h = 1 / o, u = 1 / a;
        return ti.elements[0] *= c, ti.elements[1] *= c, ti.elements[2] *= c, ti.elements[4] *= h, ti.elements[5] *= h, ti.elements[6] *= h, ti.elements[8] *= u, ti.elements[9] *= u, ti.elements[10] *= u, t.setFromRotationMatrix(ti), r.x = s, r.y = o, r.z = a, this;
    }
    makePerspective(e, t, r, n, s, o) {
        o === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        let a = this.elements, l = 2 * s / (t - e), c = 2 * s / (r - n), h = (t + e) / (t - e), u = (r + n) / (r - n), f = -(o + s) / (o - s), d = -2 * o * s / (o - s);
        return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
    }
    makeOrthographic(e, t, r, n, s, o) {
        let a = this.elements, l = 1 / (t - e), c = 1 / (r - n), h = 1 / (o - s), u = (t + e) * l, f = (r + n) * c, d = (o + s) * h;
        return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
    }
    equals(e) {
        let t = this.elements, r = e.elements;
        for(let n = 0; n < 16; n++)if (t[n] !== r[n]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for(let r = 0; r < 16; r++)this.elements[r] = e[r + t];
        return this;
    }
    toArray(e = [], t = 0) {
        let r = this.elements;
        return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
    }
};
Ae.prototype.isMatrix4 = !0;
var fa = new M, ti = new Ae, $E = new M(0, 0, 0), e_ = new M(1, 1, 1), As = new M, Nu = new M, En = new M, s0 = new Ae, o0 = new zt, yn = class {
    constructor(e = 0, t = 0, r = 0, n = yn.DefaultOrder){
        this._x = e, this._y = t, this._z = r, this._order = n;
    }
    get x() {
        return this._x;
    }
    set x(e) {
        this._x = e, this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        this._y = e, this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        this._z = e, this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(e) {
        this._order = e, this._onChangeCallback();
    }
    set(e, t, r, n = this._order) {
        return this._x = e, this._y = t, this._z = r, this._order = n, this._onChangeCallback(), this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e, t = this._order, r = !0) {
        let n = e.elements, s = n[0], o = n[4], a = n[8], l = n[1], c = n[5], h = n[9], u = n[2], f = n[6], d = n[10];
        switch(t){
            case "XYZ":
                this._y = Math.asin(xr(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-xr(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(xr(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
                break;
            case "ZYX":
                this._y = Math.asin(-xr(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
                break;
            case "YZX":
                this._z = Math.asin(xr(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(a, d));
                break;
            case "XZY":
                this._z = Math.asin(-xr(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, d), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
        }
        return this._order = t, r === !0 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, r) {
        return s0.makeRotationFromQuaternion(e), this.setFromRotationMatrix(s0, t, r);
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
        return o0.setFromEuler(this), this.setFromQuaternion(o0, e);
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
    }
    fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
    }
    _onChange(e) {
        return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
    }
};
yn.prototype.isEuler = !0;
yn.DefaultOrder = "XYZ";
yn.RotationOrders = [
    "XYZ",
    "YZX",
    "ZXY",
    "XZY",
    "YXZ",
    "ZYX"
];
var Yc = class {
    constructor(){
        this.mask = 1;
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0;
    }
    enable(e) {
        this.mask |= 1 << e | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(e) {
        this.mask ^= 1 << e | 0;
    }
    disable(e) {
        this.mask &= ~(1 << e | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(e) {
        return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0;
    }
}, t_ = 0, a0 = new M, da = new zt, Ji = new Ae, Ou = new M, _c = new M, r_ = new M, n_ = new zt, l0 = new M(1, 0, 0), c0 = new M(0, 1, 0), h0 = new M(0, 0, 1), i_ = {
    type: "added"
}, u0 = {
    type: "removed"
}, ot = class extends Yt {
    constructor(){
        super(), Object.defineProperty(this, "id", {
            value: t_++
        }), this.uuid = Un(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ot.DefaultUp.clone();
        let e = new M, t = new yn, r = new zt, n = new M(1, 1, 1);
        function s() {
            r.setFromEuler(t, !1);
        }
        function o() {
            t.setFromQuaternion(r, void 0, !1);
        }
        t._onChange(s), r._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new Ae
            },
            normalMatrix: {
                value: new Ft
            }
        }), this.matrix = new Ae, this.matrixWorld = new Ae, this.matrixAutoUpdate = ot.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Yc, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
        return da.setFromAxisAngle(e, t), this.quaternion.multiply(da), this;
    }
    rotateOnWorldAxis(e, t) {
        return da.setFromAxisAngle(e, t), this.quaternion.premultiply(da), this;
    }
    rotateX(e) {
        return this.rotateOnAxis(l0, e);
    }
    rotateY(e) {
        return this.rotateOnAxis(c0, e);
    }
    rotateZ(e) {
        return this.rotateOnAxis(h0, e);
    }
    translateOnAxis(e, t) {
        return a0.copy(e).applyQuaternion(this.quaternion), this.position.add(a0.multiplyScalar(t)), this;
    }
    translateX(e) {
        return this.translateOnAxis(l0, e);
    }
    translateY(e) {
        return this.translateOnAxis(c0, e);
    }
    translateZ(e) {
        return this.translateOnAxis(h0, e);
    }
    localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
        return e.applyMatrix4(Ji.copy(this.matrixWorld).invert());
    }
    lookAt(e, t, r) {
        e.isVector3 ? Ou.copy(e) : Ou.set(e, t, r);
        let n = this.parent;
        this.updateWorldMatrix(!0, !1), _c.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ji.lookAt(_c, Ou, this.up) : Ji.lookAt(Ou, _c, this.up), this.quaternion.setFromRotationMatrix(Ji), n && (Ji.extractRotation(n.matrixWorld), da.setFromRotationMatrix(Ji), this.quaternion.premultiply(da.invert()));
    }
    add(e) {
        if (arguments.length > 1) {
            for(let t = 0; t < arguments.length; t++)this.add(arguments[t]);
            return this;
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(i_)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
    }
    remove(e) {
        if (arguments.length > 1) {
            for(let r = 0; r < arguments.length; r++)this.remove(arguments[r]);
            return this;
        }
        let t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(u0)), this;
    }
    removeFromParent() {
        let e = this.parent;
        return e !== null && e.remove(this), this;
    }
    clear() {
        for(let e = 0; e < this.children.length; e++){
            let t = this.children[e];
            t.parent = null, t.dispatchEvent(u0);
        }
        return this.children.length = 0, this;
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1), Ji.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ji.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ji), this.add(e), e.updateWorldMatrix(!1, !0), this;
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for(let r = 0, n = this.children.length; r < n; r++){
            let o = this.children[r].getObjectByProperty(e, t);
            if (o !== void 0) return o;
        }
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_c, e, r_), e;
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_c, n_, e), e;
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {}
    traverse(e) {
        e(this);
        let t = this.children;
        for(let r = 0, n = t.length; r < n; r++)t[r].traverse(e);
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        let t = this.children;
        for(let r = 0, n = t.length; r < n; r++)t[r].traverseVisible(e);
    }
    traverseAncestors(e) {
        let t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
        let t = this.children;
        for(let r = 0, n = t.length; r < n; r++)t[r].updateMatrixWorld(e);
    }
    updateWorldMatrix(e, t) {
        let r = this.parent;
        if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
            let n = this.children;
            for(let s = 0, o = n.length; s < o; s++)n[s].updateWorldMatrix(!1, !0);
        }
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string", r = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, r.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        let n = {};
        n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), this.frustumCulled === !1 && (n.frustumCulled = !1), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
        }
        if (this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = s(e.geometries, this.geometry);
            let a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                let l = a.shapes;
                if (Array.isArray(l)) for(let c = 0, h = l.length; c < h; c++){
                    let u = l[c];
                    s(e.shapes, u);
                }
                else s(e.shapes, l);
            }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0) {
            if (Array.isArray(this.material)) {
                let a = [];
                for(let l = 0, c = this.material.length; l < c; l++)a.push(s(e.materials, this.material[l]));
                n.material = a;
            } else n.material = s(e.materials, this.material);
        }
        if (this.children.length > 0) {
            n.children = [];
            for(let a = 0; a < this.children.length; a++)n.children.push(this.children[a].toJSON(e).object);
        }
        if (this.animations.length > 0) {
            n.animations = [];
            for(let a = 0; a < this.animations.length; a++){
                let l = this.animations[a];
                n.animations.push(s(e.animations, l));
            }
        }
        if (t) {
            let a = o(e.geometries), l = o(e.materials), c = o(e.textures), h = o(e.images), u = o(e.shapes), f = o(e.skeletons), d = o(e.animations), p = o(e.nodes);
            a.length > 0 && (r.geometries = a), l.length > 0 && (r.materials = l), c.length > 0 && (r.textures = c), h.length > 0 && (r.images = h), u.length > 0 && (r.shapes = u), f.length > 0 && (r.skeletons = f), d.length > 0 && (r.animations = d), p.length > 0 && (r.nodes = p);
        }
        return r.object = n, r;
        function o(a) {
            let l = [];
            for(let c in a){
                let h = a[c];
                delete h.metadata, l.push(h);
            }
            return l;
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e);
    }
    copy(e, t = !0) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for(let r = 0; r < e.children.length; r++){
            let n = e.children[r];
            this.add(n.clone());
        }
        return this;
    }
};
ot.DefaultUp = new M(0, 1, 0);
ot.DefaultMatrixAutoUpdate = !0;
ot.prototype.isObject3D = !0;
var ri = new M, Ki = new M, Rm = new M, Zi = new M, pa = new M, ma = new M, f0 = new M, Bm = new M, Nm = new M, Om = new M, Jt = class {
    constructor(e = new M, t = new M, r = new M){
        this.a = e, this.b = t, this.c = r;
    }
    static getNormal(e, t, r, n) {
        n.subVectors(r, t), ri.subVectors(e, t), n.cross(ri);
        let s = n.lengthSq();
        return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
    }
    static getBarycoord(e, t, r, n, s) {
        ri.subVectors(n, t), Ki.subVectors(r, t), Rm.subVectors(e, t);
        let o = ri.dot(ri), a = ri.dot(Ki), l = ri.dot(Rm), c = Ki.dot(Ki), h = Ki.dot(Rm), u = o * c - a * a;
        if (u === 0) return s.set(-2, -1, -1);
        let f = 1 / u, d = (c * l - a * h) * f, p = (o * h - a * l) * f;
        return s.set(1 - d - p, p, d);
    }
    static containsPoint(e, t, r, n) {
        return this.getBarycoord(e, t, r, n, Zi), Zi.x >= 0 && Zi.y >= 0 && Zi.x + Zi.y <= 1;
    }
    static getUV(e, t, r, n, s, o, a, l) {
        return this.getBarycoord(e, t, r, n, Zi), l.set(0, 0), l.addScaledVector(s, Zi.x), l.addScaledVector(o, Zi.y), l.addScaledVector(a, Zi.z), l;
    }
    static isFrontFacing(e, t, r, n) {
        return ri.subVectors(r, t), Ki.subVectors(e, t), ri.cross(Ki).dot(n) < 0;
    }
    set(e, t, r) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
    }
    setFromPointsAndIndices(e, t, r, n) {
        return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
    }
    setFromAttributeAndIndices(e, t, r, n) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, n), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
        return ri.subVectors(this.c, this.b), Ki.subVectors(this.a, this.b), ri.cross(Ki).length() * .5;
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e) {
        return Jt.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
        return Jt.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getUV(e, t, r, n, s) {
        return Jt.getUV(e, this.a, this.b, this.c, t, r, n, s);
    }
    containsPoint(e) {
        return Jt.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
        return Jt.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
        let r = this.a, n = this.b, s = this.c, o, a;
        pa.subVectors(n, r), ma.subVectors(s, r), Bm.subVectors(e, r);
        let l = pa.dot(Bm), c = ma.dot(Bm);
        if (l <= 0 && c <= 0) return t.copy(r);
        Nm.subVectors(e, n);
        let h = pa.dot(Nm), u = ma.dot(Nm);
        if (h >= 0 && u <= h) return t.copy(n);
        let f = l * u - h * c;
        if (f <= 0 && l >= 0 && h <= 0) return o = l / (l - h), t.copy(r).addScaledVector(pa, o);
        Om.subVectors(e, s);
        let d = pa.dot(Om), p = ma.dot(Om);
        if (p >= 0 && d <= p) return t.copy(s);
        let m = d * c - l * p;
        if (m <= 0 && c >= 0 && p <= 0) return a = c / (c - p), t.copy(r).addScaledVector(ma, a);
        let g = h * p - d * u;
        if (g <= 0 && u - h >= 0 && d - p >= 0) return f0.subVectors(s, n), a = (u - h) / (u - h + (d - p)), t.copy(n).addScaledVector(f0, a);
        let v = 1 / (g + m + f);
        return o = m * v, a = f * v, t.copy(r).addScaledVector(pa, o).addScaledVector(ma, a);
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
}, s_ = 0, ur = class extends Yt {
    constructor(){
        super(), Object.defineProperty(this, "id", {
            value: s_++
        }), this.uuid = Un(), this.name = "", this.type = "Material", this.blending = Ps, this.side = ii, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = db, this.blendDst = pb, this.blendEquation = Ea, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = tg, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = RE, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Sm, this.stencilZFail = Sm, this.stencilZPass = Sm, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
        return this._alphaTest;
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(e) {
        if (e !== void 0) for(let t in e){
            let r = e[t];
            if (r === void 0) {
                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                continue;
            }
            if (t === "shading") {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r === fb;
                continue;
            }
            let n = this[t];
            if (n === void 0) {
                console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                continue;
            }
            n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[t] = r;
        }
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        let r = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== Ps && (r.blending = this.blending), this.side !== ii && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData);
        function n(s) {
            let o = [];
            for(let a in s){
                let l = s[a];
                delete l.metadata, o.push(l);
            }
            return o;
        }
        if (t) {
            let s = n(e.textures), o = n(e.images);
            s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o);
        }
        return r;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        let t = e.clippingPlanes, r = null;
        if (t !== null) {
            let n = t.length;
            r = new Array(n);
            for(let s = 0; s !== n; ++s)r[s] = t[s].clone();
        }
        return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
};
ur.prototype.isMaterial = !0;
ur.fromType = function() {
    return null;
};
var zn = class extends ur {
    constructor(e){
        super(), this.type = "MeshBasicMaterial", this.color = new be(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $f, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
};
zn.prototype.isMeshBasicMaterial = !0;
var vr = new M, Fu = new B, Ve = class {
    constructor(e, t, r){
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r === !0, this.usage = Hc, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0;
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setUsage(e) {
        return this.usage = e, this;
    }
    copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
    }
    copyAt(e, t, r) {
        e *= this.itemSize, r *= t.itemSize;
        for(let n = 0, s = this.itemSize; n < s; n++)this.array[e + n] = t.array[r + n];
        return this;
    }
    copyArray(e) {
        return this.array.set(e), this;
    }
    copyColorsArray(e) {
        let t = this.array, r = 0;
        for(let n = 0, s = e.length; n < s; n++){
            let o = e[n];
            o === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new be), t[r++] = o.r, t[r++] = o.g, t[r++] = o.b;
        }
        return this;
    }
    copyVector2sArray(e) {
        let t = this.array, r = 0;
        for(let n = 0, s = e.length; n < s; n++){
            let o = e[n];
            o === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), o = new B), t[r++] = o.x, t[r++] = o.y;
        }
        return this;
    }
    copyVector3sArray(e) {
        let t = this.array, r = 0;
        for(let n = 0, s = e.length; n < s; n++){
            let o = e[n];
            o === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new M), t[r++] = o.x, t[r++] = o.y, t[r++] = o.z;
        }
        return this;
    }
    copyVector4sArray(e) {
        let t = this.array, r = 0;
        for(let n = 0, s = e.length; n < s; n++){
            let o = e[n];
            o === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new Je), t[r++] = o.x, t[r++] = o.y, t[r++] = o.z, t[r++] = o.w;
        }
        return this;
    }
    applyMatrix3(e) {
        if (this.itemSize === 2) for(let t = 0, r = this.count; t < r; t++)Fu.fromBufferAttribute(this, t), Fu.applyMatrix3(e), this.setXY(t, Fu.x, Fu.y);
        else if (this.itemSize === 3) for(let t4 = 0, r4 = this.count; t4 < r4; t4++)vr.fromBufferAttribute(this, t4), vr.applyMatrix3(e), this.setXYZ(t4, vr.x, vr.y, vr.z);
        return this;
    }
    applyMatrix4(e) {
        for(let t = 0, r = this.count; t < r; t++)vr.fromBufferAttribute(this, t), vr.applyMatrix4(e), this.setXYZ(t, vr.x, vr.y, vr.z);
        return this;
    }
    applyNormalMatrix(e) {
        for(let t = 0, r = this.count; t < r; t++)vr.fromBufferAttribute(this, t), vr.applyNormalMatrix(e), this.setXYZ(t, vr.x, vr.y, vr.z);
        return this;
    }
    transformDirection(e) {
        for(let t = 0, r = this.count; t < r; t++)vr.fromBufferAttribute(this, t), vr.transformDirection(e), this.setXYZ(t, vr.x, vr.y, vr.z);
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    getX(e) {
        return this.array[e * this.itemSize];
    }
    setX(e, t) {
        return this.array[e * this.itemSize] = t, this;
    }
    getY(e) {
        return this.array[e * this.itemSize + 1];
    }
    setY(e, t) {
        return this.array[e * this.itemSize + 1] = t, this;
    }
    getZ(e) {
        return this.array[e * this.itemSize + 2];
    }
    setZ(e, t) {
        return this.array[e * this.itemSize + 2] = t, this;
    }
    getW(e) {
        return this.array[e * this.itemSize + 3];
    }
    setW(e, t) {
        return this.array[e * this.itemSize + 3] = t, this;
    }
    setXY(e, t, r) {
        return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this;
    }
    setXYZ(e, t, r, n) {
        return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this;
    }
    setXYZW(e, t, r, n, s) {
        return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = n, this.array[e + 3] = s, this;
    }
    onUpload(e) {
        return this.onUploadCallback = e, this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        let e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== Hc && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
    }
};
Ve.prototype.isBufferAttribute = !0;
var yf = class extends Ve {
    constructor(e, t, r){
        super(new Uint16Array(e), t, r);
    }
};
var Os = class extends Ve {
    constructor(e, t, r){
        super(new Uint32Array(e), t, r);
    }
}, hg = class extends Ve {
    constructor(e, t, r){
        super(new Uint16Array(e), t, r);
    }
};
hg.prototype.isFloat16BufferAttribute = !0;
var Ce = class extends Ve {
    constructor(e, t, r){
        super(new Float32Array(e), t, r);
    }
};
var o_ = 0, On = new Ae, Fm = new ot, ga = new M, _n = new Kt, Cc = new Kt, Cr = new M, Le = class extends Yt {
    constructor(){
        super(), Object.defineProperty(this, "id", {
            value: o_++
        }), this.uuid = Un(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {};
    }
    getIndex() {
        return this.index;
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (vb(e) ? Os : yf)(e, 1) : this.index = e, this;
    }
    getAttribute(e) {
        return this.attributes[e];
    }
    setAttribute(e, t) {
        return this.attributes[e] = t, this;
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this;
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0;
    }
    addGroup(e, t, r = 0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: r
        });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t;
    }
    applyMatrix4(e) {
        let t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
        let r = this.attributes.normal;
        if (r !== void 0) {
            let s = new Ft().getNormalMatrix(e);
            r.applyNormalMatrix(s), r.needsUpdate = !0;
        }
        let n = this.attributes.tangent;
        return n !== void 0 && (n.transformDirection(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e) {
        return On.makeRotationFromQuaternion(e), this.applyMatrix4(On), this;
    }
    rotateX(e) {
        return On.makeRotationX(e), this.applyMatrix4(On), this;
    }
    rotateY(e) {
        return On.makeRotationY(e), this.applyMatrix4(On), this;
    }
    rotateZ(e) {
        return On.makeRotationZ(e), this.applyMatrix4(On), this;
    }
    translate(e, t, r) {
        return On.makeTranslation(e, t, r), this.applyMatrix4(On), this;
    }
    scale(e, t, r) {
        return On.makeScale(e, t, r), this.applyMatrix4(On), this;
    }
    lookAt(e) {
        return Fm.lookAt(e), Fm.updateMatrix(), this.applyMatrix4(Fm.matrix), this;
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(ga).negate(), this.translate(ga.x, ga.y, ga.z), this;
    }
    setFromPoints(e) {
        let t = [];
        for(let r = 0, n = e.length; r < n; r++){
            let s = e[r];
            t.push(s.x, s.y, s.z || 0);
        }
        return this.setAttribute("position", new Ce(t, 3)), this;
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Kt);
        let e = this.attributes.position, t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new M(-1 / 0, -1 / 0, -1 / 0), new M(1 / 0, 1 / 0, 1 / 0));
            return;
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t) for(let r = 0, n = t.length; r < n; r++){
                let s = t[r];
                _n.setFromBufferAttribute(s), this.morphTargetsRelative ? (Cr.addVectors(this.boundingBox.min, _n.min), this.boundingBox.expandByPoint(Cr), Cr.addVectors(this.boundingBox.max, _n.max), this.boundingBox.expandByPoint(Cr)) : (this.boundingBox.expandByPoint(_n.min), this.boundingBox.expandByPoint(_n.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Lr);
        let e = this.attributes.position, t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new M, 1 / 0);
            return;
        }
        if (e) {
            let r = this.boundingSphere.center;
            if (_n.setFromBufferAttribute(e), t) for(let s = 0, o = t.length; s < o; s++){
                let a = t[s];
                Cc.setFromBufferAttribute(a), this.morphTargetsRelative ? (Cr.addVectors(_n.min, Cc.min), _n.expandByPoint(Cr), Cr.addVectors(_n.max, Cc.max), _n.expandByPoint(Cr)) : (_n.expandByPoint(Cc.min), _n.expandByPoint(Cc.max));
            }
            _n.getCenter(r);
            let n = 0;
            for(let s4 = 0, o4 = e.count; s4 < o4; s4++)Cr.fromBufferAttribute(e, s4), n = Math.max(n, r.distanceToSquared(Cr));
            if (t) for(let s5 = 0, o5 = t.length; s5 < o5; s5++){
                let a = t[s5], l = this.morphTargetsRelative;
                for(let c = 0, h = a.count; c < h; c++)Cr.fromBufferAttribute(a, c), l && (ga.fromBufferAttribute(e, c), Cr.add(ga)), n = Math.max(n, r.distanceToSquared(Cr));
            }
            this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    }
    computeTangents() {
        let e = this.index, t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
        }
        let r = e.array, n = t.position.array, s = t.normal.array, o = t.uv.array, a = n.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ve(new Float32Array(4 * a), 4));
        let l = this.getAttribute("tangent").array, c = [], h = [];
        for(let _6 = 0; _6 < a; _6++)c[_6] = new M, h[_6] = new M;
        let u = new M, f = new M, d = new M, p = new B, m = new B, g = new B, v = new M, y = new M;
        function w(_, C, I) {
            u.fromArray(n, _ * 3), f.fromArray(n, C * 3), d.fromArray(n, I * 3), p.fromArray(o, _ * 2), m.fromArray(o, C * 2), g.fromArray(o, I * 2), f.sub(u), d.sub(u), m.sub(p), g.sub(p);
            let N = 1 / (m.x * g.y - g.x * m.y);
            !isFinite(N) || (v.copy(f).multiplyScalar(g.y).addScaledVector(d, -m.y).multiplyScalar(N), y.copy(d).multiplyScalar(m.x).addScaledVector(f, -g.x).multiplyScalar(N), c[_].add(v), c[C].add(v), c[I].add(v), h[_].add(y), h[C].add(y), h[I].add(y));
        }
        let b = this.groups;
        b.length === 0 && (b = [
            {
                start: 0,
                count: r.length
            }
        ]);
        for(let _4 = 0, C5 = b.length; _4 < C5; ++_4){
            let I = b[_4], N = I.start, R = I.count;
            for(let k = N, G = N + R; k < G; k += 3)w(r[k + 0], r[k + 1], r[k + 2]);
        }
        let S = new M, T = new M, A = new M, x = new M;
        function E(_) {
            A.fromArray(s, _ * 3), x.copy(A);
            let C = c[_];
            S.copy(C), S.sub(A.multiplyScalar(A.dot(C))).normalize(), T.crossVectors(x, C);
            let N = T.dot(h[_]) < 0 ? -1 : 1;
            l[_ * 4] = S.x, l[_ * 4 + 1] = S.y, l[_ * 4 + 2] = S.z, l[_ * 4 + 3] = N;
        }
        for(let _5 = 0, C4 = b.length; _5 < C4; ++_5){
            let I = b[_5], N = I.start, R = I.count;
            for(let k = N, G = N + R; k < G; k += 3)E(r[k + 0]), E(r[k + 1]), E(r[k + 2]);
        }
    }
    computeVertexNormals() {
        let e = this.index, t = this.getAttribute("position");
        if (t !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0) r = new Ve(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
            else for(let f = 0, d = r.count; f < d; f++)r.setXYZ(f, 0, 0, 0);
            let n = new M, s = new M, o = new M, a = new M, l = new M, c = new M, h = new M, u = new M;
            if (e) for(let f4 = 0, d4 = e.count; f4 < d4; f4 += 3){
                let p = e.getX(f4 + 0), m = e.getX(f4 + 1), g = e.getX(f4 + 2);
                n.fromBufferAttribute(t, p), s.fromBufferAttribute(t, m), o.fromBufferAttribute(t, g), h.subVectors(o, s), u.subVectors(n, s), h.cross(u), a.fromBufferAttribute(r, p), l.fromBufferAttribute(r, m), c.fromBufferAttribute(r, g), a.add(h), l.add(h), c.add(h), r.setXYZ(p, a.x, a.y, a.z), r.setXYZ(m, l.x, l.y, l.z), r.setXYZ(g, c.x, c.y, c.z);
            }
            else for(let f5 = 0, d5 = t.count; f5 < d5; f5 += 3)n.fromBufferAttribute(t, f5 + 0), s.fromBufferAttribute(t, f5 + 1), o.fromBufferAttribute(t, f5 + 2), h.subVectors(o, s), u.subVectors(n, s), h.cross(u), r.setXYZ(f5 + 0, h.x, h.y, h.z), r.setXYZ(f5 + 1, h.x, h.y, h.z), r.setXYZ(f5 + 2, h.x, h.y, h.z);
            this.normalizeNormals(), r.needsUpdate = !0;
        }
    }
    merge(e, t) {
        if (!(e && e.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            return;
        }
        t === void 0 && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        let r = this.attributes;
        for(let n in r){
            if (e.attributes[n] === void 0) continue;
            let o = r[n].array, a = e.attributes[n], l = a.array, c = a.itemSize * t, h = Math.min(l.length, o.length - c);
            for(let u = 0, f = c; u < h; u++, f++)o[f] = l[u];
        }
        return this;
    }
    normalizeNormals() {
        let e = this.attributes.normal;
        for(let t = 0, r = e.count; t < r; t++)Cr.fromBufferAttribute(e, t), Cr.normalize(), e.setXYZ(t, Cr.x, Cr.y, Cr.z);
    }
    toNonIndexed() {
        function e(a, l) {
            let c = a.array, h = a.itemSize, u = a.normalized, f = new c.constructor(l.length * h), d = 0, p = 0;
            for(let m = 0, g = l.length; m < g; m++){
                a.isInterleavedBufferAttribute ? d = l[m] * a.data.stride + a.offset : d = l[m] * h;
                for(let v = 0; v < h; v++)f[p++] = c[d++];
            }
            return new Ve(f, h, u);
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        let t = new Le, r = this.index.array, n = this.attributes;
        for(let a6 in n){
            let l = n[a6], c = e(l, r);
            t.setAttribute(a6, c);
        }
        let s = this.morphAttributes;
        for(let a4 in s){
            let l = [], c = s[a4];
            for(let h = 0, u = c.length; h < u; h++){
                let f = c[h], d = e(f, r);
                l.push(d);
            }
            t.morphAttributes[a4] = l;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        let o = this.groups;
        for(let a5 = 0, l4 = o.length; a5 < l4; a5++){
            let c = o[a5];
            t.addGroup(c.start, c.count, c.materialIndex);
        }
        return t;
    }
    toJSON() {
        let e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            let l = this.parameters;
            for(let c in l)l[c] !== void 0 && (e[c] = l[c]);
            return e;
        }
        e.data = {
            attributes: {}
        };
        let t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        let r = this.attributes;
        for(let l in r){
            let c = r[l];
            e.data.attributes[l] = c.toJSON(e.data);
        }
        let n = {}, s = !1;
        for(let l5 in this.morphAttributes){
            let c = this.morphAttributes[l5], h = [];
            for(let u = 0, f = c.length; u < f; u++){
                let d = c[u];
                h.push(d.toJSON(e.data));
            }
            h.length > 0 && (n[l5] = h, s = !0);
        }
        s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
        let o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        let a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), e;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        let t = {};
        this.name = e.name;
        let r = e.index;
        r !== null && this.setIndex(r.clone(t));
        let n = e.attributes;
        for(let c in n){
            let h = n[c];
            this.setAttribute(c, h.clone(t));
        }
        let s = e.morphAttributes;
        for(let c4 in s){
            let h = [], u = s[c4];
            for(let f = 0, d = u.length; f < d; f++)h.push(u[f].clone(t));
            this.morphAttributes[c4] = h;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        let o = e.groups;
        for(let c5 = 0, h = o.length; c5 < h; c5++){
            let u = o[c5];
            this.addGroup(u.start, u.count, u.materialIndex);
        }
        let a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        let l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};
Le.prototype.isBufferGeometry = !0;
var d0 = new Ae, ya = new si, Um = new Lr, Ts = new M, Es = new M, _s = new M, zm = new M, Gm = new M, km = new M, Uu = new M, zu = new M, Gu = new M, ku = new B, Vu = new B, Hu = new B, Vm = new M, Wu = new M, Vt = class extends ot {
    constructor(e = new Le, t = new zn){
        super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e) {
        return super.copy(e), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
    }
    updateMorphTargets() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            let t = e.morphAttributes, r = Object.keys(t);
            if (r.length > 0) {
                let n = t[r[0]];
                if (n !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let s = 0, o = n.length; s < o; s++){
                        let a = n[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
                    }
                }
            }
        } else {
            let t = e.morphTargets;
            t !== void 0 && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    }
    raycast(e, t) {
        let r = this.geometry, n = this.material, s = this.matrixWorld;
        if (n === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(), Um.copy(r.boundingSphere), Um.applyMatrix4(s), e.ray.intersectsSphere(Um) === !1) || (d0.copy(s).invert(), ya.copy(e.ray).applyMatrix4(d0), r.boundingBox !== null && ya.intersectsBox(r.boundingBox) === !1)) return;
        let o;
        if (r.isBufferGeometry) {
            let a = r.index, l = r.attributes.position, c = r.morphAttributes.position, h = r.morphTargetsRelative, u = r.attributes.uv, f = r.attributes.uv2, d = r.groups, p = r.drawRange;
            if (a !== null) {
                if (Array.isArray(n)) for(let m = 0, g = d.length; m < g; m++){
                    let v = d[m], y = n[v.materialIndex], w = Math.max(v.start, p.start), b = Math.min(a.count, Math.min(v.start + v.count, p.start + p.count));
                    for(let S = w, T = b; S < T; S += 3){
                        let A = a.getX(S), x = a.getX(S + 1), E = a.getX(S + 2);
                        o = ju(this, y, e, ya, l, c, h, u, f, A, x, E), o && (o.faceIndex = Math.floor(S / 3), o.face.materialIndex = v.materialIndex, t.push(o));
                    }
                }
                else {
                    let m = Math.max(0, p.start), g = Math.min(a.count, p.start + p.count);
                    for(let v = m, y = g; v < y; v += 3){
                        let w = a.getX(v), b = a.getX(v + 1), S = a.getX(v + 2);
                        o = ju(this, n, e, ya, l, c, h, u, f, w, b, S), o && (o.faceIndex = Math.floor(v / 3), t.push(o));
                    }
                }
            } else if (l !== void 0) {
                if (Array.isArray(n)) for(let m = 0, g = d.length; m < g; m++){
                    let v = d[m], y = n[v.materialIndex], w = Math.max(v.start, p.start), b = Math.min(l.count, Math.min(v.start + v.count, p.start + p.count));
                    for(let S = w, T = b; S < T; S += 3){
                        let A = S, x = S + 1, E = S + 2;
                        o = ju(this, y, e, ya, l, c, h, u, f, A, x, E), o && (o.faceIndex = Math.floor(S / 3), o.face.materialIndex = v.materialIndex, t.push(o));
                    }
                }
                else {
                    let m = Math.max(0, p.start), g = Math.min(l.count, p.start + p.count);
                    for(let v = m, y = g; v < y; v += 3){
                        let w = v, b = v + 1, S = v + 2;
                        o = ju(this, n, e, ya, l, c, h, u, f, w, b, S), o && (o.faceIndex = Math.floor(v / 3), t.push(o));
                    }
                }
            }
        } else r.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
};
Vt.prototype.isMesh = !0;
function a_(i, e, t, r, n, s, o, a) {
    let l;
    if (e.side === Pr ? l = r.intersectTriangle(o, s, n, !0, a) : l = r.intersectTriangle(n, s, o, e.side !== or, a), l === null) return null;
    Wu.copy(a), Wu.applyMatrix4(i.matrixWorld);
    let c = t.ray.origin.distanceTo(Wu);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Wu.clone(),
        object: i
    };
}
function ju(i, e, t, r, n, s, o, a, l, c, h, u) {
    Ts.fromBufferAttribute(n, c), Es.fromBufferAttribute(n, h), _s.fromBufferAttribute(n, u);
    let f = i.morphTargetInfluences;
    if (s && f) {
        Uu.set(0, 0, 0), zu.set(0, 0, 0), Gu.set(0, 0, 0);
        for(let p = 0, m = s.length; p < m; p++){
            let g = f[p], v = s[p];
            g !== 0 && (zm.fromBufferAttribute(v, c), Gm.fromBufferAttribute(v, h), km.fromBufferAttribute(v, u), o ? (Uu.addScaledVector(zm, g), zu.addScaledVector(Gm, g), Gu.addScaledVector(km, g)) : (Uu.addScaledVector(zm.sub(Ts), g), zu.addScaledVector(Gm.sub(Es), g), Gu.addScaledVector(km.sub(_s), g)));
        }
        Ts.add(Uu), Es.add(zu), _s.add(Gu);
    }
    i.isSkinnedMesh && (i.boneTransform(c, Ts), i.boneTransform(h, Es), i.boneTransform(u, _s));
    let d = a_(i, e, t, r, Ts, Es, _s, Vm);
    if (d) {
        a && (ku.fromBufferAttribute(a, c), Vu.fromBufferAttribute(a, h), Hu.fromBufferAttribute(a, u), d.uv = Jt.getUV(Vm, Ts, Es, _s, ku, Vu, Hu, new B)), l && (ku.fromBufferAttribute(l, c), Vu.fromBufferAttribute(l, h), Hu.fromBufferAttribute(l, u), d.uv2 = Jt.getUV(Vm, Ts, Es, _s, ku, Vu, Hu, new B));
        let p = {
            a: c,
            b: h,
            c: u,
            normal: new M,
            materialIndex: 0
        };
        Jt.getNormal(Ts, Es, _s, p.normal), d.face = p;
    }
    return d;
}
var vn = class extends Le {
    constructor(e = 1, t = 1, r = 1, n = 1, s = 1, o = 1){
        super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: s,
            depthSegments: o
        };
        let a = this;
        n = Math.floor(n), s = Math.floor(s), o = Math.floor(o);
        let l = [], c = [], h = [], u = [], f = 0, d = 0;
        p("z", "y", "x", -1, -1, r, t, e, o, s, 0), p("z", "y", "x", 1, -1, r, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, r, t, n, o, 2), p("x", "z", "y", 1, -1, e, r, -t, n, o, 3), p("x", "y", "z", 1, -1, e, t, r, n, s, 4), p("x", "y", "z", -1, -1, e, t, -r, n, s, 5), this.setIndex(l), this.setAttribute("position", new Ce(c, 3)), this.setAttribute("normal", new Ce(h, 3)), this.setAttribute("uv", new Ce(u, 2));
        function p(m, g, v, y, w, b, S, T, A, x, E) {
            let _ = b / A, C = S / x, I = b / 2, N = S / 2, R = T / 2, k = A + 1, G = x + 1, te = 0, Q = 0, Y = new M;
            for(let F = 0; F < G; F++){
                let z = F * C - N;
                for(let O = 0; O < k; O++){
                    let j = O * _ - I;
                    Y[m] = j * y, Y[g] = z * w, Y[v] = R, c.push(Y.x, Y.y, Y.z), Y[m] = 0, Y[g] = 0, Y[v] = T > 0 ? 1 : -1, h.push(Y.x, Y.y, Y.z), u.push(O / A), u.push(1 - F / x), te += 1;
                }
            }
            for(let F4 = 0; F4 < x; F4++)for(let z = 0; z < A; z++){
                let O = f + z + k * F4, j = f + z + k * (F4 + 1), q = f + (z + 1) + k * (F4 + 1), J = f + (z + 1) + k * F4;
                l.push(O, j, J), l.push(j, q, J), Q += 6;
            }
            a.addGroup(d, Q, E), d += Q, f += te;
        }
    }
    static fromJSON(e) {
        return new vn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
    }
};
function Ba(i) {
    let e = {};
    for(let t in i){
        e[t] = {};
        for(let r in i[t]){
            let n = i[t][r];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? e[t][r] = n.clone() : Array.isArray(n) ? e[t][r] = n.slice() : e[t][r] = n;
        }
    }
    return e;
}
function Qr(i) {
    let e = {};
    for(let t = 0; t < i.length; t++){
        let r = Ba(i[t]);
        for(let n in r)e[n] = r[n];
    }
    return e;
}
var li = {
    clone: Ba,
    merge: Qr
}, l_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, c_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, Mt = class extends ur {
    constructor(e){
        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = l_, this.fragmentShader = c_, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [
                1,
                1,
                1
            ],
            uv: [
                0,
                0
            ],
            uv2: [
                0,
                0
            ]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
    }
    copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ba(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};
        for(let n in this.uniforms){
            let o = this.uniforms[n].value;
            o && o.isTexture ? t.uniforms[n] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[n] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[n] = {
                value: o
            };
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
        let r = {};
        for(let n4 in this.extensions)this.extensions[n4] === !0 && (r[n4] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r), t;
    }
};
Mt.prototype.isShaderMaterial = !0;
var Gn = class extends ot {
    constructor(){
        super(), this.type = "Camera", this.matrixWorldInverse = new Ae, this.projectionMatrix = new Ae, this.projectionMatrixInverse = new Ae;
    }
    copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
};
Gn.prototype.isCamera = !0;
var sr = class extends Gn {
    constructor(e = 50, t = 1, r = .1, n = 2e3){
        super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
    }
    setFocalLength(e) {
        let t = .5 * this.getFilmHeight() / e;
        this.fov = Wc * 2 * Math.atan(t), this.updateProjectionMatrix();
    }
    getFocalLength() {
        let e = Math.tan(Oc * .5 * this.fov);
        return .5 * this.getFilmHeight() / e;
    }
    getEffectiveFOV() {
        return Wc * 2 * Math.atan(Math.tan(Oc * .5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, r, n, s, o) {
        this.aspect = e / t, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        let e = this.near, t = e * Math.tan(Oc * .5 * this.fov) / this.zoom, r = 2 * t, n = this.aspect * r, s = -0.5 * n, o = this.view;
        if (this.view !== null && this.view.enabled) {
            let l = o.fullWidth, c = o.fullHeight;
            s += o.offsetX * n / l, t -= o.offsetY * r / c, n *= o.width / l, r *= o.height / c;
        }
        let a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, t, t - r, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
};
sr.prototype.isPerspectiveCamera = !0;
var va = 90, xa = 1, Xc = class extends ot {
    constructor(e, t, r){
        if (super(), this.type = "CubeCamera", r.isWebGLCubeRenderTarget !== !0) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
        }
        this.renderTarget = r;
        let n = new sr(va, xa, e, t);
        n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new M(1, 0, 0)), this.add(n);
        let s = new sr(va, xa, e, t);
        s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new M(-1, 0, 0)), this.add(s);
        let o = new sr(va, xa, e, t);
        o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new M(0, 1, 0)), this.add(o);
        let a = new sr(va, xa, e, t);
        a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new M(0, -1, 0)), this.add(a);
        let l = new sr(va, xa, e, t);
        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new M(0, 0, 1)), this.add(l);
        let c = new sr(va, xa, e, t);
        c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new M(0, 0, -1)), this.add(c);
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        let r = this.renderTarget, [n, s, o, a, l, c] = this.children, h = e.getRenderTarget(), u = e.toneMapping, f = e.xr.enabled;
        e.toneMapping = rs, e.xr.enabled = !1;
        let d = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, n), e.setRenderTarget(r, 1), e.render(t, s), e.setRenderTarget(r, 2), e.render(t, o), e.setRenderTarget(r, 3), e.render(t, a), e.setRenderTarget(r, 4), e.render(t, l), r.texture.generateMipmaps = d, e.setRenderTarget(r, 5), e.render(t, c), e.setRenderTarget(h), e.toneMapping = u, e.xr.enabled = f, r.texture.needsPMREMUpdate = !0;
    }
}, Fs = class extends Dt {
    constructor(e, t, r, n, s, o, a, l, c, h){
        e = e !== void 0 ? e : [], t = t !== void 0 ? t : Rs, super(e, t, r, n, s, o, a, l, c, h), this.flipY = !1;
    }
    get images() {
        return this.image;
    }
    set images(e) {
        this.image = e;
    }
};
Fs.prototype.isCubeTexture = !0;
var vf = class extends mt {
    constructor(e, t = {}){
        super(e, e, t);
        let r = {
            width: e,
            height: e,
            depth: 1
        }, n = [
            r,
            r,
            r,
            r,
            r,
            r
        ];
        this.texture = new Fs(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : ct;
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        let r = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }, n = new vn(5, 5, 5), s = new Mt({
            name: "CubemapFromEquirect",
            uniforms: Ba(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: Pr,
            blending: Ht
        });
        s.uniforms.tEquirect.value = t;
        let o = new Vt(n, s), a = t.minFilter;
        return t.minFilter === js && (t.minFilter = ct), new Xc(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
    }
    clear(e, t, r, n) {
        let s = e.getRenderTarget();
        for(let o = 0; o < 6; o++)e.setRenderTarget(this, o), e.clear(t, r, n);
        e.setRenderTarget(s);
    }
};
vf.prototype.isWebGLCubeRenderTarget = !0;
var Hm = new M, h_ = new M, u_ = new Ft, Gr = class {
    constructor(e = new M(1, 0, 0), t = 0){
        this.normal = e, this.constant = t;
    }
    set(e, t) {
        return this.normal.copy(e), this.constant = t, this;
    }
    setComponents(e, t, r, n) {
        return this.normal.set(e, t, r), this.constant = n, this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
    }
    setFromCoplanarPoints(e, t, r) {
        let n = Hm.subVectors(r, t).cross(h_.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, e), this;
    }
    copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this;
    }
    normalize() {
        let e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this;
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
    }
    intersectLine(e, t) {
        let r = e.delta(Hm), n = this.normal.dot(r);
        if (n === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        let s = -(e.start.dot(this.normal) + this.constant) / n;
        return s < 0 || s > 1 ? null : t.copy(r).multiplyScalar(s).add(e.start);
    }
    intersectsLine(e) {
        let t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
        return t < 0 && r > 0 || r < 0 && t > 0;
    }
    intersectsBox(e) {
        return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
        let r = t || u_.getNormalMatrix(e), n = this.coplanarPoint(Hm).applyMatrix4(e), s = this.normal.applyMatrix3(r).normalize();
        return this.constant = -n.dot(s), this;
    }
    translate(e) {
        return this.constant -= e.dot(this.normal), this;
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
        return new this.constructor().copy(this);
    }
};
Gr.prototype.isPlane = !0;
var ba = new Lr, qu = new M, Na = class {
    constructor(e = new Gr, t = new Gr, r = new Gr, n = new Gr, s = new Gr, o = new Gr){
        this.planes = [
            e,
            t,
            r,
            n,
            s,
            o
        ];
    }
    set(e, t, r, n, s, o) {
        let a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(r), a[3].copy(n), a[4].copy(s), a[5].copy(o), this;
    }
    copy(e) {
        let t = this.planes;
        for(let r = 0; r < 6; r++)t[r].copy(e.planes[r]);
        return this;
    }
    setFromProjectionMatrix(e) {
        let t = this.planes, r = e.elements, n = r[0], s = r[1], o = r[2], a = r[3], l = r[4], c = r[5], h = r[6], u = r[7], f = r[8], d = r[9], p = r[10], m = r[11], g = r[12], v = r[13], y = r[14], w = r[15];
        return t[0].setComponents(a - n, u - l, m - f, w - g).normalize(), t[1].setComponents(a + n, u + l, m + f, w + g).normalize(), t[2].setComponents(a + s, u + c, m + d, w + v).normalize(), t[3].setComponents(a - s, u - c, m - d, w - v).normalize(), t[4].setComponents(a - o, u - h, m - p, w - y).normalize(), t[5].setComponents(a + o, u + h, m + p, w + y).normalize(), this;
    }
    intersectsObject(e) {
        let t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(), ba.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ba);
    }
    intersectsSprite(e) {
        return ba.center.set(0, 0, 0), ba.radius = .7071067811865476, ba.applyMatrix4(e.matrixWorld), this.intersectsSphere(ba);
    }
    intersectsSphere(e) {
        let t = this.planes, r = e.center, n = -e.radius;
        for(let s = 0; s < 6; s++)if (t[s].distanceToPoint(r) < n) return !1;
        return !0;
    }
    intersectsBox(e) {
        let t = this.planes;
        for(let r = 0; r < 6; r++){
            let n = t[r];
            if (qu.x = n.normal.x > 0 ? e.max.x : e.min.x, qu.y = n.normal.y > 0 ? e.max.y : e.min.y, qu.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(qu) < 0) return !1;
        }
        return !0;
    }
    containsPoint(e) {
        let t = this.planes;
        for(let r = 0; r < 6; r++)if (t[r].distanceToPoint(e) < 0) return !1;
        return !0;
    }
    clone() {
        return new this.constructor().copy(this);
    }
};
function bb() {
    let i = null, e = !1, t = null, r = null;
    function n(s, o) {
        t(s, o), r = i.requestAnimationFrame(n);
    }
    return {
        start: function() {
            e !== !0 && t !== null && (r = i.requestAnimationFrame(n), e = !0);
        },
        stop: function() {
            i.cancelAnimationFrame(r), e = !1;
        },
        setAnimationLoop: function(s) {
            t = s;
        },
        setContext: function(s) {
            i = s;
        }
    };
}
function f_(i, e) {
    let t = e.isWebGL2, r = new WeakMap;
    function n(c, h) {
        let u = c.array, f = c.usage, d = i.createBuffer();
        i.bindBuffer(h, d), i.bufferData(h, u, f), c.onUploadCallback();
        let p;
        if (u instanceof Float32Array) p = 5126;
        else if (u instanceof Uint16Array) {
            if (c.isFloat16BufferAttribute) {
                if (t) p = 5131;
                else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            } else p = 5123;
        } else if (u instanceof Int16Array) p = 5122;
        else if (u instanceof Uint32Array) p = 5125;
        else if (u instanceof Int32Array) p = 5124;
        else if (u instanceof Int8Array) p = 5120;
        else if (u instanceof Uint8Array) p = 5121;
        else if (u instanceof Uint8ClampedArray) p = 5121;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
        return {
            buffer: d,
            type: p,
            bytesPerElement: u.BYTES_PER_ELEMENT,
            version: c.version
        };
    }
    function s(c, h, u) {
        let f = h.array, d = h.updateRange;
        i.bindBuffer(u, c), d.count === -1 ? i.bufferSubData(u, 0, f) : (t ? i.bufferSubData(u, d.offset * f.BYTES_PER_ELEMENT, f, d.offset, d.count) : i.bufferSubData(u, d.offset * f.BYTES_PER_ELEMENT, f.subarray(d.offset, d.offset + d.count)), d.count = -1);
    }
    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data), r.get(c);
    }
    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        let h = r.get(c);
        h && (i.deleteBuffer(h.buffer), r.delete(c));
    }
    function l(c, h) {
        if (c.isGLBufferAttribute) {
            let f = r.get(c);
            (!f || f.version < c.version) && r.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return;
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        let u = r.get(c);
        u === void 0 ? r.set(c, n(c, h)) : u.version < c.version && (s(u.buffer, c, h), u.version = c.version);
    }
    return {
        get: o,
        remove: a,
        update: l
    };
}
var is = class extends Le {
    constructor(e = 1, t = 1, r = 1, n = 1){
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: n
        };
        let s = e / 2, o = t / 2, a = Math.floor(r), l = Math.floor(n), c = a + 1, h = l + 1, u = e / a, f = t / l, d = [], p = [], m = [], g = [];
        for(let v = 0; v < h; v++){
            let y = v * f - o;
            for(let w = 0; w < c; w++){
                let b = w * u - s;
                p.push(b, -y, 0), m.push(0, 0, 1), g.push(w / a), g.push(1 - v / l);
            }
        }
        for(let v4 = 0; v4 < l; v4++)for(let y = 0; y < a; y++){
            let w = y + c * v4, b = y + c * (v4 + 1), S = y + 1 + c * (v4 + 1), T = y + 1 + c * v4;
            d.push(w, b, T), d.push(b, S, T);
        }
        this.setIndex(d), this.setAttribute("position", new Ce(p, 3)), this.setAttribute("normal", new Ce(m, 3)), this.setAttribute("uv", new Ce(g, 2));
    }
    static fromJSON(e) {
        return new is(e.width, e.height, e.widthSegments, e.heightSegments);
    }
}, d_ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, p_ = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, m_ = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, g_ = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, y_ = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, v_ = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, x_ = "vec3 transformed = vec3( position );", b_ = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, w_ = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, S_ = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, M_ = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, A_ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, T_ = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, E_ = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, __ = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, C_ = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, D_ = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, P_ = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, L_ = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, I_ = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, R_ = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, B_ = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, N_ = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, O_ = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, F_ = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, U_ = "gl_FragColor = linearToOutputTexel( gl_FragColor );", z_ = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, G_ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, k_ = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, V_ = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, H_ = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, W_ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, j_ = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, q_ = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Y_ = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, X_ = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Q_ = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, J_ = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, K_ = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Z_ = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`, $_ = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, eC = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, tC = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, rC = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, nC = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, iC = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, sC = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, oC = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, aC = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lC = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, cC = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, hC = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, uC = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, fC = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, dC = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, pC = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, mC = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, gC = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, yC = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, vC = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, xC = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, bC = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, wC = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, SC = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, MC = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, AC = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, TC = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, EC = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, _C = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, CC = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, DC = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, PC = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, LC = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, IC = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, RC = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, BC = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, NC = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, OC = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, FC = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, UC = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, zC = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, GC = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, kC = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, VC = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, HC = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, WC = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, jC = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, qC = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, YC = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, XC = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, QC = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, JC = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, KC = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, ZC = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, $C = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`, eD = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, tD = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, rD = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, nD = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, iD = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, sD = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, oD = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, aD = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, lD = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cD = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, hD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, uD = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, fD = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, dD = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, pD = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, mD = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, gD = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, yD = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, vD = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, xD = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, bD = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, wD = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, SD = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, MD = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, AD = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, TD = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ED = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, _D = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, CD = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, DD = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, PD = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, LD = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ID = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, RD = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, BD = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, ND = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, OD = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, FD = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, UD = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, zD = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, yt = {
    alphamap_fragment: d_,
    alphamap_pars_fragment: p_,
    alphatest_fragment: m_,
    alphatest_pars_fragment: g_,
    aomap_fragment: y_,
    aomap_pars_fragment: v_,
    begin_vertex: x_,
    beginnormal_vertex: b_,
    bsdfs: w_,
    bumpmap_pars_fragment: S_,
    clipping_planes_fragment: M_,
    clipping_planes_pars_fragment: A_,
    clipping_planes_pars_vertex: T_,
    clipping_planes_vertex: E_,
    color_fragment: __,
    color_pars_fragment: C_,
    color_pars_vertex: D_,
    color_vertex: P_,
    common: L_,
    cube_uv_reflection_fragment: I_,
    defaultnormal_vertex: R_,
    displacementmap_pars_vertex: B_,
    displacementmap_vertex: N_,
    emissivemap_fragment: O_,
    emissivemap_pars_fragment: F_,
    encodings_fragment: U_,
    encodings_pars_fragment: z_,
    envmap_fragment: G_,
    envmap_common_pars_fragment: k_,
    envmap_pars_fragment: V_,
    envmap_pars_vertex: H_,
    envmap_physical_pars_fragment: eC,
    envmap_vertex: W_,
    fog_vertex: j_,
    fog_pars_vertex: q_,
    fog_fragment: Y_,
    fog_pars_fragment: X_,
    gradientmap_pars_fragment: Q_,
    lightmap_fragment: J_,
    lightmap_pars_fragment: K_,
    lights_lambert_vertex: Z_,
    lights_pars_begin: $_,
    lights_toon_fragment: tC,
    lights_toon_pars_fragment: rC,
    lights_phong_fragment: nC,
    lights_phong_pars_fragment: iC,
    lights_physical_fragment: sC,
    lights_physical_pars_fragment: oC,
    lights_fragment_begin: aC,
    lights_fragment_maps: lC,
    lights_fragment_end: cC,
    logdepthbuf_fragment: hC,
    logdepthbuf_pars_fragment: uC,
    logdepthbuf_pars_vertex: fC,
    logdepthbuf_vertex: dC,
    map_fragment: pC,
    map_pars_fragment: mC,
    map_particle_fragment: gC,
    map_particle_pars_fragment: yC,
    metalnessmap_fragment: vC,
    metalnessmap_pars_fragment: xC,
    morphcolor_vertex: bC,
    morphnormal_vertex: wC,
    morphtarget_pars_vertex: SC,
    morphtarget_vertex: MC,
    normal_fragment_begin: AC,
    normal_fragment_maps: TC,
    normal_pars_fragment: EC,
    normal_pars_vertex: _C,
    normal_vertex: CC,
    normalmap_pars_fragment: DC,
    clearcoat_normal_fragment_begin: PC,
    clearcoat_normal_fragment_maps: LC,
    clearcoat_pars_fragment: IC,
    output_fragment: RC,
    packing: BC,
    premultiplied_alpha_fragment: NC,
    project_vertex: OC,
    dithering_fragment: FC,
    dithering_pars_fragment: UC,
    roughnessmap_fragment: zC,
    roughnessmap_pars_fragment: GC,
    shadowmap_pars_fragment: kC,
    shadowmap_pars_vertex: VC,
    shadowmap_vertex: HC,
    shadowmask_pars_fragment: WC,
    skinbase_vertex: jC,
    skinning_pars_vertex: qC,
    skinning_vertex: YC,
    skinnormal_vertex: XC,
    specularmap_fragment: QC,
    specularmap_pars_fragment: JC,
    tonemapping_fragment: KC,
    tonemapping_pars_fragment: ZC,
    transmission_fragment: $C,
    transmission_pars_fragment: eD,
    uv_pars_fragment: tD,
    uv_pars_vertex: rD,
    uv_vertex: nD,
    uv2_pars_fragment: iD,
    uv2_pars_vertex: sD,
    uv2_vertex: oD,
    worldpos_vertex: aD,
    background_vert: lD,
    background_frag: cD,
    cube_vert: hD,
    cube_frag: uD,
    depth_vert: fD,
    depth_frag: dD,
    distanceRGBA_vert: pD,
    distanceRGBA_frag: mD,
    equirect_vert: gD,
    equirect_frag: yD,
    linedashed_vert: vD,
    linedashed_frag: xD,
    meshbasic_vert: bD,
    meshbasic_frag: wD,
    meshlambert_vert: SD,
    meshlambert_frag: MD,
    meshmatcap_vert: AD,
    meshmatcap_frag: TD,
    meshnormal_vert: ED,
    meshnormal_frag: _D,
    meshphong_vert: CD,
    meshphong_frag: DD,
    meshphysical_vert: PD,
    meshphysical_frag: LD,
    meshtoon_vert: ID,
    meshtoon_frag: RD,
    points_vert: BD,
    points_frag: ND,
    shadow_vert: OD,
    shadow_frag: FD,
    sprite_vert: UD,
    sprite_frag: zD
}, we = {
    common: {
        diffuse: {
            value: new be(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Ft
        },
        uv2Transform: {
            value: new Ft
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new B(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new be(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new be(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Ft
        }
    },
    sprite: {
        diffuse: {
            value: new be(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new B(.5, .5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Ft
        }
    }
}, Ei = {
    basic: {
        uniforms: Qr([
            we.common,
            we.specularmap,
            we.envmap,
            we.aomap,
            we.lightmap,
            we.fog
        ]),
        vertexShader: yt.meshbasic_vert,
        fragmentShader: yt.meshbasic_frag
    },
    lambert: {
        uniforms: Qr([
            we.common,
            we.specularmap,
            we.envmap,
            we.aomap,
            we.lightmap,
            we.emissivemap,
            we.fog,
            we.lights,
            {
                emissive: {
                    value: new be(0)
                }
            }
        ]),
        vertexShader: yt.meshlambert_vert,
        fragmentShader: yt.meshlambert_frag
    },
    phong: {
        uniforms: Qr([
            we.common,
            we.specularmap,
            we.envmap,
            we.aomap,
            we.lightmap,
            we.emissivemap,
            we.bumpmap,
            we.normalmap,
            we.displacementmap,
            we.fog,
            we.lights,
            {
                emissive: {
                    value: new be(0)
                },
                specular: {
                    value: new be(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: yt.meshphong_vert,
        fragmentShader: yt.meshphong_frag
    },
    standard: {
        uniforms: Qr([
            we.common,
            we.envmap,
            we.aomap,
            we.lightmap,
            we.emissivemap,
            we.bumpmap,
            we.normalmap,
            we.displacementmap,
            we.roughnessmap,
            we.metalnessmap,
            we.fog,
            we.lights,
            {
                emissive: {
                    value: new be(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: yt.meshphysical_vert,
        fragmentShader: yt.meshphysical_frag
    },
    toon: {
        uniforms: Qr([
            we.common,
            we.aomap,
            we.lightmap,
            we.emissivemap,
            we.bumpmap,
            we.normalmap,
            we.displacementmap,
            we.gradientmap,
            we.fog,
            we.lights,
            {
                emissive: {
                    value: new be(0)
                }
            }
        ]),
        vertexShader: yt.meshtoon_vert,
        fragmentShader: yt.meshtoon_frag
    },
    matcap: {
        uniforms: Qr([
            we.common,
            we.bumpmap,
            we.normalmap,
            we.displacementmap,
            we.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: yt.meshmatcap_vert,
        fragmentShader: yt.meshmatcap_frag
    },
    points: {
        uniforms: Qr([
            we.points,
            we.fog
        ]),
        vertexShader: yt.points_vert,
        fragmentShader: yt.points_frag
    },
    dashed: {
        uniforms: Qr([
            we.common,
            we.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: yt.linedashed_vert,
        fragmentShader: yt.linedashed_frag
    },
    depth: {
        uniforms: Qr([
            we.common,
            we.displacementmap
        ]),
        vertexShader: yt.depth_vert,
        fragmentShader: yt.depth_frag
    },
    normal: {
        uniforms: Qr([
            we.common,
            we.bumpmap,
            we.normalmap,
            we.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: yt.meshnormal_vert,
        fragmentShader: yt.meshnormal_frag
    },
    sprite: {
        uniforms: Qr([
            we.sprite,
            we.fog
        ]),
        vertexShader: yt.sprite_vert,
        fragmentShader: yt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Ft
            },
            t2D: {
                value: null
            }
        },
        vertexShader: yt.background_vert,
        fragmentShader: yt.background_frag
    },
    cube: {
        uniforms: Qr([
            we.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: yt.cube_vert,
        fragmentShader: yt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: yt.equirect_vert,
        fragmentShader: yt.equirect_frag
    },
    distanceRGBA: {
        uniforms: Qr([
            we.common,
            we.displacementmap,
            {
                referencePosition: {
                    value: new M
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }
        ]),
        vertexShader: yt.distanceRGBA_vert,
        fragmentShader: yt.distanceRGBA_frag
    },
    shadow: {
        uniforms: Qr([
            we.lights,
            we.fog,
            {
                color: {
                    value: new be(0)
                },
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: yt.shadow_vert,
        fragmentShader: yt.shadow_frag
    }
};
Ei.physical = {
    uniforms: Qr([
        Ei.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new B(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new be(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new B
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new be(0)
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularColor: {
                value: new be(1, 1, 1)
            },
            specularColorMap: {
                value: null
            }
        }
    ]),
    vertexShader: yt.meshphysical_vert,
    fragmentShader: yt.meshphysical_frag
};
function GD(i, e, t, r, n, s) {
    let o = new be(0), a = n === !0 ? 0 : 1, l, c, h = null, u = 0, f = null;
    function d(m, g) {
        let v = !1, y = g.isScene === !0 ? g.background : null;
        y && y.isTexture && (y = e.get(y));
        let w = i.xr, b = w.getSession && w.getSession();
        b && b.environmentBlendMode === "additive" && (y = null), y === null ? p(o, a) : y && y.isColor && (p(y, 1), v = !0), (i.autoClear || v) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), y && (y.isCubeTexture || y.mapping === Ya) ? (c === void 0 && (c = new Vt(new vn(1, 1, 1), new Mt({
            name: "BackgroundCubeMaterial",
            uniforms: Ba(Ei.cube.uniforms),
            vertexShader: Ei.cube.vertexShader,
            fragmentShader: Ei.cube.fragmentShader,
            side: Pr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(S, T, A) {
            this.matrixWorld.copyPosition(A.matrixWorld);
        }, Object.defineProperty(c.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value;
            }
        }), r.update(c)), c.material.uniforms.envMap.value = y, c.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, (h !== y || u !== y.version || f !== i.toneMapping) && (c.material.needsUpdate = !0, h = y, u = y.version, f = i.toneMapping), c.layers.enableAll(), m.unshift(c, c.geometry, c.material, 0, 0, null)) : y && y.isTexture && (l === void 0 && (l = new Vt(new is(2, 2), new Mt({
            name: "BackgroundMaterial",
            uniforms: Ba(Ei.background.uniforms),
            vertexShader: Ei.background.vertexShader,
            fragmentShader: Ei.background.fragmentShader,
            side: ii,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
            get: function() {
                return this.uniforms.t2D.value;
            }
        }), r.update(l)), l.material.uniforms.t2D.value = y, y.matrixAutoUpdate === !0 && y.updateMatrix(), l.material.uniforms.uvTransform.value.copy(y.matrix), (h !== y || u !== y.version || f !== i.toneMapping) && (l.material.needsUpdate = !0, h = y, u = y.version, f = i.toneMapping), l.layers.enableAll(), m.unshift(l, l.geometry, l.material, 0, 0, null));
    }
    function p(m, g) {
        t.buffers.color.setClear(m.r, m.g, m.b, g, s);
    }
    return {
        getClearColor: function() {
            return o;
        },
        setClearColor: function(m, g = 1) {
            o.set(m), a = g, p(o, a);
        },
        getClearAlpha: function() {
            return a;
        },
        setClearAlpha: function(m) {
            a = m, p(o, a);
        },
        render: d
    };
}
function kD(i, e, t, r) {
    let n = i.getParameter(34921), s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = r.isWebGL2 || s !== null, a = {}, l = g(null), c = l, h = !1;
    function u(R, k, G, te, Q) {
        let Y = !1;
        if (o) {
            let F = m(te, G, k);
            c !== F && (c = F, d(c.object)), Y = v(R, te, G, Q), Y && y(R, te, G, Q);
        } else {
            let F = k.wireframe === !0;
            (c.geometry !== te.id || c.program !== G.id || c.wireframe !== F) && (c.geometry = te.id, c.program = G.id, c.wireframe = F, Y = !0);
        }
        Q !== null && t.update(Q, 34963), (Y || h) && (h = !1, x(R, k, G, te), Q !== null && i.bindBuffer(34963, t.get(Q).buffer));
    }
    function f() {
        return r.isWebGL2 ? i.createVertexArray() : s.createVertexArrayOES();
    }
    function d(R) {
        return r.isWebGL2 ? i.bindVertexArray(R) : s.bindVertexArrayOES(R);
    }
    function p(R) {
        return r.isWebGL2 ? i.deleteVertexArray(R) : s.deleteVertexArrayOES(R);
    }
    function m(R, k, G) {
        let te = G.wireframe === !0, Q = a[R.id];
        Q === void 0 && (Q = {}, a[R.id] = Q);
        let Y = Q[k.id];
        Y === void 0 && (Y = {}, Q[k.id] = Y);
        let F = Y[te];
        return F === void 0 && (F = g(f()), Y[te] = F), F;
    }
    function g(R) {
        let k = [], G = [], te = [];
        for(let Q = 0; Q < n; Q++)k[Q] = 0, G[Q] = 0, te[Q] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: k,
            enabledAttributes: G,
            attributeDivisors: te,
            object: R,
            attributes: {},
            index: null
        };
    }
    function v(R, k, G, te) {
        let Q = c.attributes, Y = k.attributes, F = 0, z = G.getAttributes();
        for(let O in z)if (z[O].location >= 0) {
            let q = Q[O], J = Y[O];
            if (J === void 0 && (O === "instanceMatrix" && R.instanceMatrix && (J = R.instanceMatrix), O === "instanceColor" && R.instanceColor && (J = R.instanceColor)), q === void 0 || q.attribute !== J || J && q.data !== J.data) return !0;
            F++;
        }
        return c.attributesNum !== F || c.index !== te;
    }
    function y(R, k, G, te) {
        let Q = {}, Y = k.attributes, F = 0, z = G.getAttributes();
        for(let O in z)if (z[O].location >= 0) {
            let q = Y[O];
            q === void 0 && (O === "instanceMatrix" && R.instanceMatrix && (q = R.instanceMatrix), O === "instanceColor" && R.instanceColor && (q = R.instanceColor));
            let J = {};
            J.attribute = q, q && q.data && (J.data = q.data), Q[O] = J, F++;
        }
        c.attributes = Q, c.attributesNum = F, c.index = te;
    }
    function w() {
        let R = c.newAttributes;
        for(let k = 0, G = R.length; k < G; k++)R[k] = 0;
    }
    function b(R) {
        S(R, 0);
    }
    function S(R, k) {
        let G = c.newAttributes, te = c.enabledAttributes, Q = c.attributeDivisors;
        G[R] = 1, te[R] === 0 && (i.enableVertexAttribArray(R), te[R] = 1), Q[R] !== k && ((r.isWebGL2 ? i : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](R, k), Q[R] = k);
    }
    function T() {
        let R = c.newAttributes, k = c.enabledAttributes;
        for(let G = 0, te = k.length; G < te; G++)k[G] !== R[G] && (i.disableVertexAttribArray(G), k[G] = 0);
    }
    function A(R, k, G, te, Q, Y) {
        r.isWebGL2 === !0 && (G === 5124 || G === 5125) ? i.vertexAttribIPointer(R, k, G, Q, Y) : i.vertexAttribPointer(R, k, G, te, Q, Y);
    }
    function x(R, k, G, te) {
        if (r.isWebGL2 === !1 && (R.isInstancedMesh || te.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
        w();
        let Q = te.attributes, Y = G.getAttributes(), F = k.defaultAttributeValues;
        for(let z in Y){
            let O = Y[z];
            if (O.location >= 0) {
                let j = Q[z];
                if (j === void 0 && (z === "instanceMatrix" && R.instanceMatrix && (j = R.instanceMatrix), z === "instanceColor" && R.instanceColor && (j = R.instanceColor)), j !== void 0) {
                    let q = j.normalized, J = j.itemSize, W = t.get(j);
                    if (W === void 0) continue;
                    let ge = W.buffer, oe = W.type, le = W.bytesPerElement;
                    if (j.isInterleavedBufferAttribute) {
                        let H = j.data, he = H.stride, K = j.offset;
                        if (H.isInstancedInterleavedBuffer) {
                            for(let V = 0; V < O.locationSize; V++)S(O.location + V, H.meshPerAttribute);
                            R.isInstancedMesh !== !0 && te._maxInstanceCount === void 0 && (te._maxInstanceCount = H.meshPerAttribute * H.count);
                        } else for(let V = 0; V < O.locationSize; V++)b(O.location + V);
                        i.bindBuffer(34962, ge);
                        for(let V4 = 0; V4 < O.locationSize; V4++)A(O.location + V4, J / O.locationSize, oe, q, he * le, (K + J / O.locationSize * V4) * le);
                    } else {
                        if (j.isInstancedBufferAttribute) {
                            for(let H = 0; H < O.locationSize; H++)S(O.location + H, j.meshPerAttribute);
                            R.isInstancedMesh !== !0 && te._maxInstanceCount === void 0 && (te._maxInstanceCount = j.meshPerAttribute * j.count);
                        } else for(let H = 0; H < O.locationSize; H++)b(O.location + H);
                        i.bindBuffer(34962, ge);
                        for(let H4 = 0; H4 < O.locationSize; H4++)A(O.location + H4, J / O.locationSize, oe, q, J * le, J / O.locationSize * H4 * le);
                    }
                } else if (F !== void 0) {
                    let q = F[z];
                    if (q !== void 0) switch(q.length){
                        case 2:
                            i.vertexAttrib2fv(O.location, q);
                            break;
                        case 3:
                            i.vertexAttrib3fv(O.location, q);
                            break;
                        case 4:
                            i.vertexAttrib4fv(O.location, q);
                            break;
                        default:
                            i.vertexAttrib1fv(O.location, q);
                    }
                }
            }
        }
        T();
    }
    function E() {
        I();
        for(let R in a){
            let k = a[R];
            for(let G in k){
                let te = k[G];
                for(let Q in te)p(te[Q].object), delete te[Q];
                delete k[G];
            }
            delete a[R];
        }
    }
    function _(R) {
        if (a[R.id] === void 0) return;
        let k = a[R.id];
        for(let G in k){
            let te = k[G];
            for(let Q in te)p(te[Q].object), delete te[Q];
            delete k[G];
        }
        delete a[R.id];
    }
    function C(R) {
        for(let k in a){
            let G = a[k];
            if (G[R.id] === void 0) continue;
            let te = G[R.id];
            for(let Q in te)p(te[Q].object), delete te[Q];
            delete G[R.id];
        }
    }
    function I() {
        N(), h = !0, c !== l && (c = l, d(c.object));
    }
    function N() {
        l.geometry = null, l.program = null, l.wireframe = !1;
    }
    return {
        setup: u,
        reset: I,
        resetDefaultState: N,
        dispose: E,
        releaseStatesOfGeometry: _,
        releaseStatesOfProgram: C,
        initAttributes: w,
        enableAttribute: b,
        disableUnusedAttributes: T
    };
}
function VD(i, e, t, r) {
    let n = r.isWebGL2, s;
    function o(c) {
        s = c;
    }
    function a(c, h) {
        i.drawArrays(s, c, h), t.update(h, s, 1);
    }
    function l(c, h, u) {
        if (u === 0) return;
        let f, d;
        if (n) f = i, d = "drawArraysInstanced";
        else if (f = e.get("ANGLE_instanced_arrays"), d = "drawArraysInstancedANGLE", f === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
        }
        f[d](s, c, h, u), t.update(h, s, u);
    }
    this.setMode = o, this.render = a, this.renderInstances = l;
}
function HD(i, e, t) {
    let r;
    function n() {
        if (r !== void 0) return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            let A = e.get("EXT_texture_filter_anisotropic");
            r = i.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else r = 0;
        return r;
    }
    function s(A) {
        if (A === "highp") {
            if (i.getShaderPrecisionFormat(35633, 36338).precision > 0 && i.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            A = "mediump";
        }
        return A === "mediump" && i.getShaderPrecisionFormat(35633, 36337).precision > 0 && i.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    let o = typeof WebGL2RenderingContext < "u" && i instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && i instanceof WebGL2ComputeRenderingContext, a = t.precision !== void 0 ? t.precision : "highp", l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
    let c = o || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, u = i.getParameter(34930), f = i.getParameter(35660), d = i.getParameter(3379), p = i.getParameter(34076), m = i.getParameter(34921), g = i.getParameter(36347), v = i.getParameter(36348), y = i.getParameter(36349), w = f > 0, b = o || e.has("OES_texture_float"), S = w && b, T = o ? i.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: n,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: u,
        maxVertexTextures: f,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: m,
        maxVertexUniforms: g,
        maxVaryings: v,
        maxFragmentUniforms: y,
        vertexTextures: w,
        floatFragmentTextures: b,
        floatVertexTextures: S,
        maxSamples: T
    };
}
function WD(i) {
    let e = this, t = null, r = 0, n = !1, s = !1, o = new Gr, a = new Ft, l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, f, d) {
        let p = u.length !== 0 || f || r !== 0 || n;
        return n = f, t = h(u, d, 0), r = u.length, p;
    }, this.beginShadows = function() {
        s = !0, h(null);
    }, this.endShadows = function() {
        s = !1, c();
    }, this.setState = function(u, f, d) {
        let p = u.clippingPlanes, m = u.clipIntersection, g = u.clipShadows, v = i.get(u);
        if (!n || p === null || p.length === 0 || s && !g) s ? h(null) : c();
        else {
            let y = s ? 0 : r, w = y * 4, b = v.clippingState || null;
            l.value = b, b = h(p, f, w, d);
            for(let S = 0; S !== w; ++S)b[S] = t[S];
            v.clippingState = b, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += y;
        }
    };
    function c() {
        l.value !== t && (l.value = t, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
    }
    function h(u, f, d, p) {
        let m = u !== null ? u.length : 0, g = null;
        if (m !== 0) {
            if (g = l.value, p !== !0 || g === null) {
                let v = d + m * 4, y = f.matrixWorldInverse;
                a.getNormalMatrix(y), (g === null || g.length < v) && (g = new Float32Array(v));
                for(let w = 0, b = d; w !== m; ++w, b += 4)o.copy(u[w]).applyMatrix4(y, a), o.normal.toArray(g, b), g[b + 3] = o.constant;
            }
            l.value = g, l.needsUpdate = !0;
        }
        return e.numPlanes = m, e.numIntersection = 0, g;
    }
}
function jD(i) {
    let e = new WeakMap;
    function t(o, a) {
        return a === rg ? o.mapping = Rs : a === ng && (o.mapping = Bs), o;
    }
    function r(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            let a = o.mapping;
            if (a === rg || a === ng) {
                if (e.has(o)) {
                    let l = e.get(o).texture;
                    return t(l, o.mapping);
                } else {
                    let l = o.image;
                    if (l && l.height > 0) {
                        let c = new vf(l.height / 2);
                        return c.fromEquirectangularTexture(i, o), e.set(o, c), o.addEventListener("dispose", n), t(c.texture, o.mapping);
                    } else return null;
                }
            }
        }
        return o;
    }
    function n(o) {
        let a = o.target;
        a.removeEventListener("dispose", n);
        let l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose());
    }
    function s() {
        e = new WeakMap;
    }
    return {
        get: r,
        dispose: s
    };
}
var Co = class extends Gn {
    constructor(e = -1, t = 1, r = 1, n = -1, s = .1, o = 2e3){
        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = n, this.near = s, this.far = o, this.updateProjectionMatrix();
    }
    copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
    }
    setViewOffset(e, t, r, n, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = n, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        let e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, s = r - e, o = r + e, a = n + t, l = n - t;
        if (this.view !== null && this.view.enabled) {
            let c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX, o = s + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
};
Co.prototype.isOrthographicCamera = !0;
var Da = 4, p0 = [
    .125,
    .215,
    .35,
    .446,
    .526,
    .582
], Ao = 20, Wm = new Co, m0 = new be, jm = null, Mo = (1 + Math.sqrt(5)) / 2, wa = 1 / Mo, g0 = [
    new M(1, 1, 1),
    new M(-1, 1, 1),
    new M(1, 1, -1),
    new M(-1, 1, -1),
    new M(0, Mo, wa),
    new M(0, Mo, -wa),
    new M(wa, 0, Mo),
    new M(-wa, 0, Mo),
    new M(Mo, wa, 0),
    new M(-Mo, wa, 0)
], xf = class {
    constructor(e){
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, r = .1, n = 100) {
        jm = this._renderer.getRenderTarget(), this._setSize(256);
        let s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(e, r, n, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = x0(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = v0(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for(let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(jm), e.scissorTest = !1, Yu(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
        e.mapping === Rs || e.mapping === Bs ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), jm = this._renderer.getRenderTarget();
        let r = t || this._allocateTargets();
        return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
    }
    _allocateTargets() {
        let e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = {
            magFilter: ct,
            minFilter: ct,
            generateMipmaps: !1,
            type: Vc,
            format: Fn,
            encoding: gn,
            depthBuffer: !1
        }, n = y0(e, t, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = y0(e, t, r);
            let { _lodMax: s  } = this;
            ({ sizeLods: this._sizeLods , lodPlanes: this._lodPlanes , sigmas: this._sigmas  } = qD(s)), this._blurMaterial = YD(s, e, t);
        }
        return n;
    }
    _compileMaterial(e) {
        let t = new Vt(this._lodPlanes[0], e);
        this._renderer.compile(t, Wm);
    }
    _sceneToCubeUV(e, t, r, n) {
        let a = new sr(90, 1, t, r), l = [
            1,
            -1,
            1,
            1,
            1,
            1
        ], c = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ], h = this._renderer, u = h.autoClear, f = h.toneMapping;
        h.getClearColor(m0), h.toneMapping = rs, h.autoClear = !1;
        let d = new zn({
            name: "PMREM.Background",
            side: Pr,
            depthWrite: !1,
            depthTest: !1
        }), p = new Vt(new vn, d), m = !1, g = e.background;
        g ? g.isColor && (d.color.copy(g), e.background = null, m = !0) : (d.color.copy(m0), m = !0);
        for(let v = 0; v < 6; v++){
            let y = v % 3;
            y === 0 ? (a.up.set(0, l[v], 0), a.lookAt(c[v], 0, 0)) : y === 1 ? (a.up.set(0, 0, l[v]), a.lookAt(0, c[v], 0)) : (a.up.set(0, l[v], 0), a.lookAt(0, 0, c[v]));
            let w = this._cubeSize;
            Yu(n, y * w, v > 2 ? w : 0, w, w), h.setRenderTarget(n), m && h.render(p, a), h.render(e, a);
        }
        p.geometry.dispose(), p.material.dispose(), h.toneMapping = f, h.autoClear = u, e.background = g;
    }
    _textureToCubeUV(e, t) {
        let r = this._renderer, n = e.mapping === Rs || e.mapping === Bs;
        n ? (this._cubemapMaterial === null && (this._cubemapMaterial = x0()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = v0());
        let s = n ? this._cubemapMaterial : this._equirectMaterial, o = new Vt(this._lodPlanes[0], s), a = s.uniforms;
        a.envMap.value = e;
        let l = this._cubeSize;
        Yu(t, 0, 0, 3 * l, 2 * l), r.setRenderTarget(t), r.render(o, Wm);
    }
    _applyPMREM(e) {
        let t = this._renderer, r = t.autoClear;
        t.autoClear = !1;
        for(let n = 1; n < this._lodPlanes.length; n++){
            let s = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1]), o = g0[(n - 1) % g0.length];
            this._blur(e, n - 1, n, s, o);
        }
        t.autoClear = r;
    }
    _blur(e, t, r, n, s) {
        let o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, r, n, "latitudinal", s), this._halfBlur(o, e, r, r, n, "longitudinal", s);
    }
    _halfBlur(e, t, r, n, s, o, a) {
        let l = this._renderer, c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        let h = 3, u = new Vt(this._lodPlanes[n], c), f = c.uniforms, d = this._sizeLods[r] - 1, p = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * Ao - 1), m = s / p, g = isFinite(s) ? 1 + Math.floor(h * m) : Ao;
        g > Ao && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Ao}`);
        let v = [], y = 0;
        for(let A = 0; A < Ao; ++A){
            let x = A / m, E = Math.exp(-x * x / 2);
            v.push(E), A === 0 ? y += E : A < g && (y += 2 * E);
        }
        for(let A4 = 0; A4 < v.length; A4++)v[A4] = v[A4] / y;
        f.envMap.value = e.texture, f.samples.value = g, f.weights.value = v, f.latitudinal.value = o === "latitudinal", a && (f.poleAxis.value = a);
        let { _lodMax: w  } = this;
        f.dTheta.value = p, f.mipInt.value = w - r;
        let b = this._sizeLods[n], S = 3 * b * (n > w - Da ? n - w + Da : 0), T = 4 * (this._cubeSize - b);
        Yu(t, S, T, 3 * b, 2 * b), l.setRenderTarget(t), l.render(u, Wm);
    }
};
function qD(i) {
    let e = [], t = [], r = [], n = i, s = i - Da + 1 + p0.length;
    for(let o = 0; o < s; o++){
        let a = Math.pow(2, n);
        t.push(a);
        let l = 1 / a;
        o > i - Da ? l = p0[o - i + Da - 1] : o === 0 && (l = 0), r.push(l);
        let c = 1 / (a - 2), h = -c, u = 1 + c, f = [
            h,
            h,
            u,
            h,
            u,
            u,
            h,
            h,
            u,
            u,
            h,
            u
        ], d = 6, p = 6, m = 3, g = 2, v = 1, y = new Float32Array(m * p * d), w = new Float32Array(g * p * d), b = new Float32Array(v * p * d);
        for(let T = 0; T < d; T++){
            let A = T % 3 * 2 / 3 - 1, x = T > 2 ? 0 : -1, E = [
                A,
                x,
                0,
                A + 2 / 3,
                x,
                0,
                A + 2 / 3,
                x + 1,
                0,
                A,
                x,
                0,
                A + 2 / 3,
                x + 1,
                0,
                A,
                x + 1,
                0
            ];
            y.set(E, m * p * T), w.set(f, g * p * T);
            let _ = [
                T,
                T,
                T,
                T,
                T,
                T
            ];
            b.set(_, v * p * T);
        }
        let S = new Le;
        S.setAttribute("position", new Ve(y, m)), S.setAttribute("uv", new Ve(w, g)), S.setAttribute("faceIndex", new Ve(b, v)), e.push(S), n > Da && n--;
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: r
    };
}
function y0(i, e, t) {
    let r = new mt(i, e, t);
    return r.texture.mapping = Ya, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
}
function Yu(i, e, t, r, n) {
    i.viewport.set(e, t, r, n), i.scissor.set(e, t, r, n);
}
function YD(i, e, t) {
    let r = new Float32Array(Ao), n = new M(0, 1, 0);
    return new Mt({
        name: "SphericalGaussianBlur",
        defines: {
            n: Ao,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${i}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: n
            }
        },
        vertexShader: ty(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Ht,
        depthTest: !1,
        depthWrite: !1
    });
}
function v0() {
    return new Mt({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: ty(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Ht,
        depthTest: !1,
        depthWrite: !1
    });
}
function x0() {
    return new Mt({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: ty(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Ht,
        depthTest: !1,
        depthWrite: !1
    });
}
function ty() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function XD(i) {
    let e = new WeakMap, t = null;
    function r(a) {
        if (a && a.isTexture) {
            let l = a.mapping, c = l === rg || l === ng, h = l === Rs || l === Bs;
            if (c || h) {
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let u = e.get(a);
                    return t === null && (t = new xf(i)), u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u), e.set(a, u), u.texture;
                } else {
                    if (e.has(a)) return e.get(a).texture;
                    {
                        let u = a.image;
                        if (c && u && u.height > 0 || h && u && n(u)) {
                            t === null && (t = new xf(i));
                            let f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, f), a.addEventListener("dispose", s), f.texture;
                        } else return null;
                    }
                }
            }
        }
        return a;
    }
    function n(a) {
        let l = 0, c = 6;
        for(let h = 0; h < c; h++)a[h] !== void 0 && l++;
        return l === c;
    }
    function s(a) {
        let l = a.target;
        l.removeEventListener("dispose", s);
        let c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose());
    }
    function o() {
        e = new WeakMap, t !== null && (t.dispose(), t = null);
    }
    return {
        get: r,
        dispose: o
    };
}
function QD(i) {
    let e = {};
    function t(r) {
        if (e[r] !== void 0) return e[r];
        let n;
        switch(r){
            case "WEBGL_depth_texture":
                n = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                n = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                n = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                n = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                n = i.getExtension(r);
        }
        return e[r] = n, n;
    }
    return {
        has: function(r) {
            return t(r) !== null;
        },
        init: function(r) {
            r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
        },
        get: function(r) {
            let n = t(r);
            return n === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), n;
        }
    };
}
function JD(i, e, t, r) {
    let n = {}, s = new WeakMap;
    function o(u) {
        let f = u.target;
        f.index !== null && e.remove(f.index);
        for(let p in f.attributes)e.remove(f.attributes[p]);
        f.removeEventListener("dispose", o), delete n[f.id];
        let d = s.get(f);
        d && (e.remove(d), s.delete(f)), r.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--;
    }
    function a(u, f) {
        return n[f.id] === !0 || (f.addEventListener("dispose", o), n[f.id] = !0, t.memory.geometries++), f;
    }
    function l(u) {
        let f = u.attributes;
        for(let p in f)e.update(f[p], 34962);
        let d = u.morphAttributes;
        for(let p4 in d){
            let m = d[p4];
            for(let g = 0, v = m.length; g < v; g++)e.update(m[g], 34962);
        }
    }
    function c(u) {
        let f = [], d = u.index, p = u.attributes.position, m = 0;
        if (d !== null) {
            let y = d.array;
            m = d.version;
            for(let w = 0, b = y.length; w < b; w += 3){
                let S = y[w + 0], T = y[w + 1], A = y[w + 2];
                f.push(S, T, T, A, A, S);
            }
        } else {
            let y = p.array;
            m = p.version;
            for(let w = 0, b = y.length / 3 - 1; w < b; w += 3){
                let S = w + 0, T = w + 1, A = w + 2;
                f.push(S, T, T, A, A, S);
            }
        }
        let g = new (vb(f) ? Os : yf)(f, 1);
        g.version = m;
        let v = s.get(u);
        v && e.remove(v), s.set(u, g);
    }
    function h(u) {
        let f = s.get(u);
        if (f) {
            let d = u.index;
            d !== null && f.version < d.version && c(u);
        } else c(u);
        return s.get(u);
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: h
    };
}
function KD(i, e, t, r) {
    let n = r.isWebGL2, s;
    function o(f) {
        s = f;
    }
    let a, l;
    function c(f) {
        a = f.type, l = f.bytesPerElement;
    }
    function h(f, d) {
        i.drawElements(s, d, a, f * l), t.update(d, s, 1);
    }
    function u(f, d, p) {
        if (p === 0) return;
        let m, g;
        if (n) m = i, g = "drawElementsInstanced";
        else if (m = e.get("ANGLE_instanced_arrays"), g = "drawElementsInstancedANGLE", m === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return;
        }
        m[g](s, d, a, f * l, p), t.update(d, s, p);
    }
    this.setMode = o, this.setIndex = c, this.render = h, this.renderInstances = u;
}
function ZD(i) {
    let e = {
        geometries: 0,
        textures: 0
    }, t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function r(s, o, a) {
        switch(t.calls++, o){
            case 4:
                t.triangles += a * (s / 3);
                break;
            case 1:
                t.lines += a * (s / 2);
                break;
            case 3:
                t.lines += a * (s - 1);
                break;
            case 2:
                t.lines += a * s;
                break;
            case 0:
                t.points += a * s;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break;
        }
    }
    function n() {
        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: n,
        update: r
    };
}
function $D(i, e) {
    return i[0] - e[0];
}
function eP(i, e) {
    return Math.abs(e[1]) - Math.abs(i[1]);
}
function qm(i, e) {
    let t = 1, r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
    r instanceof Int8Array ? t = 127 : r instanceof Int16Array ? t = 32767 : r instanceof Int32Array ? t = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), i.divideScalar(t);
}
function tP(i, e, t) {
    let r = {}, n = new Float32Array(8), s = new WeakMap, o = new Je, a = [];
    for(let c6 = 0; c6 < 8; c6++)a[c6] = [
        c6,
        0
    ];
    function l(c, h, u, f) {
        let d = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            let p = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, m = p !== void 0 ? p.length : 0, g = s.get(h);
            if (g === void 0 || g.count !== m) {
                let k = function() {
                    N.dispose(), s.delete(h), h.removeEventListener("dispose", k);
                };
                g !== void 0 && g.texture.dispose();
                let w = h.morphAttributes.position !== void 0, b = h.morphAttributes.normal !== void 0, S = h.morphAttributes.color !== void 0, T = h.morphAttributes.position || [], A = h.morphAttributes.normal || [], x = h.morphAttributes.color || [], E = 0;
                w === !0 && (E = 1), b === !0 && (E = 2), S === !0 && (E = 3);
                let _ = h.attributes.position.count * E, C = 1;
                _ > e.maxTextureSize && (C = Math.ceil(_ / e.maxTextureSize), _ = e.maxTextureSize);
                let I = new Float32Array(_ * C * 4 * m), N = new Ra(I, _, C, m);
                N.type = Ds, N.needsUpdate = !0;
                let R = E * 4;
                for(let G = 0; G < m; G++){
                    let te = T[G], Q = A[G], Y = x[G], F = _ * C * 4 * G;
                    for(let z = 0; z < te.count; z++){
                        let O = z * R;
                        w === !0 && (o.fromBufferAttribute(te, z), te.normalized === !0 && qm(o, te), I[F + O + 0] = o.x, I[F + O + 1] = o.y, I[F + O + 2] = o.z, I[F + O + 3] = 0), b === !0 && (o.fromBufferAttribute(Q, z), Q.normalized === !0 && qm(o, Q), I[F + O + 4] = o.x, I[F + O + 5] = o.y, I[F + O + 6] = o.z, I[F + O + 7] = 0), S === !0 && (o.fromBufferAttribute(Y, z), Y.normalized === !0 && qm(o, Y), I[F + O + 8] = o.x, I[F + O + 9] = o.y, I[F + O + 10] = o.z, I[F + O + 11] = Y.itemSize === 4 ? o.w : 1);
                    }
                }
                g = {
                    count: m,
                    texture: N,
                    size: new B(_, C)
                }, s.set(h, g), h.addEventListener("dispose", k);
            }
            let v = 0;
            for(let w = 0; w < d.length; w++)v += d[w];
            let y = h.morphTargetsRelative ? 1 : 1 - v;
            f.getUniforms().setValue(i, "morphTargetBaseInfluence", y), f.getUniforms().setValue(i, "morphTargetInfluences", d), f.getUniforms().setValue(i, "morphTargetsTexture", g.texture, t), f.getUniforms().setValue(i, "morphTargetsTextureSize", g.size);
        } else {
            let p = d === void 0 ? 0 : d.length, m = r[h.id];
            if (m === void 0 || m.length !== p) {
                m = [];
                for(let b = 0; b < p; b++)m[b] = [
                    b,
                    0
                ];
                r[h.id] = m;
            }
            for(let b = 0; b < p; b++){
                let S = m[b];
                S[0] = b, S[1] = d[b];
            }
            m.sort(eP);
            for(let b4 = 0; b4 < 8; b4++)b4 < p && m[b4][1] ? (a[b4][0] = m[b4][0], a[b4][1] = m[b4][1]) : (a[b4][0] = Number.MAX_SAFE_INTEGER, a[b4][1] = 0);
            a.sort($D);
            let g = h.morphAttributes.position, v = h.morphAttributes.normal, y = 0;
            for(let b5 = 0; b5 < 8; b5++){
                let S = a[b5], T = S[0], A = S[1];
                T !== Number.MAX_SAFE_INTEGER && A ? (g && h.getAttribute("morphTarget" + b5) !== g[T] && h.setAttribute("morphTarget" + b5, g[T]), v && h.getAttribute("morphNormal" + b5) !== v[T] && h.setAttribute("morphNormal" + b5, v[T]), n[b5] = A, y += A) : (g && h.hasAttribute("morphTarget" + b5) === !0 && h.deleteAttribute("morphTarget" + b5), v && h.hasAttribute("morphNormal" + b5) === !0 && h.deleteAttribute("morphNormal" + b5), n[b5] = 0);
            }
            let w = h.morphTargetsRelative ? 1 : 1 - y;
            f.getUniforms().setValue(i, "morphTargetBaseInfluence", w), f.getUniforms().setValue(i, "morphTargetInfluences", n);
        }
    }
    return {
        update: l
    };
}
function rP(i, e, t, r) {
    let n = new WeakMap;
    function s(l) {
        let c = r.render.frame, h = l.geometry, u = e.get(l, h);
        return n.get(u) !== c && (e.update(u), n.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), u;
    }
    function o() {
        n = new WeakMap;
    }
    function a(l) {
        let c = l.target;
        c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
    }
    return {
        update: s,
        dispose: o
    };
}
var wb = new Dt, Sb = new Ra, Mb = new qc, Ab = new Fs, b0 = [], w0 = [], S0 = new Float32Array(16), M0 = new Float32Array(9), A0 = new Float32Array(4);
function Qa(i, e, t) {
    let r = i[0];
    if (r <= 0 || r > 0) return i;
    let n = e * t, s = b0[n];
    if (s === void 0 && (s = new Float32Array(n), b0[n] = s), e !== 0) {
        r.toArray(s, 0);
        for(let o = 1, a = 0; o !== e; ++o)a += t, i[o].toArray(s, a);
    }
    return s;
}
function nn(i, e) {
    if (i.length !== e.length) return !1;
    for(let t = 0, r = i.length; t < r; t++)if (i[t] !== e[t]) return !1;
    return !0;
}
function sn(i, e) {
    for(let t = 0, r = e.length; t < r; t++)i[t] = e[t];
}
function ed(i, e) {
    let t = w0[e];
    t === void 0 && (t = new Int32Array(e), w0[e] = t);
    for(let r = 0; r !== e; ++r)t[r] = i.allocateTextureUnit();
    return t;
}
function nP(i, e) {
    let t = this.cache;
    t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
}
function iP(i, e) {
    let t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (nn(t, e)) return;
        i.uniform2fv(this.addr, e), sn(t, e);
    }
}
function sP(i, e) {
    let t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
        if (nn(t, e)) return;
        i.uniform3fv(this.addr, e), sn(t, e);
    }
}
function oP(i, e) {
    let t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (nn(t, e)) return;
        i.uniform4fv(this.addr, e), sn(t, e);
    }
}
function aP(i, e) {
    let t = this.cache, r = e.elements;
    if (r === void 0) {
        if (nn(t, e)) return;
        i.uniformMatrix2fv(this.addr, !1, e), sn(t, e);
    } else {
        if (nn(t, r)) return;
        A0.set(r), i.uniformMatrix2fv(this.addr, !1, A0), sn(t, r);
    }
}
function lP(i, e) {
    let t = this.cache, r = e.elements;
    if (r === void 0) {
        if (nn(t, e)) return;
        i.uniformMatrix3fv(this.addr, !1, e), sn(t, e);
    } else {
        if (nn(t, r)) return;
        M0.set(r), i.uniformMatrix3fv(this.addr, !1, M0), sn(t, r);
    }
}
function cP(i, e) {
    let t = this.cache, r = e.elements;
    if (r === void 0) {
        if (nn(t, e)) return;
        i.uniformMatrix4fv(this.addr, !1, e), sn(t, e);
    } else {
        if (nn(t, r)) return;
        S0.set(r), i.uniformMatrix4fv(this.addr, !1, S0), sn(t, r);
    }
}
function hP(i, e) {
    let t = this.cache;
    t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
}
function uP(i, e) {
    let t = this.cache;
    nn(t, e) || (i.uniform2iv(this.addr, e), sn(t, e));
}
function fP(i, e) {
    let t = this.cache;
    nn(t, e) || (i.uniform3iv(this.addr, e), sn(t, e));
}
function dP(i, e) {
    let t = this.cache;
    nn(t, e) || (i.uniform4iv(this.addr, e), sn(t, e));
}
function pP(i, e) {
    let t = this.cache;
    t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
}
function mP(i, e) {
    let t = this.cache;
    nn(t, e) || (i.uniform2uiv(this.addr, e), sn(t, e));
}
function gP(i, e) {
    let t = this.cache;
    nn(t, e) || (i.uniform3uiv(this.addr, e), sn(t, e));
}
function yP(i, e) {
    let t = this.cache;
    nn(t, e) || (i.uniform4uiv(this.addr, e), sn(t, e));
}
function vP(i, e, t) {
    let r = this.cache, n = t.allocateTextureUnit();
    r[0] !== n && (i.uniform1i(this.addr, n), r[0] = n), t.setTexture2D(e || wb, n);
}
function xP(i, e, t) {
    let r = this.cache, n = t.allocateTextureUnit();
    r[0] !== n && (i.uniform1i(this.addr, n), r[0] = n), t.setTexture3D(e || Mb, n);
}
function bP(i, e, t) {
    let r = this.cache, n = t.allocateTextureUnit();
    r[0] !== n && (i.uniform1i(this.addr, n), r[0] = n), t.setTextureCube(e || Ab, n);
}
function wP(i, e, t) {
    let r = this.cache, n = t.allocateTextureUnit();
    r[0] !== n && (i.uniform1i(this.addr, n), r[0] = n), t.setTexture2DArray(e || Sb, n);
}
function SP(i) {
    switch(i){
        case 5126:
            return nP;
        case 35664:
            return iP;
        case 35665:
            return sP;
        case 35666:
            return oP;
        case 35674:
            return aP;
        case 35675:
            return lP;
        case 35676:
            return cP;
        case 5124:
        case 35670:
            return hP;
        case 35667:
        case 35671:
            return uP;
        case 35668:
        case 35672:
            return fP;
        case 35669:
        case 35673:
            return dP;
        case 5125:
            return pP;
        case 36294:
            return mP;
        case 36295:
            return gP;
        case 36296:
            return yP;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return vP;
        case 35679:
        case 36299:
        case 36307:
            return xP;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return bP;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return wP;
    }
}
function MP(i, e) {
    i.uniform1fv(this.addr, e);
}
function AP(i, e) {
    let t = Qa(e, this.size, 2);
    i.uniform2fv(this.addr, t);
}
function TP(i, e) {
    let t = Qa(e, this.size, 3);
    i.uniform3fv(this.addr, t);
}
function EP(i, e) {
    let t = Qa(e, this.size, 4);
    i.uniform4fv(this.addr, t);
}
function _P(i, e) {
    let t = Qa(e, this.size, 4);
    i.uniformMatrix2fv(this.addr, !1, t);
}
function CP(i, e) {
    let t = Qa(e, this.size, 9);
    i.uniformMatrix3fv(this.addr, !1, t);
}
function DP(i, e) {
    let t = Qa(e, this.size, 16);
    i.uniformMatrix4fv(this.addr, !1, t);
}
function PP(i, e) {
    i.uniform1iv(this.addr, e);
}
function LP(i, e) {
    i.uniform2iv(this.addr, e);
}
function IP(i, e) {
    i.uniform3iv(this.addr, e);
}
function RP(i, e) {
    i.uniform4iv(this.addr, e);
}
function BP(i, e) {
    i.uniform1uiv(this.addr, e);
}
function NP(i, e) {
    i.uniform2uiv(this.addr, e);
}
function OP(i, e) {
    i.uniform3uiv(this.addr, e);
}
function FP(i, e) {
    i.uniform4uiv(this.addr, e);
}
function UP(i, e, t) {
    let r = e.length, n = ed(t, r);
    i.uniform1iv(this.addr, n);
    for(let s = 0; s !== r; ++s)t.setTexture2D(e[s] || wb, n[s]);
}
function zP(i, e, t) {
    let r = e.length, n = ed(t, r);
    i.uniform1iv(this.addr, n);
    for(let s = 0; s !== r; ++s)t.setTexture3D(e[s] || Mb, n[s]);
}
function GP(i, e, t) {
    let r = e.length, n = ed(t, r);
    i.uniform1iv(this.addr, n);
    for(let s = 0; s !== r; ++s)t.setTextureCube(e[s] || Ab, n[s]);
}
function kP(i, e, t) {
    let r = e.length, n = ed(t, r);
    i.uniform1iv(this.addr, n);
    for(let s = 0; s !== r; ++s)t.setTexture2DArray(e[s] || Sb, n[s]);
}
function VP(i) {
    switch(i){
        case 5126:
            return MP;
        case 35664:
            return AP;
        case 35665:
            return TP;
        case 35666:
            return EP;
        case 35674:
            return _P;
        case 35675:
            return CP;
        case 35676:
            return DP;
        case 5124:
        case 35670:
            return PP;
        case 35667:
        case 35671:
            return LP;
        case 35668:
        case 35672:
            return IP;
        case 35669:
        case 35673:
            return RP;
        case 5125:
            return BP;
        case 36294:
            return NP;
        case 36295:
            return OP;
        case 36296:
            return FP;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return UP;
        case 35679:
        case 36299:
        case 36307:
            return zP;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return GP;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return kP;
    }
}
function HP(i, e, t) {
    this.id = i, this.addr = t, this.cache = [], this.setValue = SP(e.type);
}
function WP(i, e, t) {
    this.id = i, this.addr = t, this.cache = [], this.size = e.size, this.setValue = VP(e.type);
}
function Tb(i) {
    this.id = i, this.seq = [], this.map = {};
}
Tb.prototype.setValue = function(i, e, t) {
    let r = this.seq;
    for(let n = 0, s = r.length; n !== s; ++n){
        let o = r[n];
        o.setValue(i, e[o.id], t);
    }
};
var Ym = /(\w+)(\])?(\[|\.)?/g;
function T0(i, e) {
    i.seq.push(e), i.map[e.id] = e;
}
function jP(i, e, t) {
    let r = i.name, n = r.length;
    for(Ym.lastIndex = 0;;){
        let s = Ym.exec(r), o = Ym.lastIndex, a = s[1], l = s[2] === "]", c = s[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === n) {
            T0(t, c === void 0 ? new HP(a, i, e) : new WP(a, i, e));
            break;
        } else {
            let u = t.map[a];
            u === void 0 && (u = new Tb(a), T0(t, u)), t = u;
        }
    }
}
function Is(i, e) {
    this.seq = [], this.map = {};
    let t = i.getProgramParameter(e, 35718);
    for(let r = 0; r < t; ++r){
        let n = i.getActiveUniform(e, r), s = i.getUniformLocation(e, n.name);
        jP(n, s, this);
    }
}
Is.prototype.setValue = function(i, e, t, r) {
    let n = this.map[e];
    n !== void 0 && n.setValue(i, t, r);
};
Is.prototype.setOptional = function(i, e, t) {
    let r = e[t];
    r !== void 0 && this.setValue(i, t, r);
};
Is.upload = function(i, e, t, r) {
    for(let n = 0, s = e.length; n !== s; ++n){
        let o = e[n], a = t[o.id];
        a.needsUpdate !== !1 && o.setValue(i, a.value, r);
    }
};
Is.seqWithValue = function(i, e) {
    let t = [];
    for(let r = 0, n = i.length; r !== n; ++r){
        let s = i[r];
        s.id in e && t.push(s);
    }
    return t;
};
function E0(i, e, t) {
    let r = i.createShader(e);
    return i.shaderSource(r, t), i.compileShader(r), r;
}
var qP = 0;
function YP(i, e) {
    let t = i.split(`
`), r = [], n = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
    for(let o = n; o < s; o++)r.push(o + 1 + ": " + t[o]);
    return r.join(`
`);
}
function XP(i) {
    switch(i){
        case gn:
            return [
                "Linear",
                "( value )"
            ];
        case je:
            return [
                "sRGB",
                "( value )"
            ];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", i), [
                "Linear",
                "( value )"
            ];
    }
}
function _0(i, e, t) {
    let r = i.getShaderParameter(e, 35713), n = i.getShaderInfoLog(e).trim();
    if (r && n === "") return "";
    let s = /ERROR: 0:(\d+)/.exec(n);
    if (s) {
        let o = parseInt(s[0]);
        return t.toUpperCase() + `

` + n + `

` + YP(i.getShaderSource(e), o);
    } else return n;
}
function QP(i, e) {
    let t = XP(e);
    return "vec4 " + i + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function JP(i, e) {
    let t;
    switch(e){
        case aE:
            t = "Linear";
            break;
        case lE:
            t = "Reinhard";
            break;
        case cE:
            t = "OptimizedCineon";
            break;
        case hE:
            t = "ACESFilmic";
            break;
        case uE:
            t = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
    }
    return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function KP(i) {
    return [
        i.extensionDerivatives || !!i.envMapCubeUVHeight || i.bumpMap || i.tangentSpaceNormalMap || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
        (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
        i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
        (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ].filter(Nc).join(`
`);
}
function ZP(i) {
    let e = [];
    for(let t in i){
        let r = i[t];
        r !== !1 && e.push("#define " + t + " " + r);
    }
    return e.join(`
`);
}
function $P(i, e) {
    let t = {}, r = i.getProgramParameter(e, 35721);
    for(let n = 0; n < r; n++){
        let s = i.getActiveAttrib(e, n), o = s.name, a = 1;
        s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[o] = {
            type: s.type,
            location: i.getAttribLocation(e, o),
            locationSize: a
        };
    }
    return t;
}
function Nc(i) {
    return i !== "";
}
function C0(i, e) {
    return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function D0(i, e) {
    return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
var eL = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ug(i) {
    return i.replace(eL, tL);
}
function tL(i, e) {
    let t = yt[e];
    if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
    return ug(t);
}
var rL = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, nL = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function P0(i) {
    return i.replace(nL, Eb).replace(rL, iL);
}
function iL(i, e, t, r) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Eb(i, e, t, r);
}
function Eb(i, e, t, r) {
    let n = "";
    for(let s = parseInt(e); s < parseInt(t); s++)n += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return n;
}
function L0(i) {
    let e = "precision " + i.precision + ` float;
precision ` + i.precision + " int;";
    return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function sL(i) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return i.shadowMapType === ub ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === Zg ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === Bc && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function oL(i) {
    let e = "ENVMAP_TYPE_CUBE";
    if (i.envMap) switch(i.envMapMode){
        case Rs:
        case Bs:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Ya:
            e = "ENVMAP_TYPE_CUBE_UV";
            break;
    }
    return e;
}
function aL(i) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (i.envMap) switch(i.envMapMode){
        case Bs:
            e = "ENVMAP_MODE_REFRACTION";
            break;
    }
    return e;
}
function lL(i) {
    let e = "ENVMAP_BLENDING_NONE";
    if (i.envMap) switch(i.combine){
        case $f:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case sE:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case oE:
            e = "ENVMAP_BLENDING_ADD";
            break;
    }
    return e;
}
function cL(i) {
    let e = i.envMapCubeUVHeight;
    if (e === null) return null;
    let t = Math.log2(e) - 2, r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
        texelHeight: r,
        maxMip: t
    };
}
function hL(i, e, t, r) {
    let n = i.getContext(), s = t.defines, o = t.vertexShader, a = t.fragmentShader, l = sL(t), c = oL(t), h = aL(t), u = lL(t), f = cL(t), d = t.isWebGL2 ? "" : KP(t), p = ZP(s), m = n.createProgram(), g, v, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (g = [
        p
    ].filter(Nc).join(`
`), g.length > 0 && (g += `
`), v = [
        d,
        p
    ].filter(Nc).join(`
`), v.length > 0 && (v += `
`)) : (g = [
        L0(t),
        "#define SHADER_NAME " + t.shaderName,
        p,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
        t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`
    ].filter(Nc).join(`
`), v = [
        d,
        L0(t),
        "#define SHADER_NAME " + t.shaderName,
        p,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + u : "",
        f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
        f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
        f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== rs ? "#define TONE_MAPPING" : "",
        t.toneMapping !== rs ? yt.tonemapping_pars_fragment : "",
        t.toneMapping !== rs ? JP("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        yt.encodings_pars_fragment,
        QP("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`
    ].filter(Nc).join(`
`)), o = ug(o), o = C0(o, t), o = D0(o, t), a = ug(a), a = C0(a, t), a = D0(a, t), o = P0(o), a = P0(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (y = `#version 300 es
`, g = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
    ].join(`
`) + `
` + g, v = [
        "#define varying in",
        t.glslVersion === t0 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        t.glslVersion === t0 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
    ].join(`
`) + `
` + v);
    let w = y + g + o, b = y + v + a, S = E0(n, 35633, w), T = E0(n, 35632, b);
    if (n.attachShader(m, S), n.attachShader(m, T), t.index0AttributeName !== void 0 ? n.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(m, 0, "position"), n.linkProgram(m), i.debug.checkShaderErrors) {
        let E = n.getProgramInfoLog(m).trim(), _ = n.getShaderInfoLog(S).trim(), C = n.getShaderInfoLog(T).trim(), I = !0, N = !0;
        if (n.getProgramParameter(m, 35714) === !1) {
            I = !1;
            let R = _0(n, S, "vertex"), k = _0(n, T, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(m, 35715) + `

Program Info Log: ` + E + `
` + R + `
` + k);
        } else E !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", E) : (_ === "" || C === "") && (N = !1);
        N && (this.diagnostics = {
            runnable: I,
            programLog: E,
            vertexShader: {
                log: _,
                prefix: g
            },
            fragmentShader: {
                log: C,
                prefix: v
            }
        });
    }
    n.deleteShader(S), n.deleteShader(T);
    let A;
    this.getUniforms = function() {
        return A === void 0 && (A = new Is(n, m)), A;
    };
    let x;
    return this.getAttributes = function() {
        return x === void 0 && (x = $P(n, m)), x;
    }, this.destroy = function() {
        r.releaseStatesOfProgram(this), n.deleteProgram(m), this.program = void 0;
    }, this.name = t.shaderName, this.id = qP++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = S, this.fragmentShader = T, this;
}
var uL = 0, fg = class {
    constructor(){
        this.shaderCache = new Map, this.materialCache = new Map;
    }
    update(e) {
        let t = e.vertexShader, r = e.fragmentShader, n = this._getShaderStage(t), s = this._getShaderStage(r), o = this._getShaderCacheForMaterial(e);
        return o.has(n) === !1 && (o.add(n), n.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this;
    }
    remove(e) {
        let t = this.materialCache.get(e);
        for (let r of t)r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
        let t = this.materialCache;
        return t.has(e) === !1 && t.set(e, new Set), t.get(e);
    }
    _getShaderStage(e) {
        let t = this.shaderCache;
        if (t.has(e) === !1) {
            let r = new dg(e);
            t.set(e, r);
        }
        return t.get(e);
    }
}, dg = class {
    constructor(e){
        this.id = uL++, this.code = e, this.usedTimes = 0;
    }
};
function fL(i, e, t, r, n, s, o) {
    let a = new Yc, l = new fg, c = [], h = n.isWebGL2, u = n.logarithmicDepthBuffer, f = n.vertexTextures, d = n.precision, p = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function m(x, E, _, C, I) {
        let N = C.fog, R = I.geometry, k = x.isMeshStandardMaterial ? C.environment : null, G = (x.isMeshStandardMaterial ? t : e).get(x.envMap || k), te = !!G && G.mapping === Ya ? G.image.height : null, Q = p[x.type];
        x.precision !== null && (d = n.getMaxPrecision(x.precision), d !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", d, "instead."));
        let Y = R.morphAttributes.position || R.morphAttributes.normal || R.morphAttributes.color, F = Y !== void 0 ? Y.length : 0, z = 0;
        R.morphAttributes.position !== void 0 && (z = 1), R.morphAttributes.normal !== void 0 && (z = 2), R.morphAttributes.color !== void 0 && (z = 3);
        let O, j, q, J;
        if (Q) {
            let H = Ei[Q];
            O = H.vertexShader, j = H.fragmentShader;
        } else O = x.vertexShader, j = x.fragmentShader, l.update(x), q = l.getVertexShaderID(x), J = l.getFragmentShaderID(x);
        let W = i.getRenderTarget(), ge = x.alphaTest > 0, oe = x.clearcoat > 0;
        return {
            isWebGL2: h,
            shaderID: Q,
            shaderName: x.type,
            vertexShader: O,
            fragmentShader: j,
            defines: x.defines,
            customVertexShaderID: q,
            customFragmentShaderID: J,
            isRawShaderMaterial: x.isRawShaderMaterial === !0,
            glslVersion: x.glslVersion,
            precision: d,
            instancing: I.isInstancedMesh === !0,
            instancingColor: I.isInstancedMesh === !0 && I.instanceColor !== null,
            supportsVertexTextures: f,
            outputEncoding: W === null ? i.outputEncoding : W.isXRRenderTarget === !0 ? W.texture.encoding : gn,
            map: !!x.map,
            matcap: !!x.matcap,
            envMap: !!G,
            envMapMode: G && G.mapping,
            envMapCubeUVHeight: te,
            lightMap: !!x.lightMap,
            aoMap: !!x.aoMap,
            emissiveMap: !!x.emissiveMap,
            bumpMap: !!x.bumpMap,
            normalMap: !!x.normalMap,
            objectSpaceNormalMap: x.normalMapType === IE,
            tangentSpaceNormalMap: x.normalMapType === Xa,
            decodeVideoTexture: !!x.map && x.map.isVideoTexture === !0 && x.map.encoding === je,
            clearcoat: oe,
            clearcoatMap: oe && !!x.clearcoatMap,
            clearcoatRoughnessMap: oe && !!x.clearcoatRoughnessMap,
            clearcoatNormalMap: oe && !!x.clearcoatNormalMap,
            displacementMap: !!x.displacementMap,
            roughnessMap: !!x.roughnessMap,
            metalnessMap: !!x.metalnessMap,
            specularMap: !!x.specularMap,
            specularIntensityMap: !!x.specularIntensityMap,
            specularColorMap: !!x.specularColorMap,
            opaque: x.transparent === !1 && x.blending === Ps,
            alphaMap: !!x.alphaMap,
            alphaTest: ge,
            gradientMap: !!x.gradientMap,
            sheen: x.sheen > 0,
            sheenColorMap: !!x.sheenColorMap,
            sheenRoughnessMap: !!x.sheenRoughnessMap,
            transmission: x.transmission > 0,
            transmissionMap: !!x.transmissionMap,
            thicknessMap: !!x.thicknessMap,
            combine: x.combine,
            vertexTangents: !!x.normalMap && !!R.attributes.tangent,
            vertexColors: x.vertexColors,
            vertexAlphas: x.vertexColors === !0 && !!R.attributes.color && R.attributes.color.itemSize === 4,
            vertexUvs: !!x.map || !!x.bumpMap || !!x.normalMap || !!x.specularMap || !!x.alphaMap || !!x.emissiveMap || !!x.roughnessMap || !!x.metalnessMap || !!x.clearcoatMap || !!x.clearcoatRoughnessMap || !!x.clearcoatNormalMap || !!x.displacementMap || !!x.transmissionMap || !!x.thicknessMap || !!x.specularIntensityMap || !!x.specularColorMap || !!x.sheenColorMap || !!x.sheenRoughnessMap,
            uvsVertexOnly: !(!!x.map || !!x.bumpMap || !!x.normalMap || !!x.specularMap || !!x.alphaMap || !!x.emissiveMap || !!x.roughnessMap || !!x.metalnessMap || !!x.clearcoatNormalMap || x.transmission > 0 || !!x.transmissionMap || !!x.thicknessMap || !!x.specularIntensityMap || !!x.specularColorMap || x.sheen > 0 || !!x.sheenColorMap || !!x.sheenRoughnessMap) && !!x.displacementMap,
            fog: !!N,
            useFog: x.fog === !0,
            fogExp2: N && N.isFogExp2,
            flatShading: !!x.flatShading,
            sizeAttenuation: x.sizeAttenuation,
            logarithmicDepthBuffer: u,
            skinning: I.isSkinnedMesh === !0,
            morphTargets: R.morphAttributes.position !== void 0,
            morphNormals: R.morphAttributes.normal !== void 0,
            morphColors: R.morphAttributes.color !== void 0,
            morphTargetsCount: F,
            morphTextureStride: z,
            numDirLights: E.directional.length,
            numPointLights: E.point.length,
            numSpotLights: E.spot.length,
            numRectAreaLights: E.rectArea.length,
            numHemiLights: E.hemi.length,
            numDirLightShadows: E.directionalShadowMap.length,
            numPointLightShadows: E.pointShadowMap.length,
            numSpotLightShadows: E.spotShadowMap.length,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: x.dithering,
            shadowMapEnabled: i.shadowMap.enabled && _.length > 0,
            shadowMapType: i.shadowMap.type,
            toneMapping: x.toneMapped ? i.toneMapping : rs,
            physicallyCorrectLights: i.physicallyCorrectLights,
            premultipliedAlpha: x.premultipliedAlpha,
            doubleSided: x.side === or,
            flipSided: x.side === Pr,
            useDepthPacking: !!x.depthPacking,
            depthPacking: x.depthPacking || 0,
            index0AttributeName: x.index0AttributeName,
            extensionDerivatives: x.extensions && x.extensions.derivatives,
            extensionFragDepth: x.extensions && x.extensions.fragDepth,
            extensionDrawBuffers: x.extensions && x.extensions.drawBuffers,
            extensionShaderTextureLOD: x.extensions && x.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: x.customProgramCacheKey()
        };
    }
    function g(x) {
        let E = [];
        if (x.shaderID ? E.push(x.shaderID) : (E.push(x.customVertexShaderID), E.push(x.customFragmentShaderID)), x.defines !== void 0) for(let _ in x.defines)E.push(_), E.push(x.defines[_]);
        return x.isRawShaderMaterial === !1 && (v(E, x), y(E, x), E.push(i.outputEncoding)), E.push(x.customProgramCacheKey), E.join();
    }
    function v(x, E) {
        x.push(E.precision), x.push(E.outputEncoding), x.push(E.envMapMode), x.push(E.envMapCubeUVHeight), x.push(E.combine), x.push(E.vertexUvs), x.push(E.fogExp2), x.push(E.sizeAttenuation), x.push(E.morphTargetsCount), x.push(E.morphAttributeCount), x.push(E.numDirLights), x.push(E.numPointLights), x.push(E.numSpotLights), x.push(E.numHemiLights), x.push(E.numRectAreaLights), x.push(E.numDirLightShadows), x.push(E.numPointLightShadows), x.push(E.numSpotLightShadows), x.push(E.shadowMapType), x.push(E.toneMapping), x.push(E.numClippingPlanes), x.push(E.numClipIntersection), x.push(E.depthPacking);
    }
    function y(x, E) {
        a.disableAll(), E.isWebGL2 && a.enable(0), E.supportsVertexTextures && a.enable(1), E.instancing && a.enable(2), E.instancingColor && a.enable(3), E.map && a.enable(4), E.matcap && a.enable(5), E.envMap && a.enable(6), E.lightMap && a.enable(7), E.aoMap && a.enable(8), E.emissiveMap && a.enable(9), E.bumpMap && a.enable(10), E.normalMap && a.enable(11), E.objectSpaceNormalMap && a.enable(12), E.tangentSpaceNormalMap && a.enable(13), E.clearcoat && a.enable(14), E.clearcoatMap && a.enable(15), E.clearcoatRoughnessMap && a.enable(16), E.clearcoatNormalMap && a.enable(17), E.displacementMap && a.enable(18), E.specularMap && a.enable(19), E.roughnessMap && a.enable(20), E.metalnessMap && a.enable(21), E.gradientMap && a.enable(22), E.alphaMap && a.enable(23), E.alphaTest && a.enable(24), E.vertexColors && a.enable(25), E.vertexAlphas && a.enable(26), E.vertexUvs && a.enable(27), E.vertexTangents && a.enable(28), E.uvsVertexOnly && a.enable(29), E.fog && a.enable(30), x.push(a.mask), a.disableAll(), E.useFog && a.enable(0), E.flatShading && a.enable(1), E.logarithmicDepthBuffer && a.enable(2), E.skinning && a.enable(3), E.morphTargets && a.enable(4), E.morphNormals && a.enable(5), E.morphColors && a.enable(6), E.premultipliedAlpha && a.enable(7), E.shadowMapEnabled && a.enable(8), E.physicallyCorrectLights && a.enable(9), E.doubleSided && a.enable(10), E.flipSided && a.enable(11), E.useDepthPacking && a.enable(12), E.dithering && a.enable(13), E.specularIntensityMap && a.enable(14), E.specularColorMap && a.enable(15), E.transmission && a.enable(16), E.transmissionMap && a.enable(17), E.thicknessMap && a.enable(18), E.sheen && a.enable(19), E.sheenColorMap && a.enable(20), E.sheenRoughnessMap && a.enable(21), E.decodeVideoTexture && a.enable(22), E.opaque && a.enable(23), x.push(a.mask);
    }
    function w(x) {
        let E = p[x.type], _;
        if (E) {
            let C = Ei[E];
            _ = li.clone(C.uniforms);
        } else _ = x.uniforms;
        return _;
    }
    function b(x, E) {
        let _;
        for(let C = 0, I = c.length; C < I; C++){
            let N = c[C];
            if (N.cacheKey === E) {
                _ = N, ++_.usedTimes;
                break;
            }
        }
        return _ === void 0 && (_ = new hL(i, E, x, s), c.push(_)), _;
    }
    function S(x) {
        if (--x.usedTimes === 0) {
            let E = c.indexOf(x);
            c[E] = c[c.length - 1], c.pop(), x.destroy();
        }
    }
    function T(x) {
        l.remove(x);
    }
    function A() {
        l.dispose();
    }
    return {
        getParameters: m,
        getProgramCacheKey: g,
        getUniforms: w,
        acquireProgram: b,
        releaseProgram: S,
        releaseShaderCache: T,
        programs: c,
        dispose: A
    };
}
function dL() {
    let i = new WeakMap;
    function e(s) {
        let o = i.get(s);
        return o === void 0 && (o = {}, i.set(s, o)), o;
    }
    function t(s) {
        i.delete(s);
    }
    function r(s, o, a) {
        i.get(s)[o] = a;
    }
    function n() {
        i = new WeakMap;
    }
    return {
        get: e,
        remove: t,
        update: r,
        dispose: n
    };
}
function pL(i, e) {
    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function I0(i, e) {
    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function R0() {
    let i = [], e = 0, t = [], r = [], n = [];
    function s() {
        e = 0, t.length = 0, r.length = 0, n.length = 0;
    }
    function o(u, f, d, p, m, g) {
        let v = i[e];
        return v === void 0 ? (v = {
            id: u.id,
            object: u,
            geometry: f,
            material: d,
            groupOrder: p,
            renderOrder: u.renderOrder,
            z: m,
            group: g
        }, i[e] = v) : (v.id = u.id, v.object = u, v.geometry = f, v.material = d, v.groupOrder = p, v.renderOrder = u.renderOrder, v.z = m, v.group = g), e++, v;
    }
    function a(u, f, d, p, m, g) {
        let v = o(u, f, d, p, m, g);
        d.transmission > 0 ? r.push(v) : d.transparent === !0 ? n.push(v) : t.push(v);
    }
    function l(u, f, d, p, m, g) {
        let v = o(u, f, d, p, m, g);
        d.transmission > 0 ? r.unshift(v) : d.transparent === !0 ? n.unshift(v) : t.unshift(v);
    }
    function c(u, f) {
        t.length > 1 && t.sort(u || pL), r.length > 1 && r.sort(f || I0), n.length > 1 && n.sort(f || I0);
    }
    function h() {
        for(let u = e, f = i.length; u < f; u++){
            let d = i[u];
            if (d.id === null) break;
            d.id = null, d.object = null, d.geometry = null, d.material = null, d.group = null;
        }
    }
    return {
        opaque: t,
        transmissive: r,
        transparent: n,
        init: s,
        push: a,
        unshift: l,
        finish: h,
        sort: c
    };
}
function mL() {
    let i = new WeakMap;
    function e(r, n) {
        let s;
        return i.has(r) === !1 ? (s = new R0, i.set(r, [
            s
        ])) : n >= i.get(r).length ? (s = new R0, i.get(r).push(s)) : s = i.get(r)[n], s;
    }
    function t() {
        i = new WeakMap;
    }
    return {
        get: e,
        dispose: t
    };
}
function gL() {
    let i = {};
    return {
        get: function(e) {
            if (i[e.id] !== void 0) return i[e.id];
            let t;
            switch(e.type){
                case "DirectionalLight":
                    t = {
                        direction: new M,
                        color: new be
                    };
                    break;
                case "SpotLight":
                    t = {
                        position: new M,
                        direction: new M,
                        color: new be,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new M,
                        color: new be,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new M,
                        skyColor: new be,
                        groundColor: new be
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new be,
                        position: new M,
                        halfWidth: new M,
                        halfHeight: new M
                    };
                    break;
            }
            return i[e.id] = t, t;
        }
    };
}
function yL() {
    let i = {};
    return {
        get: function(e) {
            if (i[e.id] !== void 0) return i[e.id];
            let t;
            switch(e.type){
                case "DirectionalLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new B
                    };
                    break;
                case "SpotLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new B
                    };
                    break;
                case "PointLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new B,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
            }
            return i[e.id] = t, t;
        }
    };
}
var vL = 0;
function xL(i, e) {
    return (e.castShadow ? 1 : 0) - (i.castShadow ? 1 : 0);
}
function bL(i, e) {
    let t = new gL, r = yL(), n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let h4 = 0; h4 < 9; h4++)n.probe.push(new M);
    let s = new M, o = new Ae, a = new Ae;
    function l(h, u) {
        let f = 0, d = 0, p = 0;
        for(let E = 0; E < 9; E++)n.probe[E].set(0, 0, 0);
        let m = 0, g = 0, v = 0, y = 0, w = 0, b = 0, S = 0, T = 0;
        h.sort(xL);
        let A = u !== !0 ? Math.PI : 1;
        for(let E4 = 0, _ = h.length; E4 < _; E4++){
            let C = h[E4], I = C.color, N = C.intensity, R = C.distance, k = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
            if (C.isAmbientLight) f += I.r * N * A, d += I.g * N * A, p += I.b * N * A;
            else if (C.isLightProbe) for(let G = 0; G < 9; G++)n.probe[G].addScaledVector(C.sh.coefficients[G], N);
            else if (C.isDirectionalLight) {
                let G = t.get(C);
                if (G.color.copy(C.color).multiplyScalar(C.intensity * A), C.castShadow) {
                    let te = C.shadow, Q = r.get(C);
                    Q.shadowBias = te.bias, Q.shadowNormalBias = te.normalBias, Q.shadowRadius = te.radius, Q.shadowMapSize = te.mapSize, n.directionalShadow[m] = Q, n.directionalShadowMap[m] = k, n.directionalShadowMatrix[m] = C.shadow.matrix, b++;
                }
                n.directional[m] = G, m++;
            } else if (C.isSpotLight) {
                let G = t.get(C);
                if (G.position.setFromMatrixPosition(C.matrixWorld), G.color.copy(I).multiplyScalar(N * A), G.distance = R, G.coneCos = Math.cos(C.angle), G.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), G.decay = C.decay, C.castShadow) {
                    let te = C.shadow, Q = r.get(C);
                    Q.shadowBias = te.bias, Q.shadowNormalBias = te.normalBias, Q.shadowRadius = te.radius, Q.shadowMapSize = te.mapSize, n.spotShadow[v] = Q, n.spotShadowMap[v] = k, n.spotShadowMatrix[v] = C.shadow.matrix, T++;
                }
                n.spot[v] = G, v++;
            } else if (C.isRectAreaLight) {
                let G = t.get(C);
                G.color.copy(I).multiplyScalar(N), G.halfWidth.set(C.width * .5, 0, 0), G.halfHeight.set(0, C.height * .5, 0), n.rectArea[y] = G, y++;
            } else if (C.isPointLight) {
                let G = t.get(C);
                if (G.color.copy(C.color).multiplyScalar(C.intensity * A), G.distance = C.distance, G.decay = C.decay, C.castShadow) {
                    let te = C.shadow, Q = r.get(C);
                    Q.shadowBias = te.bias, Q.shadowNormalBias = te.normalBias, Q.shadowRadius = te.radius, Q.shadowMapSize = te.mapSize, Q.shadowCameraNear = te.camera.near, Q.shadowCameraFar = te.camera.far, n.pointShadow[g] = Q, n.pointShadowMap[g] = k, n.pointShadowMatrix[g] = C.shadow.matrix, S++;
                }
                n.point[g] = G, g++;
            } else if (C.isHemisphereLight) {
                let G = t.get(C);
                G.skyColor.copy(C.color).multiplyScalar(N * A), G.groundColor.copy(C.groundColor).multiplyScalar(N * A), n.hemi[w] = G, w++;
            }
        }
        y > 0 && (e.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = we.LTC_FLOAT_1, n.rectAreaLTC2 = we.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (n.rectAreaLTC1 = we.LTC_HALF_1, n.rectAreaLTC2 = we.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), n.ambient[0] = f, n.ambient[1] = d, n.ambient[2] = p;
        let x = n.hash;
        (x.directionalLength !== m || x.pointLength !== g || x.spotLength !== v || x.rectAreaLength !== y || x.hemiLength !== w || x.numDirectionalShadows !== b || x.numPointShadows !== S || x.numSpotShadows !== T) && (n.directional.length = m, n.spot.length = v, n.rectArea.length = y, n.point.length = g, n.hemi.length = w, n.directionalShadow.length = b, n.directionalShadowMap.length = b, n.pointShadow.length = S, n.pointShadowMap.length = S, n.spotShadow.length = T, n.spotShadowMap.length = T, n.directionalShadowMatrix.length = b, n.pointShadowMatrix.length = S, n.spotShadowMatrix.length = T, x.directionalLength = m, x.pointLength = g, x.spotLength = v, x.rectAreaLength = y, x.hemiLength = w, x.numDirectionalShadows = b, x.numPointShadows = S, x.numSpotShadows = T, n.version = vL++);
    }
    function c(h, u) {
        let f = 0, d = 0, p = 0, m = 0, g = 0, v = u.matrixWorldInverse;
        for(let y = 0, w = h.length; y < w; y++){
            let b = h[y];
            if (b.isDirectionalLight) {
                let S = n.directional[f];
                S.direction.setFromMatrixPosition(b.matrixWorld), s.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(s), S.direction.transformDirection(v), f++;
            } else if (b.isSpotLight) {
                let S = n.spot[p];
                S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(v), S.direction.setFromMatrixPosition(b.matrixWorld), s.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(s), S.direction.transformDirection(v), p++;
            } else if (b.isRectAreaLight) {
                let S = n.rectArea[m];
                S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(v), a.identity(), o.copy(b.matrixWorld), o.premultiply(v), a.extractRotation(o), S.halfWidth.set(b.width * .5, 0, 0), S.halfHeight.set(0, b.height * .5, 0), S.halfWidth.applyMatrix4(a), S.halfHeight.applyMatrix4(a), m++;
            } else if (b.isPointLight) {
                let S = n.point[d];
                S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(v), d++;
            } else if (b.isHemisphereLight) {
                let S = n.hemi[g];
                S.direction.setFromMatrixPosition(b.matrixWorld), S.direction.transformDirection(v), g++;
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: n
    };
}
function B0(i, e) {
    let t = new bL(i, e), r = [], n = [];
    function s() {
        r.length = 0, n.length = 0;
    }
    function o(u) {
        r.push(u);
    }
    function a(u) {
        n.push(u);
    }
    function l(u) {
        t.setup(r, u);
    }
    function c(u) {
        t.setupView(r, u);
    }
    return {
        init: s,
        state: {
            lightsArray: r,
            shadowsArray: n,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    };
}
function wL(i, e) {
    let t = new WeakMap;
    function r(s, o = 0) {
        let a;
        return t.has(s) === !1 ? (a = new B0(i, e), t.set(s, [
            a
        ])) : o >= t.get(s).length ? (a = new B0(i, e), t.get(s).push(a)) : a = t.get(s)[o], a;
    }
    function n() {
        t = new WeakMap;
    }
    return {
        get: r,
        dispose: n
    };
}
var Qc = class extends ur {
    constructor(e){
        super(), this.type = "MeshDepthMaterial", this.depthPacking = Ir, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
    }
};
Qc.prototype.isMeshDepthMaterial = !0;
var Jc = class extends ur {
    constructor(e){
        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new M, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
    }
};
Jc.prototype.isMeshDistanceMaterial = !0;
var SL = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, ML = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function _b(i, e, t) {
    let r = new Na, n = new B, s = new B, o = new Je, a = new Qc({
        depthPacking: LE
    }), l = new Jc, c = {}, h = t.maxTextureSize, u = {
        0: Pr,
        1: ii,
        2: or
    }, f = new Mt({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new B
            },
            radius: {
                value: 4
            }
        },
        vertexShader: SL,
        fragmentShader: ML
    }), d = f.clone();
    d.defines.HORIZONTAL_PASS = 1;
    let p = new Le;
    p.setAttribute("position", new Ve(new Float32Array([
        -1,
        -1,
        .5,
        3,
        -1,
        .5,
        -1,
        3,
        .5
    ]), 3));
    let m = new Vt(p, f), g = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ub, this.render = function(b, S, T) {
        if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || b.length === 0) return;
        let A = i.getRenderTarget(), x = i.getActiveCubeFace(), E = i.getActiveMipmapLevel(), _ = i.state;
        _.setBlending(Ht), _.buffers.color.setClear(1, 1, 1, 1), _.buffers.depth.setTest(!0), _.setScissorTest(!1);
        for(let C = 0, I = b.length; C < I; C++){
            let N = b[C], R = N.shadow;
            if (R === void 0) {
                console.warn("THREE.WebGLShadowMap:", N, "has no shadow.");
                continue;
            }
            if (R.autoUpdate === !1 && R.needsUpdate === !1) continue;
            n.copy(R.mapSize);
            let k = R.getFrameExtents();
            if (n.multiply(k), s.copy(R.mapSize), (n.x > h || n.y > h) && (n.x > h && (s.x = Math.floor(h / k.x), n.x = s.x * k.x, R.mapSize.x = s.x), n.y > h && (s.y = Math.floor(h / k.y), n.y = s.y * k.y, R.mapSize.y = s.y)), R.map === null && !R.isPointLightShadow && this.type === Bc && (R.map = new mt(n.x, n.y), R.map.texture.name = N.name + ".shadowMap", R.mapPass = new mt(n.x, n.y), R.camera.updateProjectionMatrix()), R.map === null) {
                let te = {
                    minFilter: hr,
                    magFilter: hr,
                    format: Fn
                };
                R.map = new mt(n.x, n.y, te), R.map.texture.name = N.name + ".shadowMap", R.camera.updateProjectionMatrix();
            }
            i.setRenderTarget(R.map), i.clear();
            let G = R.getViewportCount();
            for(let te = 0; te < G; te++){
                let Q = R.getViewport(te);
                o.set(s.x * Q.x, s.y * Q.y, s.x * Q.z, s.y * Q.w), _.viewport(o), R.updateMatrices(N, te), r = R.getFrustum(), w(S, T, R.camera, N, this.type);
            }
            !R.isPointLightShadow && this.type === Bc && v(R, T), R.needsUpdate = !1;
        }
        g.needsUpdate = !1, i.setRenderTarget(A, x, E);
    };
    function v(b, S) {
        let T = e.update(m);
        f.defines.VSM_SAMPLES !== b.blurSamples && (f.defines.VSM_SAMPLES = b.blurSamples, d.defines.VSM_SAMPLES = b.blurSamples, f.needsUpdate = !0, d.needsUpdate = !0), f.uniforms.shadow_pass.value = b.map.texture, f.uniforms.resolution.value = b.mapSize, f.uniforms.radius.value = b.radius, i.setRenderTarget(b.mapPass), i.clear(), i.renderBufferDirect(S, null, T, f, m, null), d.uniforms.shadow_pass.value = b.mapPass.texture, d.uniforms.resolution.value = b.mapSize, d.uniforms.radius.value = b.radius, i.setRenderTarget(b.map), i.clear(), i.renderBufferDirect(S, null, T, d, m, null);
    }
    function y(b, S, T, A, x, E) {
        let _ = null, C = T.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
        if (C !== void 0 ? _ = C : _ = T.isPointLight === !0 ? l : a, i.localClippingEnabled && S.clipShadows === !0 && S.clippingPlanes.length !== 0 || S.displacementMap && S.displacementScale !== 0 || S.alphaMap && S.alphaTest > 0) {
            let I = _.uuid, N = S.uuid, R = c[I];
            R === void 0 && (R = {}, c[I] = R);
            let k = R[N];
            k === void 0 && (k = _.clone(), R[N] = k), _ = k;
        }
        return _.visible = S.visible, _.wireframe = S.wireframe, E === Bc ? _.side = S.shadowSide !== null ? S.shadowSide : S.side : _.side = S.shadowSide !== null ? S.shadowSide : u[S.side], _.alphaMap = S.alphaMap, _.alphaTest = S.alphaTest, _.clipShadows = S.clipShadows, _.clippingPlanes = S.clippingPlanes, _.clipIntersection = S.clipIntersection, _.displacementMap = S.displacementMap, _.displacementScale = S.displacementScale, _.displacementBias = S.displacementBias, _.wireframeLinewidth = S.wireframeLinewidth, _.linewidth = S.linewidth, T.isPointLight === !0 && _.isMeshDistanceMaterial === !0 && (_.referencePosition.setFromMatrixPosition(T.matrixWorld), _.nearDistance = A, _.farDistance = x), _;
    }
    function w(b, S, T, A, x) {
        if (b.visible === !1) return;
        if (b.layers.test(S.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && x === Bc) && (!b.frustumCulled || r.intersectsObject(b))) {
            b.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, b.matrixWorld);
            let C = e.update(b), I = b.material;
            if (Array.isArray(I)) {
                let N = C.groups;
                for(let R = 0, k = N.length; R < k; R++){
                    let G = N[R], te = I[G.materialIndex];
                    if (te && te.visible) {
                        let Q = y(b, te, A, T.near, T.far, x);
                        i.renderBufferDirect(T, null, C, Q, b, G);
                    }
                }
            } else if (I.visible) {
                let N = y(b, I, A, T.near, T.far, x);
                i.renderBufferDirect(T, null, C, N, b, null);
            }
        }
        let _ = b.children;
        for(let C = 0, I = _.length; C < I; C++)w(_[C], S, T, A, x);
    }
}
function AL(i, e, t) {
    let r = t.isWebGL2;
    function n() {
        let U = !1, Me = new Je, De = null, Ze = new Je(0, 0, 0, 0);
        return {
            setMask: function(Oe) {
                De !== Oe && !U && (i.colorMask(Oe, Oe, Oe, Oe), De = Oe);
            },
            setLocked: function(Oe) {
                U = Oe;
            },
            setClear: function(Oe, Qe, Te, $e, lt) {
                lt === !0 && (Oe *= $e, Qe *= $e, Te *= $e), Me.set(Oe, Qe, Te, $e), Ze.equals(Me) === !1 && (i.clearColor(Oe, Qe, Te, $e), Ze.copy(Me));
            },
            reset: function() {
                U = !1, De = null, Ze.set(-1, 0, 0, 0);
            }
        };
    }
    function s() {
        let U = !1, Me = null, De = null, Ze = null;
        return {
            setTest: function(Oe) {
                Oe ? J(2929) : W(2929);
            },
            setMask: function(Oe) {
                Me !== Oe && !U && (i.depthMask(Oe), Me = Oe);
            },
            setFunc: function(Oe) {
                if (De !== Oe) {
                    if (Oe) switch(Oe){
                        case ZT:
                            i.depthFunc(512);
                            break;
                        case $T:
                            i.depthFunc(519);
                            break;
                        case eE:
                            i.depthFunc(513);
                            break;
                        case tg:
                            i.depthFunc(515);
                            break;
                        case tE:
                            i.depthFunc(514);
                            break;
                        case rE:
                            i.depthFunc(518);
                            break;
                        case nE:
                            i.depthFunc(516);
                            break;
                        case iE:
                            i.depthFunc(517);
                            break;
                        default:
                            i.depthFunc(515);
                    }
                    else i.depthFunc(515);
                    De = Oe;
                }
            },
            setLocked: function(Oe) {
                U = Oe;
            },
            setClear: function(Oe) {
                Ze !== Oe && (i.clearDepth(Oe), Ze = Oe);
            },
            reset: function() {
                U = !1, Me = null, De = null, Ze = null;
            }
        };
    }
    function o() {
        let U = !1, Me = null, De = null, Ze = null, Oe = null, Qe = null, Te = null, $e = null, lt = null;
        return {
            setTest: function(dt) {
                U || (dt ? J(2960) : W(2960));
            },
            setMask: function(dt) {
                Me !== dt && !U && (i.stencilMask(dt), Me = dt);
            },
            setFunc: function(dt, Ut, Ur) {
                (De !== dt || Ze !== Ut || Oe !== Ur) && (i.stencilFunc(dt, Ut, Ur), De = dt, Ze = Ut, Oe = Ur);
            },
            setOp: function(dt, Ut, Ur) {
                (Qe !== dt || Te !== Ut || $e !== Ur) && (i.stencilOp(dt, Ut, Ur), Qe = dt, Te = Ut, $e = Ur);
            },
            setLocked: function(dt) {
                U = dt;
            },
            setClear: function(dt) {
                lt !== dt && (i.clearStencil(dt), lt = dt);
            },
            reset: function() {
                U = !1, Me = null, De = null, Ze = null, Oe = null, Qe = null, Te = null, $e = null, lt = null;
            }
        };
    }
    let a = new n, l = new s, c = new o, h = {}, u = {}, f = new WeakMap, d = [], p = null, m = !1, g = null, v = null, y = null, w = null, b = null, S = null, T = null, A = !1, x = null, E = null, _ = null, C = null, I = null, N = i.getParameter(35661), R = !1, k = 0, G = i.getParameter(7938);
    G.indexOf("WebGL") !== -1 ? (k = parseFloat(/^WebGL (\d)/.exec(G)[1]), R = k >= 1) : G.indexOf("OpenGL ES") !== -1 && (k = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]), R = k >= 2);
    let te = null, Q = {}, Y = i.getParameter(3088), F = i.getParameter(2978), z = new Je().fromArray(Y), O = new Je().fromArray(F);
    function j(U, Me, De) {
        let Ze = new Uint8Array(4), Oe = i.createTexture();
        i.bindTexture(U, Oe), i.texParameteri(U, 10241, 9728), i.texParameteri(U, 10240, 9728);
        for(let Qe = 0; Qe < De; Qe++)i.texImage2D(Me + Qe, 0, 6408, 1, 1, 0, 6408, 5121, Ze);
        return Oe;
    }
    let q = {};
    q[3553] = j(3553, 3553, 1), q[34067] = j(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), J(2929), l.setFunc(tg), Z(!1), ce(Ex), J(2884), K(Ht);
    function J(U) {
        h[U] !== !0 && (i.enable(U), h[U] = !0);
    }
    function W(U) {
        h[U] !== !1 && (i.disable(U), h[U] = !1);
    }
    function ge(U, Me) {
        return u[U] !== Me ? (i.bindFramebuffer(U, Me), u[U] = Me, r && (U === 36009 && (u[36160] = Me), U === 36160 && (u[36009] = Me)), !0) : !1;
    }
    function oe(U, Me) {
        let De = d, Ze = !1;
        if (U) {
            if (De = f.get(Me), De === void 0 && (De = [], f.set(Me, De)), U.isWebGLMultipleRenderTargets) {
                let Oe = U.texture;
                if (De.length !== Oe.length || De[0] !== 36064) {
                    for(let Qe = 0, Te = Oe.length; Qe < Te; Qe++)De[Qe] = 36064 + Qe;
                    De.length = Oe.length, Ze = !0;
                }
            } else De[0] !== 36064 && (De[0] = 36064, Ze = !0);
        } else De[0] !== 1029 && (De[0] = 1029, Ze = !0);
        Ze && (t.isWebGL2 ? i.drawBuffers(De) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(De));
    }
    function le(U) {
        return p !== U ? (i.useProgram(U), p = U, !0) : !1;
    }
    let H = {
        [Ea]: 32774,
        [kT]: 32778,
        [VT]: 32779
    };
    if (r) H[Px] = 32775, H[Lx] = 32776;
    else {
        let U = e.get("EXT_blend_minmax");
        U !== null && (H[Px] = U.MIN_EXT, H[Lx] = U.MAX_EXT);
    }
    let he = {
        [HT]: 0,
        [WT]: 1,
        [jT]: 768,
        [db]: 770,
        [KT]: 776,
        [QT]: 774,
        [YT]: 772,
        [qT]: 769,
        [pb]: 771,
        [JT]: 775,
        [XT]: 773
    };
    function K(U, Me, De, Ze, Oe, Qe, Te, $e) {
        if (U === Ht) {
            m === !0 && (W(3042), m = !1);
            return;
        }
        if (m === !1 && (J(3042), m = !0), U !== GT) {
            if (U !== g || $e !== A) {
                if ((v !== Ea || b !== Ea) && (i.blendEquation(32774), v = Ea, b = Ea), $e) switch(U){
                    case Ps:
                        i.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case _x:
                        i.blendFunc(1, 1);
                        break;
                    case Cx:
                        i.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case Dx:
                        i.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", U);
                        break;
                }
                else switch(U){
                    case Ps:
                        i.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case _x:
                        i.blendFunc(770, 1);
                        break;
                    case Cx:
                        i.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case Dx:
                        i.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", U);
                        break;
                }
                y = null, w = null, S = null, T = null, g = U, A = $e;
            }
            return;
        }
        Oe = Oe || Me, Qe = Qe || De, Te = Te || Ze, (Me !== v || Oe !== b) && (i.blendEquationSeparate(H[Me], H[Oe]), v = Me, b = Oe), (De !== y || Ze !== w || Qe !== S || Te !== T) && (i.blendFuncSeparate(he[De], he[Ze], he[Qe], he[Te]), y = De, w = Ze, S = Qe, T = Te), g = U, A = null;
    }
    function V(U, Me) {
        U.side === or ? W(2884) : J(2884);
        let De = U.side === Pr;
        Me && (De = !De), Z(De), U.blending === Ps && U.transparent === !1 ? K(Ht) : K(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.premultipliedAlpha), l.setFunc(U.depthFunc), l.setTest(U.depthTest), l.setMask(U.depthWrite), a.setMask(U.colorWrite);
        let Ze = U.stencilWrite;
        c.setTest(Ze), Ze && (c.setMask(U.stencilWriteMask), c.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), c.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), pe(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === !0 ? J(32926) : W(32926);
    }
    function Z(U) {
        x !== U && (U ? i.frontFace(2304) : i.frontFace(2305), x = U);
    }
    function ce(U) {
        U !== UT ? (J(2884), U !== E && (U === Ex ? i.cullFace(1029) : U === zT ? i.cullFace(1028) : i.cullFace(1032))) : W(2884), E = U;
    }
    function se(U) {
        U !== _ && (R && i.lineWidth(U), _ = U);
    }
    function pe(U, Me, De) {
        U ? (J(32823), (C !== Me || I !== De) && (i.polygonOffset(Me, De), C = Me, I = De)) : W(32823);
    }
    function ve(U) {
        U ? J(3089) : W(3089);
    }
    function me(U) {
        U === void 0 && (U = 33984 + N - 1), te !== U && (i.activeTexture(U), te = U);
    }
    function Pe(U, Me) {
        te === null && me();
        let De = Q[te];
        De === void 0 && (De = {
            type: void 0,
            texture: void 0
        }, Q[te] = De), (De.type !== U || De.texture !== Me) && (i.bindTexture(U, Me || q[U]), De.type = U, De.texture = Me);
    }
    function ke() {
        let U = Q[te];
        U !== void 0 && U.type !== void 0 && (i.bindTexture(U.type, null), U.type = void 0, U.texture = void 0);
    }
    function L() {
        try {
            i.compressedTexImage2D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function D() {
        try {
            i.texSubImage2D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function re() {
        try {
            i.texSubImage3D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function ye() {
        try {
            i.compressedTexSubImage2D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function Se() {
        try {
            i.texStorage2D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function Ie() {
        try {
            i.texStorage3D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function Fe() {
        try {
            i.texImage2D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function ue() {
        try {
            i.texImage3D.apply(i, arguments);
        } catch (U) {
            console.error("THREE.WebGLState:", U);
        }
    }
    function rt(U) {
        z.equals(U) === !1 && (i.scissor(U.x, U.y, U.z, U.w), z.copy(U));
    }
    function st(U) {
        O.equals(U) === !1 && (i.viewport(U.x, U.y, U.z, U.w), O.copy(U));
    }
    function Ee() {
        i.disable(3042), i.disable(2884), i.disable(2929), i.disable(32823), i.disable(3089), i.disable(2960), i.disable(32926), i.blendEquation(32774), i.blendFunc(1, 0), i.blendFuncSeparate(1, 0, 1, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(513), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(519, 0, 4294967295), i.stencilOp(7680, 7680, 7680), i.clearStencil(0), i.cullFace(1029), i.frontFace(2305), i.polygonOffset(0, 0), i.activeTexture(33984), i.bindFramebuffer(36160, null), r === !0 && (i.bindFramebuffer(36009, null), i.bindFramebuffer(36008, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), h = {}, te = null, Q = {}, u = {}, f = new WeakMap, d = [], p = null, m = !1, g = null, v = null, y = null, w = null, b = null, S = null, T = null, A = !1, x = null, E = null, _ = null, C = null, I = null, z.set(0, 0, i.canvas.width, i.canvas.height), O.set(0, 0, i.canvas.width, i.canvas.height), a.reset(), l.reset(), c.reset();
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: J,
        disable: W,
        bindFramebuffer: ge,
        drawBuffers: oe,
        useProgram: le,
        setBlending: K,
        setMaterial: V,
        setFlipSided: Z,
        setCullFace: ce,
        setLineWidth: se,
        setPolygonOffset: pe,
        setScissorTest: ve,
        activeTexture: me,
        bindTexture: Pe,
        unbindTexture: ke,
        compressedTexImage2D: L,
        texImage2D: Fe,
        texImage3D: ue,
        texStorage2D: Se,
        texStorage3D: Ie,
        texSubImage2D: D,
        texSubImage3D: re,
        compressedTexSubImage2D: ye,
        scissor: rt,
        viewport: st,
        reset: Ee
    };
}
function TL(i, e, t, r, n, s, o) {
    let a = n.isWebGL2, l = n.maxTextures, c = n.maxCubemapSize, h = n.maxTextureSize, u = n.maxSamples, f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, d = /OculusBrowser/g.test(navigator.userAgent), p = new WeakMap, m, g = new WeakMap, v = !1;
    try {
        v = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch  {}
    function y(L, D) {
        return v ? new OffscreenCanvas(L, D) : jc("canvas");
    }
    function w(L, D, re, ye) {
        let Se = 1;
        if ((L.width > ye || L.height > ye) && (Se = ye / Math.max(L.width, L.height)), Se < 1 || D === !0) {
            if (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && L instanceof ImageBitmap) {
                let Ie = D ? mf : Math.floor, Fe = Ie(Se * L.width), ue = Ie(Se * L.height);
                m === void 0 && (m = y(Fe, ue));
                let rt = re ? y(Fe, ue) : m;
                return rt.width = Fe, rt.height = ue, rt.getContext("2d").drawImage(L, 0, 0, Fe, ue), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + L.width + "x" + L.height + ") to (" + Fe + "x" + ue + ")."), rt;
            } else return "data" in L && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + L.width + "x" + L.height + ")."), L;
        }
        return L;
    }
    function b(L) {
        return og(L.width) && og(L.height);
    }
    function S(L) {
        return a ? !1 : L.wrapS !== Dr || L.wrapT !== Dr || L.minFilter !== hr && L.minFilter !== ct;
    }
    function T(L, D) {
        return L.generateMipmaps && D && L.minFilter !== hr && L.minFilter !== ct;
    }
    function A(L) {
        i.generateMipmap(L);
    }
    function x(L, D, re, ye, Se = !1) {
        if (a === !1) return D;
        if (L !== null) {
            if (i[L] !== void 0) return i[L];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + L + "'");
        }
        let Ie = D;
        return D === 6403 && (re === 5126 && (Ie = 33326), re === 5131 && (Ie = 33325), re === 5121 && (Ie = 33321)), D === 33319 && (re === 5126 && (Ie = 33328), re === 5131 && (Ie = 33327), re === 5121 && (Ie = 33323)), D === 6408 && (re === 5126 && (Ie = 34836), re === 5131 && (Ie = 34842), re === 5121 && (Ie = ye === je && Se === !1 ? 35907 : 32856), re === 32819 && (Ie = 32854), re === 32820 && (Ie = 32855)), (Ie === 33325 || Ie === 33326 || Ie === 33327 || Ie === 33328 || Ie === 34842 || Ie === 34836) && e.get("EXT_color_buffer_float"), Ie;
    }
    function E(L, D, re) {
        return T(L, re) === !0 || L.isFramebufferTexture && L.minFilter !== hr && L.minFilter !== ct ? Math.log2(Math.max(D.width, D.height)) + 1 : L.mipmaps !== void 0 && L.mipmaps.length > 0 ? L.mipmaps.length : L.isCompressedTexture && Array.isArray(L.image) ? D.mipmaps.length : 1;
    }
    function _(L) {
        return L === hr || L === Ix || L === Rx ? 9728 : 9729;
    }
    function C(L) {
        let D = L.target;
        D.removeEventListener("dispose", C), N(D), D.isVideoTexture && p.delete(D);
    }
    function I(L) {
        let D = L.target;
        D.removeEventListener("dispose", I), k(D);
    }
    function N(L) {
        let D = r.get(L);
        if (D.__webglInit === void 0) return;
        let re = L.source, ye = g.get(re);
        if (ye) {
            let Se = ye[D.__cacheKey];
            Se.usedTimes--, Se.usedTimes === 0 && R(L), Object.keys(ye).length === 0 && g.delete(re);
        }
        r.remove(L);
    }
    function R(L) {
        let D = r.get(L);
        i.deleteTexture(D.__webglTexture);
        let re = L.source, ye = g.get(re);
        delete ye[D.__cacheKey], o.memory.textures--;
    }
    function k(L) {
        let D = L.texture, re = r.get(L), ye = r.get(D);
        if (ye.__webglTexture !== void 0 && (i.deleteTexture(ye.__webglTexture), o.memory.textures--), L.depthTexture && L.depthTexture.dispose(), L.isWebGLCubeRenderTarget) for(let Se = 0; Se < 6; Se++)i.deleteFramebuffer(re.__webglFramebuffer[Se]), re.__webglDepthbuffer && i.deleteRenderbuffer(re.__webglDepthbuffer[Se]);
        else i.deleteFramebuffer(re.__webglFramebuffer), re.__webglDepthbuffer && i.deleteRenderbuffer(re.__webglDepthbuffer), re.__webglMultisampledFramebuffer && i.deleteFramebuffer(re.__webglMultisampledFramebuffer), re.__webglColorRenderbuffer && i.deleteRenderbuffer(re.__webglColorRenderbuffer), re.__webglDepthRenderbuffer && i.deleteRenderbuffer(re.__webglDepthRenderbuffer);
        if (L.isWebGLMultipleRenderTargets) for(let Se1 = 0, Ie = D.length; Se1 < Ie; Se1++){
            let Fe = r.get(D[Se1]);
            Fe.__webglTexture && (i.deleteTexture(Fe.__webglTexture), o.memory.textures--), r.remove(D[Se1]);
        }
        r.remove(D), r.remove(L);
    }
    let G = 0;
    function te() {
        G = 0;
    }
    function Q() {
        let L = G;
        return L >= l && console.warn("THREE.WebGLTextures: Trying to use " + L + " texture units while this GPU supports only " + l), G += 1, L;
    }
    function Y(L) {
        let D = [];
        return D.push(L.wrapS), D.push(L.wrapT), D.push(L.magFilter), D.push(L.minFilter), D.push(L.anisotropy), D.push(L.internalFormat), D.push(L.format), D.push(L.type), D.push(L.generateMipmaps), D.push(L.premultiplyAlpha), D.push(L.flipY), D.push(L.unpackAlignment), D.push(L.encoding), D.join();
    }
    function F(L, D) {
        let re = r.get(L);
        if (L.isVideoTexture && Pe(L), L.isRenderTargetTexture === !1 && L.version > 0 && re.__version !== L.version) {
            let ye = L.image;
            if (ye === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ye.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                oe(re, L, D);
                return;
            }
        }
        t.activeTexture(33984 + D), t.bindTexture(3553, re.__webglTexture);
    }
    function z(L, D) {
        let re = r.get(L);
        if (L.version > 0 && re.__version !== L.version) {
            oe(re, L, D);
            return;
        }
        t.activeTexture(33984 + D), t.bindTexture(35866, re.__webglTexture);
    }
    function O(L, D) {
        let re = r.get(L);
        if (L.version > 0 && re.__version !== L.version) {
            oe(re, L, D);
            return;
        }
        t.activeTexture(33984 + D), t.bindTexture(32879, re.__webglTexture);
    }
    function j(L, D) {
        let re = r.get(L);
        if (L.version > 0 && re.__version !== L.version) {
            le(re, L, D);
            return;
        }
        t.activeTexture(33984 + D), t.bindTexture(34067, re.__webglTexture);
    }
    let q = {
        [Ia]: 10497,
        [Dr]: 33071,
        [ig]: 33648
    }, J = {
        [hr]: 9728,
        [Ix]: 9984,
        [Rx]: 9986,
        [ct]: 9729,
        [fE]: 9985,
        [js]: 9987
    };
    function W(L, D, re) {
        if (re ? (i.texParameteri(L, 10242, q[D.wrapS]), i.texParameteri(L, 10243, q[D.wrapT]), (L === 32879 || L === 35866) && i.texParameteri(L, 32882, q[D.wrapR]), i.texParameteri(L, 10240, J[D.magFilter]), i.texParameteri(L, 10241, J[D.minFilter])) : (i.texParameteri(L, 10242, 33071), i.texParameteri(L, 10243, 33071), (L === 32879 || L === 35866) && i.texParameteri(L, 32882, 33071), (D.wrapS !== Dr || D.wrapT !== Dr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(L, 10240, _(D.magFilter)), i.texParameteri(L, 10241, _(D.minFilter)), D.minFilter !== hr && D.minFilter !== ct && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
            let ye = e.get("EXT_texture_filter_anisotropic");
            if (D.type === Ds && e.has("OES_texture_float_linear") === !1 || a === !1 && D.type === Vc && e.has("OES_texture_half_float_linear") === !1) return;
            (D.anisotropy > 1 || r.get(D).__currentAnisotropy) && (i.texParameterf(L, ye.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(D.anisotropy, n.getMaxAnisotropy())), r.get(D).__currentAnisotropy = D.anisotropy);
        }
    }
    function ge(L, D) {
        let re = !1;
        L.__webglInit === void 0 && (L.__webglInit = !0, D.addEventListener("dispose", C));
        let ye = D.source, Se = g.get(ye);
        Se === void 0 && (Se = {}, g.set(ye, Se));
        let Ie = Y(D);
        if (Ie !== L.__cacheKey) {
            Se[Ie] === void 0 && (Se[Ie] = {
                texture: i.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, re = !0), Se[Ie].usedTimes++;
            let Fe = Se[L.__cacheKey];
            Fe !== void 0 && (Se[L.__cacheKey].usedTimes--, Fe.usedTimes === 0 && R(D)), L.__cacheKey = Ie, L.__webglTexture = Se[Ie].texture;
        }
        return re;
    }
    function oe(L, D, re) {
        let ye = 3553;
        D.isDataArrayTexture && (ye = 35866), D.isData3DTexture && (ye = 32879);
        let Se = ge(L, D), Ie = D.source;
        if (t.activeTexture(33984 + re), t.bindTexture(ye, L.__webglTexture), Ie.version !== Ie.__currentVersion || Se === !0) {
            i.pixelStorei(37440, D.flipY), i.pixelStorei(37441, D.premultiplyAlpha), i.pixelStorei(3317, D.unpackAlignment), i.pixelStorei(37443, 0);
            let Fe = S(D) && b(D.image) === !1, ue = w(D.image, Fe, !1, h);
            ue = ke(D, ue);
            let rt = b(ue) || a, st = s.convert(D.format, D.encoding), Ee = s.convert(D.type), U = x(D.internalFormat, st, Ee, D.encoding, D.isVideoTexture);
            W(ye, D, rt);
            let Me, De = D.mipmaps, Ze = a && D.isVideoTexture !== !0, Oe = L.__version === void 0 || Se === !0, Qe = E(D, ue, rt);
            if (D.isDepthTexture) U = 6402, a ? D.type === Ds ? U = 36012 : D.type === La ? U = 33190 : D.type === Ls ? U = 35056 : U = 33189 : D.type === Ds && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), D.format === Eo && U === 6402 && D.type !== kc && D.type !== La && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), D.type = kc, Ee = s.convert(D.type)), D.format === Ns && U === 6402 && (U = 34041, D.type !== Ls && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), D.type = Ls, Ee = s.convert(D.type))), Oe && (Ze ? t.texStorage2D(3553, 1, U, ue.width, ue.height) : t.texImage2D(3553, 0, U, ue.width, ue.height, 0, st, Ee, null));
            else if (D.isDataTexture) {
                if (De.length > 0 && rt) {
                    Ze && Oe && t.texStorage2D(3553, Qe, U, De[0].width, De[0].height);
                    for(let Te = 0, $e = De.length; Te < $e; Te++)Me = De[Te], Ze ? t.texSubImage2D(3553, Te, 0, 0, Me.width, Me.height, st, Ee, Me.data) : t.texImage2D(3553, Te, U, Me.width, Me.height, 0, st, Ee, Me.data);
                    D.generateMipmaps = !1;
                } else Ze ? (Oe && t.texStorage2D(3553, Qe, U, ue.width, ue.height), t.texSubImage2D(3553, 0, 0, 0, ue.width, ue.height, st, Ee, ue.data)) : t.texImage2D(3553, 0, U, ue.width, ue.height, 0, st, Ee, ue.data);
            } else if (D.isCompressedTexture) {
                Ze && Oe && t.texStorage2D(3553, Qe, U, De[0].width, De[0].height);
                for(let Te = 0, $e = De.length; Te < $e; Te++)Me = De[Te], D.format !== Fn ? st !== null ? Ze ? t.compressedTexSubImage2D(3553, Te, 0, 0, Me.width, Me.height, st, Me.data) : t.compressedTexImage2D(3553, Te, U, Me.width, Me.height, 0, Me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ze ? t.texSubImage2D(3553, Te, 0, 0, Me.width, Me.height, st, Ee, Me.data) : t.texImage2D(3553, Te, U, Me.width, Me.height, 0, st, Ee, Me.data);
            } else if (D.isDataArrayTexture) Ze ? (Oe && t.texStorage3D(35866, Qe, U, ue.width, ue.height, ue.depth), t.texSubImage3D(35866, 0, 0, 0, 0, ue.width, ue.height, ue.depth, st, Ee, ue.data)) : t.texImage3D(35866, 0, U, ue.width, ue.height, ue.depth, 0, st, Ee, ue.data);
            else if (D.isData3DTexture) Ze ? (Oe && t.texStorage3D(32879, Qe, U, ue.width, ue.height, ue.depth), t.texSubImage3D(32879, 0, 0, 0, 0, ue.width, ue.height, ue.depth, st, Ee, ue.data)) : t.texImage3D(32879, 0, U, ue.width, ue.height, ue.depth, 0, st, Ee, ue.data);
            else if (D.isFramebufferTexture) {
                if (Oe) {
                    if (Ze) t.texStorage2D(3553, Qe, U, ue.width, ue.height);
                    else {
                        let Te = ue.width, $e = ue.height;
                        for(let lt = 0; lt < Qe; lt++)t.texImage2D(3553, lt, U, Te, $e, 0, st, Ee, null), Te >>= 1, $e >>= 1;
                    }
                }
            } else if (De.length > 0 && rt) {
                Ze && Oe && t.texStorage2D(3553, Qe, U, De[0].width, De[0].height);
                for(let Te = 0, $e = De.length; Te < $e; Te++)Me = De[Te], Ze ? t.texSubImage2D(3553, Te, 0, 0, st, Ee, Me) : t.texImage2D(3553, Te, U, st, Ee, Me);
                D.generateMipmaps = !1;
            } else Ze ? (Oe && t.texStorage2D(3553, Qe, U, ue.width, ue.height), t.texSubImage2D(3553, 0, 0, 0, st, Ee, ue)) : t.texImage2D(3553, 0, U, st, Ee, ue);
            T(D, rt) && A(ye), Ie.__currentVersion = Ie.version, D.onUpdate && D.onUpdate(D);
        }
        L.__version = D.version;
    }
    function le(L, D, re) {
        if (D.image.length !== 6) return;
        let ye = ge(L, D), Se = D.source;
        if (t.activeTexture(33984 + re), t.bindTexture(34067, L.__webglTexture), Se.version !== Se.__currentVersion || ye === !0) {
            i.pixelStorei(37440, D.flipY), i.pixelStorei(37441, D.premultiplyAlpha), i.pixelStorei(3317, D.unpackAlignment), i.pixelStorei(37443, 0);
            let Ie = D.isCompressedTexture || D.image[0].isCompressedTexture, Fe = D.image[0] && D.image[0].isDataTexture, ue = [];
            for(let Te = 0; Te < 6; Te++)!Ie && !Fe ? ue[Te] = w(D.image[Te], !1, !0, c) : ue[Te] = Fe ? D.image[Te].image : D.image[Te], ue[Te] = ke(D, ue[Te]);
            let rt = ue[0], st = b(rt) || a, Ee = s.convert(D.format, D.encoding), U = s.convert(D.type), Me = x(D.internalFormat, Ee, U, D.encoding), De = a && D.isVideoTexture !== !0, Ze = L.__version === void 0, Oe = E(D, rt, st);
            W(34067, D, st);
            let Qe;
            if (Ie) {
                De && Ze && t.texStorage2D(34067, Oe, Me, rt.width, rt.height);
                for(let Te = 0; Te < 6; Te++){
                    Qe = ue[Te].mipmaps;
                    for(let $e = 0; $e < Qe.length; $e++){
                        let lt = Qe[$e];
                        D.format !== Fn ? Ee !== null ? De ? t.compressedTexSubImage2D(34069 + Te, $e, 0, 0, lt.width, lt.height, Ee, lt.data) : t.compressedTexImage2D(34069 + Te, $e, Me, lt.width, lt.height, 0, lt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : De ? t.texSubImage2D(34069 + Te, $e, 0, 0, lt.width, lt.height, Ee, U, lt.data) : t.texImage2D(34069 + Te, $e, Me, lt.width, lt.height, 0, Ee, U, lt.data);
                    }
                }
            } else {
                Qe = D.mipmaps, De && Ze && (Qe.length > 0 && Oe++, t.texStorage2D(34067, Oe, Me, ue[0].width, ue[0].height));
                for(let Te = 0; Te < 6; Te++)if (Fe) {
                    De ? t.texSubImage2D(34069 + Te, 0, 0, 0, ue[Te].width, ue[Te].height, Ee, U, ue[Te].data) : t.texImage2D(34069 + Te, 0, Me, ue[Te].width, ue[Te].height, 0, Ee, U, ue[Te].data);
                    for(let $e = 0; $e < Qe.length; $e++){
                        let dt = Qe[$e].image[Te].image;
                        De ? t.texSubImage2D(34069 + Te, $e + 1, 0, 0, dt.width, dt.height, Ee, U, dt.data) : t.texImage2D(34069 + Te, $e + 1, Me, dt.width, dt.height, 0, Ee, U, dt.data);
                    }
                } else {
                    De ? t.texSubImage2D(34069 + Te, 0, 0, 0, Ee, U, ue[Te]) : t.texImage2D(34069 + Te, 0, Me, Ee, U, ue[Te]);
                    for(let $e = 0; $e < Qe.length; $e++){
                        let lt = Qe[$e];
                        De ? t.texSubImage2D(34069 + Te, $e + 1, 0, 0, Ee, U, lt.image[Te]) : t.texImage2D(34069 + Te, $e + 1, Me, Ee, U, lt.image[Te]);
                    }
                }
            }
            T(D, st) && A(34067), Se.__currentVersion = Se.version, D.onUpdate && D.onUpdate(D);
        }
        L.__version = D.version;
    }
    function H(L, D, re, ye, Se) {
        let Ie = s.convert(re.format, re.encoding), Fe = s.convert(re.type), ue = x(re.internalFormat, Ie, Fe, re.encoding);
        r.get(D).__hasExternalTextures || (Se === 32879 || Se === 35866 ? t.texImage3D(Se, 0, ue, D.width, D.height, D.depth, 0, Ie, Fe, null) : t.texImage2D(Se, 0, ue, D.width, D.height, 0, Ie, Fe, null)), t.bindFramebuffer(36160, L), me(D) ? f.framebufferTexture2DMultisampleEXT(36160, ye, Se, r.get(re).__webglTexture, 0, ve(D)) : i.framebufferTexture2D(36160, ye, Se, r.get(re).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }
    function he(L, D, re) {
        if (i.bindRenderbuffer(36161, L), D.depthBuffer && !D.stencilBuffer) {
            let ye = 33189;
            if (re || me(D)) {
                let Se = D.depthTexture;
                Se && Se.isDepthTexture && (Se.type === Ds ? ye = 36012 : Se.type === La && (ye = 33190));
                let Ie = ve(D);
                me(D) ? f.renderbufferStorageMultisampleEXT(36161, Ie, ye, D.width, D.height) : i.renderbufferStorageMultisample(36161, Ie, ye, D.width, D.height);
            } else i.renderbufferStorage(36161, ye, D.width, D.height);
            i.framebufferRenderbuffer(36160, 36096, 36161, L);
        } else if (D.depthBuffer && D.stencilBuffer) {
            let ye = ve(D);
            re && me(D) === !1 ? i.renderbufferStorageMultisample(36161, ye, 35056, D.width, D.height) : me(D) ? f.renderbufferStorageMultisampleEXT(36161, ye, 35056, D.width, D.height) : i.renderbufferStorage(36161, 34041, D.width, D.height), i.framebufferRenderbuffer(36160, 33306, 36161, L);
        } else {
            let ye = D.isWebGLMultipleRenderTargets === !0 ? D.texture[0] : D.texture, Se = s.convert(ye.format, ye.encoding), Ie = s.convert(ye.type), Fe = x(ye.internalFormat, Se, Ie, ye.encoding), ue = ve(D);
            re && me(D) === !1 ? i.renderbufferStorageMultisample(36161, ue, Fe, D.width, D.height) : me(D) ? f.renderbufferStorageMultisampleEXT(36161, ue, Fe, D.width, D.height) : i.renderbufferStorage(36161, Fe, D.width, D.height);
        }
        i.bindRenderbuffer(36161, null);
    }
    function K(L, D) {
        if (D && D.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, L), !(D.depthTexture && D.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!r.get(D.depthTexture).__webglTexture || D.depthTexture.image.width !== D.width || D.depthTexture.image.height !== D.height) && (D.depthTexture.image.width = D.width, D.depthTexture.image.height = D.height, D.depthTexture.needsUpdate = !0), F(D.depthTexture, 0);
        let ye = r.get(D.depthTexture).__webglTexture, Se = ve(D);
        if (D.depthTexture.format === Eo) me(D) ? f.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ye, 0, Se) : i.framebufferTexture2D(36160, 36096, 3553, ye, 0);
        else if (D.depthTexture.format === Ns) me(D) ? f.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ye, 0, Se) : i.framebufferTexture2D(36160, 33306, 3553, ye, 0);
        else throw new Error("Unknown depthTexture format");
    }
    function V(L) {
        let D = r.get(L), re = L.isWebGLCubeRenderTarget === !0;
        if (L.depthTexture && !D.__autoAllocateDepthBuffer) {
            if (re) throw new Error("target.depthTexture not supported in Cube render targets");
            K(D.__webglFramebuffer, L);
        } else if (re) {
            D.__webglDepthbuffer = [];
            for(let ye = 0; ye < 6; ye++)t.bindFramebuffer(36160, D.__webglFramebuffer[ye]), D.__webglDepthbuffer[ye] = i.createRenderbuffer(), he(D.__webglDepthbuffer[ye], L, !1);
        } else t.bindFramebuffer(36160, D.__webglFramebuffer), D.__webglDepthbuffer = i.createRenderbuffer(), he(D.__webglDepthbuffer, L, !1);
        t.bindFramebuffer(36160, null);
    }
    function Z(L, D, re) {
        let ye = r.get(L);
        D !== void 0 && H(ye.__webglFramebuffer, L, L.texture, 36064, 3553), re !== void 0 && V(L);
    }
    function ce(L) {
        let D = L.texture, re = r.get(L), ye = r.get(D);
        L.addEventListener("dispose", I), L.isWebGLMultipleRenderTargets !== !0 && (ye.__webglTexture === void 0 && (ye.__webglTexture = i.createTexture()), ye.__version = D.version, o.memory.textures++);
        let Se = L.isWebGLCubeRenderTarget === !0, Ie = L.isWebGLMultipleRenderTargets === !0, Fe = b(L) || a;
        if (Se) {
            re.__webglFramebuffer = [];
            for(let ue = 0; ue < 6; ue++)re.__webglFramebuffer[ue] = i.createFramebuffer();
        } else if (re.__webglFramebuffer = i.createFramebuffer(), Ie) {
            if (n.drawBuffers) {
                let ue = L.texture;
                for(let rt = 0, st = ue.length; rt < st; rt++){
                    let Ee = r.get(ue[rt]);
                    Ee.__webglTexture === void 0 && (Ee.__webglTexture = i.createTexture(), o.memory.textures++);
                }
            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        } else if (a && L.samples > 0 && me(L) === !1) {
            re.__webglMultisampledFramebuffer = i.createFramebuffer(), re.__webglColorRenderbuffer = i.createRenderbuffer(), i.bindRenderbuffer(36161, re.__webglColorRenderbuffer);
            let ue = s.convert(D.format, D.encoding), rt = s.convert(D.type), st = x(D.internalFormat, ue, rt, D.encoding), Ee = ve(L);
            i.renderbufferStorageMultisample(36161, Ee, st, L.width, L.height), t.bindFramebuffer(36160, re.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064, 36161, re.__webglColorRenderbuffer), i.bindRenderbuffer(36161, null), L.depthBuffer && (re.__webglDepthRenderbuffer = i.createRenderbuffer(), he(re.__webglDepthRenderbuffer, L, !0)), t.bindFramebuffer(36160, null);
        }
        if (Se) {
            t.bindTexture(34067, ye.__webglTexture), W(34067, D, Fe);
            for(let ue = 0; ue < 6; ue++)H(re.__webglFramebuffer[ue], L, D, 36064, 34069 + ue);
            T(D, Fe) && A(34067), t.unbindTexture();
        } else if (Ie) {
            let ue = L.texture;
            for(let rt = 0, st = ue.length; rt < st; rt++){
                let Ee = ue[rt], U = r.get(Ee);
                t.bindTexture(3553, U.__webglTexture), W(3553, Ee, Fe), H(re.__webglFramebuffer, L, Ee, 36064 + rt, 3553), T(Ee, Fe) && A(3553);
            }
            t.unbindTexture();
        } else {
            let ue = 3553;
            (L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) && (a ? ue = L.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(ue, ye.__webglTexture), W(ue, D, Fe), H(re.__webglFramebuffer, L, D, 36064, ue), T(D, Fe) && A(ue), t.unbindTexture();
        }
        L.depthBuffer && V(L);
    }
    function se(L) {
        let D = b(L) || a, re = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [
            L.texture
        ];
        for(let ye = 0, Se = re.length; ye < Se; ye++){
            let Ie = re[ye];
            if (T(Ie, D)) {
                let Fe = L.isWebGLCubeRenderTarget ? 34067 : 3553, ue = r.get(Ie).__webglTexture;
                t.bindTexture(Fe, ue), A(Fe), t.unbindTexture();
            }
        }
    }
    function pe(L) {
        if (a && L.samples > 0 && me(L) === !1) {
            let D = L.width, re = L.height, ye = 16384, Se = [
                36064
            ], Ie = L.stencilBuffer ? 33306 : 36096;
            L.depthBuffer && Se.push(Ie);
            let Fe = r.get(L), ue = Fe.__ignoreDepthValues !== void 0 ? Fe.__ignoreDepthValues : !1;
            ue === !1 && (L.depthBuffer && (ye |= 256), L.stencilBuffer && (ye |= 1024)), t.bindFramebuffer(36008, Fe.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, Fe.__webglFramebuffer), ue === !0 && (i.invalidateFramebuffer(36008, [
                Ie
            ]), i.invalidateFramebuffer(36009, [
                Ie
            ])), i.blitFramebuffer(0, 0, D, re, 0, 0, D, re, ye, 9728), d && i.invalidateFramebuffer(36008, Se), t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, Fe.__webglMultisampledFramebuffer);
        }
    }
    function ve(L) {
        return Math.min(u, L.samples);
    }
    function me(L) {
        let D = r.get(L);
        return a && L.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && D.__useRenderToTexture !== !1;
    }
    function Pe(L) {
        let D = o.render.frame;
        p.get(L) !== D && (p.set(L, D), L.update());
    }
    function ke(L, D) {
        let re = L.encoding, ye = L.format, Se = L.type;
        return L.isCompressedTexture === !0 || L.isVideoTexture === !0 || L.format === sg || re !== gn && (re === je ? a === !1 ? e.has("EXT_sRGB") === !0 && ye === Fn ? (L.format = sg, L.minFilter = ct, L.generateMipmaps = !1) : D = ns.sRGBToLinear(D) : (ye !== Fn || Se !== qt) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", re)), D;
    }
    this.allocateTextureUnit = Q, this.resetTextureUnits = te, this.setTexture2D = F, this.setTexture2DArray = z, this.setTexture3D = O, this.setTextureCube = j, this.rebindTextures = Z, this.setupRenderTarget = ce, this.updateRenderTargetMipmap = se, this.updateMultisampleRenderTarget = pe, this.setupDepthRenderbuffer = V, this.setupFrameBufferTexture = H, this.useMultisampledRTT = me;
}
function EL(i, e, t) {
    let r = t.isWebGL2;
    function n(s, o = null) {
        let a;
        if (s === qt) return 5121;
        if (s === gE) return 32819;
        if (s === yE) return 32820;
        if (s === dE) return 5120;
        if (s === pE) return 5122;
        if (s === kc) return 5123;
        if (s === mE) return 5124;
        if (s === La) return 5125;
        if (s === Ds) return 5126;
        if (s === Vc) return r ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
        if (s === vE) return 6406;
        if (s === Fn) return 6408;
        if (s === bE) return 6409;
        if (s === wE) return 6410;
        if (s === Eo) return 6402;
        if (s === Ns) return 34041;
        if (s === SE) return 6403;
        if (s === xE) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
        if (s === sg) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === ME) return 36244;
        if (s === AE) return 33319;
        if (s === TE) return 33320;
        if (s === EE) return 36249;
        if (s === ym || s === vm || s === xm || s === bm) {
            if (o === je) {
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
                    if (s === ym) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === vm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === xm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === bm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else return null;
            } else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
                if (s === ym) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === vm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === xm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === bm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (s === Bx || s === Nx || s === Ox || s === Fx) {
            if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
                if (s === Bx) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === Nx) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === Ox) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === Fx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (s === _E) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === Ux || s === zx) {
            if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
                if (s === Ux) return o === je ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === zx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
        }
        if (s === Gx || s === kx || s === Vx || s === Hx || s === Wx || s === jx || s === qx || s === Yx || s === Xx || s === Qx || s === Jx || s === Kx || s === Zx || s === $x) {
            if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
                if (s === Gx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === kx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === Vx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === Hx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === Wx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === jx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === qx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === Yx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === Xx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === Qx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === Jx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === Kx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === Zx) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === $x) return o === je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
        }
        if (s === e0) {
            if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
                if (s === e0) return o === je ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else return null;
        }
        return s === Ls ? r ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : i[s] !== void 0 ? i[s] : null;
    }
    return {
        convert: n
    };
}
var bf = class extends sr {
    constructor(e = []){
        super(), this.cameras = e;
    }
};
bf.prototype.isArrayCamera = !0;
var ts = class extends ot {
    constructor(){
        super(), this.type = "Group";
    }
};
ts.prototype.isGroup = !0;
var _L = {
    type: "move"
}, Uc = class {
    constructor(){
        this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new ts, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand;
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new ts, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new M, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new M), this._targetRay;
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new ts, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new M, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new M), this._grip;
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
    }
    update(e, t, r) {
        let n = null, s = null, o = null, a = this._targetRay, l = this._grip, c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (a !== null && (n = t.getPose(e.targetRaySpace, r), n !== null && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(_L))), c && e.hand) {
                o = !0;
                for (let m of e.hand.values()){
                    let g = t.getJointPose(m, r);
                    if (c.joints[m.jointName] === void 0) {
                        let y = new ts;
                        y.matrixAutoUpdate = !1, y.visible = !1, c.joints[m.jointName] = y, c.add(y);
                    }
                    let v = c.joints[m.jointName];
                    g !== null && (v.matrix.fromArray(g.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.jointRadius = g.radius), v.visible = g !== null;
                }
                let h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], f = h.position.distanceTo(u.position), d = .02, p = .005;
                c.inputState.pinching && f > d + p ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && f <= d - p && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }));
            } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
        }
        return a !== null && (a.visible = n !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this;
    }
}, oi = class extends Dt {
    constructor(e, t, r, n, s, o, a, l, c, h){
        if (h = h !== void 0 ? h : Eo, h !== Eo && h !== Ns) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        r === void 0 && h === Eo && (r = kc), r === void 0 && h === Ns && (r = Ls), super(null, n, s, o, a, l, h, r, c), this.image = {
            width: e,
            height: t
        }, this.magFilter = a !== void 0 ? a : hr, this.minFilter = l !== void 0 ? l : hr, this.flipY = !1, this.generateMipmaps = !1;
    }
};
oi.prototype.isDepthTexture = !0;
var pg = class extends Yt {
    constructor(e, t){
        super();
        let r = this, n = null, s = 1, o = null, a = "local-floor", l = null, c = null, h = null, u = null, f = null, d = null, p = t.getContextAttributes(), m = null, g = null, v = [], y = new Map, w = new sr;
        w.layers.enable(1), w.viewport = new Je;
        let b = new sr;
        b.layers.enable(2), b.viewport = new Je;
        let S = [
            w,
            b
        ], T = new bf;
        T.layers.enable(1), T.layers.enable(2);
        let A = null, x = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Y) {
            let F = v[Y];
            return F === void 0 && (F = new Uc, v[Y] = F), F.getTargetRaySpace();
        }, this.getControllerGrip = function(Y) {
            let F = v[Y];
            return F === void 0 && (F = new Uc, v[Y] = F), F.getGripSpace();
        }, this.getHand = function(Y) {
            let F = v[Y];
            return F === void 0 && (F = new Uc, v[Y] = F), F.getHandSpace();
        };
        function E(Y) {
            let F = y.get(Y.inputSource);
            F && F.dispatchEvent({
                type: Y.type,
                data: Y.inputSource
            });
        }
        function _() {
            y.forEach(function(Y, F) {
                Y.disconnect(F);
            }), y.clear(), A = null, x = null, e.setRenderTarget(m), f = null, u = null, h = null, n = null, g = null, Q.stop(), r.isPresenting = !1, r.dispatchEvent({
                type: "sessionend"
            });
        }
        this.setFramebufferScaleFactor = function(Y) {
            s = Y, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function(Y) {
            a = Y, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function() {
            return l || o;
        }, this.setReferenceSpace = function(Y) {
            l = Y;
        }, this.getBaseLayer = function() {
            return u !== null ? u : f;
        }, this.getBinding = function() {
            return h;
        }, this.getFrame = function() {
            return d;
        }, this.getSession = function() {
            return n;
        }, this.setSession = async function(Y) {
            if (n = Y, n !== null) {
                if (m = e.getRenderTarget(), n.addEventListener("select", E), n.addEventListener("selectstart", E), n.addEventListener("selectend", E), n.addEventListener("squeeze", E), n.addEventListener("squeezestart", E), n.addEventListener("squeezeend", E), n.addEventListener("end", _), n.addEventListener("inputsourceschange", C), p.xrCompatible !== !0 && await t.makeXRCompatible(), n.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    let F = {
                        antialias: n.renderState.layers === void 0 ? p.antialias : !0,
                        alpha: p.alpha,
                        depth: p.depth,
                        stencil: p.stencil,
                        framebufferScaleFactor: s
                    };
                    f = new XRWebGLLayer(n, t, F), n.updateRenderState({
                        baseLayer: f
                    }), g = new mt(f.framebufferWidth, f.framebufferHeight, {
                        format: Fn,
                        type: qt,
                        encoding: e.outputEncoding
                    });
                } else {
                    let F = null, z = null, O = null;
                    p.depth && (O = p.stencil ? 35056 : 33190, F = p.stencil ? Ns : Eo, z = p.stencil ? Ls : kc);
                    let j = {
                        colorFormat: e.outputEncoding === je ? 35907 : 32856,
                        depthFormat: O,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(n, t), u = h.createProjectionLayer(j), n.updateRenderState({
                        layers: [
                            u
                        ]
                    }), g = new mt(u.textureWidth, u.textureHeight, {
                        format: Fn,
                        type: qt,
                        depthTexture: new oi(u.textureWidth, u.textureHeight, z, void 0, void 0, void 0, void 0, void 0, void 0, F),
                        stencilBuffer: p.stencil,
                        encoding: e.outputEncoding,
                        samples: p.antialias ? 4 : 0
                    });
                    let q = e.properties.get(g);
                    q.__ignoreDepthValues = u.ignoreDepthValues;
                }
                g.isXRRenderTarget = !0, this.setFoveation(1), o = await n.requestReferenceSpace(a), Q.setContext(n), Q.start(), r.isPresenting = !0, r.dispatchEvent({
                    type: "sessionstart"
                });
            }
        };
        function C(Y) {
            let F = n.inputSources;
            for(let z = 0; z < F.length; z++){
                let O = F[z].handedness === "right" ? 1 : 0;
                y.set(F[z], v[O]);
            }
            for(let z4 = 0; z4 < Y.removed.length; z4++){
                let O = Y.removed[z4], j = y.get(O);
                j && (j.dispatchEvent({
                    type: "disconnected",
                    data: O
                }), y.delete(O));
            }
            for(let z5 = 0; z5 < Y.added.length; z5++){
                let O = Y.added[z5], j = y.get(O);
                j && j.dispatchEvent({
                    type: "connected",
                    data: O
                });
            }
        }
        let I = new M, N = new M;
        function R(Y, F, z) {
            I.setFromMatrixPosition(F.matrixWorld), N.setFromMatrixPosition(z.matrixWorld);
            let O = I.distanceTo(N), j = F.projectionMatrix.elements, q = z.projectionMatrix.elements, J = j[14] / (j[10] - 1), W = j[14] / (j[10] + 1), ge = (j[9] + 1) / j[5], oe = (j[9] - 1) / j[5], le = (j[8] - 1) / j[0], H = (q[8] + 1) / q[0], he = J * le, K = J * H, V = O / (-le + H), Z = V * -le;
            F.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale), Y.translateX(Z), Y.translateZ(V), Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale), Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
            let ce = J + V, se = W + V, pe = he - Z, ve = K + (O - Z), me = ge * W / se * ce, Pe = oe * W / se * ce;
            Y.projectionMatrix.makePerspective(pe, ve, me, Pe, ce, se);
        }
        function k(Y, F) {
            F === null ? Y.matrixWorld.copy(Y.matrix) : Y.matrixWorld.multiplyMatrices(F.matrixWorld, Y.matrix), Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
        }
        this.updateCamera = function(Y) {
            if (n === null) return;
            T.near = b.near = w.near = Y.near, T.far = b.far = w.far = Y.far, (A !== T.near || x !== T.far) && (n.updateRenderState({
                depthNear: T.near,
                depthFar: T.far
            }), A = T.near, x = T.far);
            let F = Y.parent, z = T.cameras;
            k(T, F);
            for(let j = 0; j < z.length; j++)k(z[j], F);
            T.matrixWorld.decompose(T.position, T.quaternion, T.scale), Y.position.copy(T.position), Y.quaternion.copy(T.quaternion), Y.scale.copy(T.scale), Y.matrix.copy(T.matrix), Y.matrixWorld.copy(T.matrixWorld);
            let O = Y.children;
            for(let j4 = 0, q = O.length; j4 < q; j4++)O[j4].updateMatrixWorld(!0);
            z.length === 2 ? R(T, w, b) : T.projectionMatrix.copy(w.projectionMatrix);
        }, this.getCamera = function() {
            return T;
        }, this.getFoveation = function() {
            if (u !== null) return u.fixedFoveation;
            if (f !== null) return f.fixedFoveation;
        }, this.setFoveation = function(Y) {
            u !== null && (u.fixedFoveation = Y), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = Y);
        };
        let G = null;
        function te(Y, F) {
            if (c = F.getViewerPose(l || o), d = F, c !== null) {
                let O = c.views;
                f !== null && (e.setRenderTargetFramebuffer(g, f.framebuffer), e.setRenderTarget(g));
                let j = !1;
                O.length !== T.cameras.length && (T.cameras.length = 0, j = !0);
                for(let q = 0; q < O.length; q++){
                    let J = O[q], W = null;
                    if (f !== null) W = f.getViewport(J);
                    else {
                        let oe = h.getViewSubImage(u, J);
                        W = oe.viewport, q === 0 && (e.setRenderTargetTextures(g, oe.colorTexture, u.ignoreDepthValues ? void 0 : oe.depthStencilTexture), e.setRenderTarget(g));
                    }
                    let ge = S[q];
                    ge.matrix.fromArray(J.transform.matrix), ge.projectionMatrix.fromArray(J.projectionMatrix), ge.viewport.set(W.x, W.y, W.width, W.height), q === 0 && T.matrix.copy(ge.matrix), j === !0 && T.cameras.push(ge);
                }
            }
            let z = n.inputSources;
            for(let O = 0; O < v.length; O++){
                let j = z[O], q = y.get(j);
                q !== void 0 && q.update(j, F, l || o);
            }
            G && G(Y, F), d = null;
        }
        let Q = new bb;
        Q.setAnimationLoop(te), this.setAnimationLoop = function(Y) {
            G = Y;
        }, this.dispose = function() {};
    }
};
function CL(i, e) {
    function t(m, g) {
        m.fogColor.value.copy(g.color), g.isFog ? (m.fogNear.value = g.near, m.fogFar.value = g.far) : g.isFogExp2 && (m.fogDensity.value = g.density);
    }
    function r(m, g, v, y, w) {
        g.isMeshBasicMaterial || g.isMeshLambertMaterial ? n(m, g) : g.isMeshToonMaterial ? (n(m, g), h(m, g)) : g.isMeshPhongMaterial ? (n(m, g), c(m, g)) : g.isMeshStandardMaterial ? (n(m, g), u(m, g), g.isMeshPhysicalMaterial && f(m, g, w)) : g.isMeshMatcapMaterial ? (n(m, g), d(m, g)) : g.isMeshDepthMaterial ? n(m, g) : g.isMeshDistanceMaterial ? (n(m, g), p(m, g)) : g.isMeshNormalMaterial ? n(m, g) : g.isLineBasicMaterial ? (s(m, g), g.isLineDashedMaterial && o(m, g)) : g.isPointsMaterial ? a(m, g, v, y) : g.isSpriteMaterial ? l(m, g) : g.isShadowMaterial ? (m.color.value.copy(g.color), m.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
    }
    function n(m, g) {
        m.opacity.value = g.opacity, g.color && m.diffuse.value.copy(g.color), g.emissive && m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (m.map.value = g.map), g.alphaMap && (m.alphaMap.value = g.alphaMap), g.bumpMap && (m.bumpMap.value = g.bumpMap, m.bumpScale.value = g.bumpScale, g.side === Pr && (m.bumpScale.value *= -1)), g.displacementMap && (m.displacementMap.value = g.displacementMap, m.displacementScale.value = g.displacementScale, m.displacementBias.value = g.displacementBias), g.emissiveMap && (m.emissiveMap.value = g.emissiveMap), g.normalMap && (m.normalMap.value = g.normalMap, m.normalScale.value.copy(g.normalScale), g.side === Pr && m.normalScale.value.negate()), g.specularMap && (m.specularMap.value = g.specularMap), g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
        let v = e.get(g).envMap;
        if (v && (m.envMap.value = v, m.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = g.reflectivity, m.ior.value = g.ior, m.refractionRatio.value = g.refractionRatio), g.lightMap) {
            m.lightMap.value = g.lightMap;
            let b = i.physicallyCorrectLights !== !0 ? Math.PI : 1;
            m.lightMapIntensity.value = g.lightMapIntensity * b;
        }
        g.aoMap && (m.aoMap.value = g.aoMap, m.aoMapIntensity.value = g.aoMapIntensity);
        let y;
        g.map ? y = g.map : g.specularMap ? y = g.specularMap : g.displacementMap ? y = g.displacementMap : g.normalMap ? y = g.normalMap : g.bumpMap ? y = g.bumpMap : g.roughnessMap ? y = g.roughnessMap : g.metalnessMap ? y = g.metalnessMap : g.alphaMap ? y = g.alphaMap : g.emissiveMap ? y = g.emissiveMap : g.clearcoatMap ? y = g.clearcoatMap : g.clearcoatNormalMap ? y = g.clearcoatNormalMap : g.clearcoatRoughnessMap ? y = g.clearcoatRoughnessMap : g.specularIntensityMap ? y = g.specularIntensityMap : g.specularColorMap ? y = g.specularColorMap : g.transmissionMap ? y = g.transmissionMap : g.thicknessMap ? y = g.thicknessMap : g.sheenColorMap ? y = g.sheenColorMap : g.sheenRoughnessMap && (y = g.sheenRoughnessMap), y !== void 0 && (y.isWebGLRenderTarget && (y = y.texture), y.matrixAutoUpdate === !0 && y.updateMatrix(), m.uvTransform.value.copy(y.matrix));
        let w;
        g.aoMap ? w = g.aoMap : g.lightMap && (w = g.lightMap), w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture), w.matrixAutoUpdate === !0 && w.updateMatrix(), m.uv2Transform.value.copy(w.matrix));
    }
    function s(m, g) {
        m.diffuse.value.copy(g.color), m.opacity.value = g.opacity;
    }
    function o(m, g) {
        m.dashSize.value = g.dashSize, m.totalSize.value = g.dashSize + g.gapSize, m.scale.value = g.scale;
    }
    function a(m, g, v, y) {
        m.diffuse.value.copy(g.color), m.opacity.value = g.opacity, m.size.value = g.size * v, m.scale.value = y * .5, g.map && (m.map.value = g.map), g.alphaMap && (m.alphaMap.value = g.alphaMap), g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
        let w;
        g.map ? w = g.map : g.alphaMap && (w = g.alphaMap), w !== void 0 && (w.matrixAutoUpdate === !0 && w.updateMatrix(), m.uvTransform.value.copy(w.matrix));
    }
    function l(m, g) {
        m.diffuse.value.copy(g.color), m.opacity.value = g.opacity, m.rotation.value = g.rotation, g.map && (m.map.value = g.map), g.alphaMap && (m.alphaMap.value = g.alphaMap), g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
        let v;
        g.map ? v = g.map : g.alphaMap && (v = g.alphaMap), v !== void 0 && (v.matrixAutoUpdate === !0 && v.updateMatrix(), m.uvTransform.value.copy(v.matrix));
    }
    function c(m, g) {
        m.specular.value.copy(g.specular), m.shininess.value = Math.max(g.shininess, 1e-4);
    }
    function h(m, g) {
        g.gradientMap && (m.gradientMap.value = g.gradientMap);
    }
    function u(m, g) {
        m.roughness.value = g.roughness, m.metalness.value = g.metalness, g.roughnessMap && (m.roughnessMap.value = g.roughnessMap), g.metalnessMap && (m.metalnessMap.value = g.metalnessMap), e.get(g).envMap && (m.envMapIntensity.value = g.envMapIntensity);
    }
    function f(m, g, v) {
        m.ior.value = g.ior, g.sheen > 0 && (m.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), m.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (m.sheenColorMap.value = g.sheenColorMap), g.sheenRoughnessMap && (m.sheenRoughnessMap.value = g.sheenRoughnessMap)), g.clearcoat > 0 && (m.clearcoat.value = g.clearcoat, m.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (m.clearcoatMap.value = g.clearcoatMap), g.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), g.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), m.clearcoatNormalMap.value = g.clearcoatNormalMap, g.side === Pr && m.clearcoatNormalScale.value.negate())), g.transmission > 0 && (m.transmission.value = g.transmission, m.transmissionSamplerMap.value = v.texture, m.transmissionSamplerSize.value.set(v.width, v.height), g.transmissionMap && (m.transmissionMap.value = g.transmissionMap), m.thickness.value = g.thickness, g.thicknessMap && (m.thicknessMap.value = g.thicknessMap), m.attenuationDistance.value = g.attenuationDistance, m.attenuationColor.value.copy(g.attenuationColor)), m.specularIntensity.value = g.specularIntensity, m.specularColor.value.copy(g.specularColor), g.specularIntensityMap && (m.specularIntensityMap.value = g.specularIntensityMap), g.specularColorMap && (m.specularColorMap.value = g.specularColorMap);
    }
    function d(m, g) {
        g.matcap && (m.matcap.value = g.matcap);
    }
    function p(m, g) {
        m.referencePosition.value.copy(g.referencePosition), m.nearDistance.value = g.nearDistance, m.farDistance.value = g.farDistance;
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: r
    };
}
function DL() {
    let i = jc("canvas");
    return i.style.display = "block", i;
}
function Pt(i = {}) {
    let e = i.canvas !== void 0 ? i.canvas : DL(), t = i.context !== void 0 ? i.context : null, r = i.depth !== void 0 ? i.depth : !0, n = i.stencil !== void 0 ? i.stencil : !0, s = i.antialias !== void 0 ? i.antialias : !1, o = i.premultipliedAlpha !== void 0 ? i.premultipliedAlpha : !0, a = i.preserveDrawingBuffer !== void 0 ? i.preserveDrawingBuffer : !1, l = i.powerPreference !== void 0 ? i.powerPreference : "default", c = i.failIfMajorPerformanceCaveat !== void 0 ? i.failIfMajorPerformanceCaveat : !1, h;
    t !== null ? h = t.getContextAttributes().alpha : h = i.alpha !== void 0 ? i.alpha : !1;
    let u = null, f = null, d = [], p = [];
    this.domElement = e, this.debug = {
        checkShaderErrors: !0
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = gn, this.physicallyCorrectLights = !1, this.toneMapping = rs, this.toneMappingExposure = 1;
    let m = this, g = !1, v = 0, y = 0, w = null, b = -1, S = null, T = new Je, A = new Je, x = null, E = e.width, _ = e.height, C = 1, I = null, N = null, R = new Je(0, 0, E, _), k = new Je(0, 0, E, _), G = !1, te = new Na, Q = !1, Y = !1, F = null, z = new Ae, O = new B, j = new M, q = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function J() {
        return w === null ? C : 1;
    }
    let W = t;
    function ge(P, X) {
        for(let ne = 0; ne < P.length; ne++){
            let ee = P[ne], fe = e.getContext(ee, X);
            if (fe !== null) return fe;
        }
        return null;
    }
    try {
        let P = {
            alpha: !0,
            depth: r,
            stencil: n,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Uo}`), e.addEventListener("webglcontextlost", U, !1), e.addEventListener("webglcontextrestored", Me, !1), W === null) {
            let X = [
                "webgl2",
                "webgl",
                "experimental-webgl"
            ];
            if (m.isWebGL1Renderer === !0 && X.shift(), W = ge(X, P), W === null) throw ge(X) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
        W.getShaderPrecisionFormat === void 0 && (W.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            };
        });
    } catch (P1) {
        throw console.error("THREE.WebGLRenderer: " + P1.message), P1;
    }
    let oe, le, H, he, K, V, Z, ce, se, pe, ve, me, Pe, ke, L, D, re, ye, Se, Ie, Fe, ue, rt;
    function st() {
        oe = new QD(W), le = new HD(W, oe, i), oe.init(le), ue = new EL(W, oe, le), H = new AL(W, oe, le), he = new ZD(W), K = new dL, V = new TL(W, oe, H, K, le, ue, he), Z = new jD(m), ce = new XD(m), se = new f_(W, le), rt = new kD(W, oe, se, le), pe = new JD(W, se, he, rt), ve = new rP(W, pe, se, he), Se = new tP(W, le, V), D = new WD(K), me = new fL(m, Z, ce, oe, le, rt, D), Pe = new CL(m, K), ke = new mL, L = new wL(oe, le), ye = new GD(m, Z, H, ve, h, o), re = new _b(m, ve, le), Ie = new VD(W, oe, he, le), Fe = new KD(W, oe, he, le), he.programs = me.programs, m.capabilities = le, m.extensions = oe, m.properties = K, m.renderLists = ke, m.shadowMap = re, m.state = H, m.info = he;
    }
    st();
    let Ee = new pg(m, W);
    this.xr = Ee, this.getContext = function() {
        return W;
    }, this.getContextAttributes = function() {
        return W.getContextAttributes();
    }, this.forceContextLoss = function() {
        let P = oe.get("WEBGL_lose_context");
        P && P.loseContext();
    }, this.forceContextRestore = function() {
        let P = oe.get("WEBGL_lose_context");
        P && P.restoreContext();
    }, this.getPixelRatio = function() {
        return C;
    }, this.setPixelRatio = function(P) {
        P !== void 0 && (C = P, this.setSize(E, _, !1));
    }, this.getSize = function(P) {
        return P.set(E, _);
    }, this.setSize = function(P, X, ne) {
        if (Ee.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
        }
        E = P, _ = X, e.width = Math.floor(P * C), e.height = Math.floor(X * C), ne !== !1 && (e.style.width = P + "px", e.style.height = X + "px"), this.setViewport(0, 0, P, X);
    }, this.getDrawingBufferSize = function(P) {
        return P.set(E * C, _ * C).floor();
    }, this.setDrawingBufferSize = function(P, X, ne) {
        E = P, _ = X, C = ne, e.width = Math.floor(P * ne), e.height = Math.floor(X * ne), this.setViewport(0, 0, P, X);
    }, this.getCurrentViewport = function(P) {
        return P.copy(T);
    }, this.getViewport = function(P) {
        return P.copy(R);
    }, this.setViewport = function(P, X, ne, ee) {
        P.isVector4 ? R.set(P.x, P.y, P.z, P.w) : R.set(P, X, ne, ee), H.viewport(T.copy(R).multiplyScalar(C).floor());
    }, this.getScissor = function(P) {
        return P.copy(k);
    }, this.setScissor = function(P, X, ne, ee) {
        P.isVector4 ? k.set(P.x, P.y, P.z, P.w) : k.set(P, X, ne, ee), H.scissor(A.copy(k).multiplyScalar(C).floor());
    }, this.getScissorTest = function() {
        return G;
    }, this.setScissorTest = function(P) {
        H.setScissorTest(G = P);
    }, this.setOpaqueSort = function(P) {
        I = P;
    }, this.setTransparentSort = function(P) {
        N = P;
    }, this.getClearColor = function(P) {
        return P.copy(ye.getClearColor());
    }, this.setClearColor = function() {
        ye.setClearColor.apply(ye, arguments);
    }, this.getClearAlpha = function() {
        return ye.getClearAlpha();
    }, this.setClearAlpha = function() {
        ye.setClearAlpha.apply(ye, arguments);
    }, this.clear = function(P = !0, X = !0, ne = !0) {
        let ee = 0;
        P && (ee |= 16384), X && (ee |= 256), ne && (ee |= 1024), W.clear(ee);
    }, this.clearColor = function() {
        this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
        this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
        this.clear(!1, !1, !0);
    }, this.dispose = function() {
        e.removeEventListener("webglcontextlost", U, !1), e.removeEventListener("webglcontextrestored", Me, !1), ke.dispose(), L.dispose(), K.dispose(), Z.dispose(), ce.dispose(), ve.dispose(), rt.dispose(), me.dispose(), Ee.dispose(), Ee.removeEventListener("sessionstart", $e), Ee.removeEventListener("sessionend", lt), F && (F.dispose(), F = null), dt.stop();
    };
    function U(P) {
        P.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0;
    }
    function Me() {
        console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
        let P = he.autoReset, X = re.enabled, ne = re.autoUpdate, ee = re.needsUpdate, fe = re.type;
        st(), he.autoReset = P, re.enabled = X, re.autoUpdate = ne, re.needsUpdate = ee, re.type = fe;
    }
    function De(P) {
        let X = P.target;
        X.removeEventListener("dispose", De), Ze(X);
    }
    function Ze(P) {
        Oe(P), K.remove(P);
    }
    function Oe(P) {
        let X = K.get(P).programs;
        X !== void 0 && (X.forEach(function(ne) {
            me.releaseProgram(ne);
        }), P.isShaderMaterial && me.releaseShaderCache(P));
    }
    this.renderBufferDirect = function(P, X, ne, ee, fe, Ue) {
        X === null && (X = q);
        let He = fe.isMesh && fe.matrixWorld.determinant() < 0, nt = pt(P, X, ne, ee, fe);
        H.setMaterial(ee, He);
        let it = ne.index, Et = ne.attributes.position;
        if (it === null) {
            if (Et === void 0 || Et.count === 0) return;
        } else if (it.count === 0) return;
        let St = 1;
        ee.wireframe === !0 && (it = pe.getWireframeAttribute(ne), St = 2), rt.setup(fe, ee, nt, ne, it);
        let _t, nr = Ie;
        it !== null && (_t = se.get(it), nr = Fe, nr.setIndex(_t));
        let xo = it !== null ? it.count : Et.count, sa = ne.drawRange.start * St, oa = ne.drawRange.count * St, wi = Ue !== null ? Ue.start * St : 0, Rt = Ue !== null ? Ue.count * St : 1 / 0, aa = Math.max(sa, wi), yr = Math.min(xo, sa + oa, wi + Rt) - 1, Si = Math.max(0, yr - aa + 1);
        if (Si !== 0) {
            if (fe.isMesh) ee.wireframe === !0 ? (H.setLineWidth(ee.wireframeLinewidth * J()), nr.setMode(1)) : nr.setMode(4);
            else if (fe.isLine) {
                let bs = ee.linewidth;
                bs === void 0 && (bs = 1), H.setLineWidth(bs * J()), fe.isLineSegments ? nr.setMode(1) : fe.isLineLoop ? nr.setMode(2) : nr.setMode(3);
            } else fe.isPoints ? nr.setMode(0) : fe.isSprite && nr.setMode(4);
            if (fe.isInstancedMesh) nr.renderInstances(aa, Si, fe.count);
            else if (ne.isInstancedBufferGeometry) {
                let bs = Math.min(ne.instanceCount, ne._maxInstanceCount);
                nr.renderInstances(aa, Si, bs);
            } else nr.render(aa, Si);
        }
    }, this.compile = function(P, X) {
        f = L.get(P), f.init(), p.push(f), P.traverseVisible(function(ne) {
            ne.isLight && ne.layers.test(X.layers) && (f.pushLight(ne), ne.castShadow && f.pushShadow(ne));
        }), f.setupLights(m.physicallyCorrectLights), P.traverse(function(ne) {
            let ee = ne.material;
            if (ee) {
                if (Array.isArray(ee)) for(let fe = 0; fe < ee.length; fe++){
                    let Ue = ee[fe];
                    ut(Ue, P, ne);
                }
                else ut(ee, P, ne);
            }
        }), p.pop(), f = null;
    };
    let Qe = null;
    function Te(P) {
        Qe && Qe(P);
    }
    function $e() {
        dt.stop();
    }
    function lt() {
        dt.start();
    }
    let dt = new bb;
    dt.setAnimationLoop(Te), typeof self < "u" && dt.setContext(self), this.setAnimationLoop = function(P) {
        Qe = P, Ee.setAnimationLoop(P), P === null ? dt.stop() : dt.start();
    }, Ee.addEventListener("sessionstart", $e), Ee.addEventListener("sessionend", lt), this.render = function(P, X) {
        if (X !== void 0 && X.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
        }
        if (g === !0) return;
        P.autoUpdate === !0 && P.updateMatrixWorld(), X.parent === null && X.updateMatrixWorld(), Ee.enabled === !0 && Ee.isPresenting === !0 && (Ee.cameraAutoUpdate === !0 && Ee.updateCamera(X), X = Ee.getCamera()), P.isScene === !0 && P.onBeforeRender(m, P, X, w), f = L.get(P, p.length), f.init(), p.push(f), z.multiplyMatrices(X.projectionMatrix, X.matrixWorldInverse), te.setFromProjectionMatrix(z), Y = this.localClippingEnabled, Q = D.init(this.clippingPlanes, Y, X), u = ke.get(P, d.length), u.init(), d.push(u), Ut(P, X, 0, m.sortObjects), u.finish(), m.sortObjects === !0 && u.sort(I, N), Q === !0 && D.beginShadows();
        let ne = f.state.shadowsArray;
        if (re.render(ne, P, X), Q === !0 && D.endShadows(), this.info.autoReset === !0 && this.info.reset(), ye.render(u, P), f.setupLights(m.physicallyCorrectLights), X.isArrayCamera) {
            let ee = X.cameras;
            for(let fe = 0, Ue = ee.length; fe < Ue; fe++){
                let He = ee[fe];
                Ur(u, P, He, He.viewport);
            }
        } else Ur(u, P, X);
        w !== null && (V.updateMultisampleRenderTarget(w), V.updateRenderTargetMipmap(w)), P.isScene === !0 && P.onAfterRender(m, P, X), rt.resetDefaultState(), b = -1, S = null, p.pop(), p.length > 0 ? f = p[p.length - 1] : f = null, d.pop(), d.length > 0 ? u = d[d.length - 1] : u = null;
    };
    function Ut(P, X, ne, ee) {
        if (P.visible === !1) return;
        if (P.layers.test(X.layers)) {
            if (P.isGroup) ne = P.renderOrder;
            else if (P.isLOD) P.autoUpdate === !0 && P.update(X);
            else if (P.isLight) f.pushLight(P), P.castShadow && f.pushShadow(P);
            else if (P.isSprite) {
                if (!P.frustumCulled || te.intersectsSprite(P)) {
                    ee && j.setFromMatrixPosition(P.matrixWorld).applyMatrix4(z);
                    let He = ve.update(P), nt = P.material;
                    nt.visible && u.push(P, He, nt, ne, j.z, null);
                }
            } else if ((P.isMesh || P.isLine || P.isPoints) && (P.isSkinnedMesh && P.skeleton.frame !== he.render.frame && (P.skeleton.update(), P.skeleton.frame = he.render.frame), !P.frustumCulled || te.intersectsObject(P))) {
                ee && j.setFromMatrixPosition(P.matrixWorld).applyMatrix4(z);
                let He = ve.update(P), nt = P.material;
                if (Array.isArray(nt)) {
                    let it = He.groups;
                    for(let Et = 0, St = it.length; Et < St; Et++){
                        let _t = it[Et], nr = nt[_t.materialIndex];
                        nr && nr.visible && u.push(P, He, nr, ne, j.z, _t);
                    }
                } else nt.visible && u.push(P, He, nt, ne, j.z, null);
            }
        }
        let Ue = P.children;
        for(let He = 0, nt = Ue.length; He < nt; He++)Ut(Ue[He], X, ne, ee);
    }
    function Ur(P, X, ne, ee) {
        let fe = P.opaque, Ue = P.transmissive, He = P.transparent;
        f.setupLightsView(ne), Ue.length > 0 && ia(fe, X, ne), ee && H.viewport(T.copy(ee)), fe.length > 0 && Nn(fe, X, ne), Ue.length > 0 && Nn(Ue, X, ne), He.length > 0 && Nn(He, X, ne), H.buffers.depth.setTest(!0), H.buffers.depth.setMask(!0), H.buffers.color.setMask(!0), H.setPolygonOffset(!1);
    }
    function ia(P, X, ne) {
        let ee = le.isWebGL2;
        F === null && (F = new mt(1, 1, {
            generateMipmaps: !0,
            type: oe.has("EXT_color_buffer_half_float") ? Vc : qt,
            minFilter: js,
            samples: ee && s === !0 ? 4 : 0
        })), m.getDrawingBufferSize(O), ee ? F.setSize(O.x, O.y) : F.setSize(mf(O.x), mf(O.y));
        let fe = m.getRenderTarget();
        m.setRenderTarget(F), m.clear();
        let Ue = m.toneMapping;
        m.toneMapping = rs, Nn(P, X, ne), m.toneMapping = Ue, V.updateMultisampleRenderTarget(F), V.updateRenderTargetMipmap(F), m.setRenderTarget(fe);
    }
    function Nn(P, X, ne) {
        let ee = X.isScene === !0 ? X.overrideMaterial : null;
        for(let fe = 0, Ue = P.length; fe < Ue; fe++){
            let He = P[fe], nt = He.object, it = He.geometry, Et = ee === null ? He.material : ee, St = He.group;
            nt.layers.test(ne.layers) && at(nt, X, ne, it, Et, St);
        }
    }
    function at(P, X, ne, ee, fe, Ue) {
        P.onBeforeRender(m, X, ne, ee, fe, Ue), P.modelViewMatrix.multiplyMatrices(ne.matrixWorldInverse, P.matrixWorld), P.normalMatrix.getNormalMatrix(P.modelViewMatrix), fe.onBeforeRender(m, X, ne, ee, P, Ue), fe.transparent === !0 && fe.side === or ? (fe.side = Pr, fe.needsUpdate = !0, m.renderBufferDirect(ne, X, ee, fe, P, Ue), fe.side = ii, fe.needsUpdate = !0, m.renderBufferDirect(ne, X, ee, fe, P, Ue), fe.side = or) : m.renderBufferDirect(ne, X, ee, fe, P, Ue), P.onAfterRender(m, X, ne, ee, fe, Ue);
    }
    function ut(P, X, ne) {
        X.isScene !== !0 && (X = q);
        let ee = K.get(P), fe = f.state.lights, Ue = f.state.shadowsArray, He = fe.state.version, nt = me.getParameters(P, fe.state, Ue, X, ne), it = me.getProgramCacheKey(nt), Et = ee.programs;
        ee.environment = P.isMeshStandardMaterial ? X.environment : null, ee.fog = X.fog, ee.envMap = (P.isMeshStandardMaterial ? ce : Z).get(P.envMap || ee.environment), Et === void 0 && (P.addEventListener("dispose", De), Et = new Map, ee.programs = Et);
        let St = Et.get(it);
        if (St !== void 0) {
            if (ee.currentProgram === St && ee.lightsStateVersion === He) return ft(P, nt), St;
        } else nt.uniforms = me.getUniforms(P), P.onBuild(ne, nt, m), P.onBeforeCompile(nt, m), St = me.acquireProgram(nt, it), Et.set(it, St), ee.uniforms = nt.uniforms;
        let _t = ee.uniforms;
        (!P.isShaderMaterial && !P.isRawShaderMaterial || P.clipping === !0) && (_t.clippingPlanes = D.uniform), ft(P, nt), ee.needsLights = It(P), ee.lightsStateVersion = He, ee.needsLights && (_t.ambientLightColor.value = fe.state.ambient, _t.lightProbe.value = fe.state.probe, _t.directionalLights.value = fe.state.directional, _t.directionalLightShadows.value = fe.state.directionalShadow, _t.spotLights.value = fe.state.spot, _t.spotLightShadows.value = fe.state.spotShadow, _t.rectAreaLights.value = fe.state.rectArea, _t.ltc_1.value = fe.state.rectAreaLTC1, _t.ltc_2.value = fe.state.rectAreaLTC2, _t.pointLights.value = fe.state.point, _t.pointLightShadows.value = fe.state.pointShadow, _t.hemisphereLights.value = fe.state.hemi, _t.directionalShadowMap.value = fe.state.directionalShadowMap, _t.directionalShadowMatrix.value = fe.state.directionalShadowMatrix, _t.spotShadowMap.value = fe.state.spotShadowMap, _t.spotShadowMatrix.value = fe.state.spotShadowMatrix, _t.pointShadowMap.value = fe.state.pointShadowMap, _t.pointShadowMatrix.value = fe.state.pointShadowMatrix);
        let nr = St.getUniforms(), xo = Is.seqWithValue(nr.seq, _t);
        return ee.currentProgram = St, ee.uniformsList = xo, St;
    }
    function ft(P, X) {
        let ne = K.get(P);
        ne.outputEncoding = X.outputEncoding, ne.instancing = X.instancing, ne.skinning = X.skinning, ne.morphTargets = X.morphTargets, ne.morphNormals = X.morphNormals, ne.morphColors = X.morphColors, ne.morphTargetsCount = X.morphTargetsCount, ne.numClippingPlanes = X.numClippingPlanes, ne.numIntersection = X.numClipIntersection, ne.vertexAlphas = X.vertexAlphas, ne.vertexTangents = X.vertexTangents, ne.toneMapping = X.toneMapping;
    }
    function pt(P, X, ne, ee, fe) {
        X.isScene !== !0 && (X = q), V.resetTextureUnits();
        let Ue = X.fog, He = ee.isMeshStandardMaterial ? X.environment : null, nt = w === null ? m.outputEncoding : w.isXRRenderTarget === !0 ? w.texture.encoding : gn, it = (ee.isMeshStandardMaterial ? ce : Z).get(ee.envMap || He), Et = ee.vertexColors === !0 && !!ne.attributes.color && ne.attributes.color.itemSize === 4, St = !!ee.normalMap && !!ne.attributes.tangent, _t = !!ne.morphAttributes.position, nr = !!ne.morphAttributes.normal, xo = !!ne.morphAttributes.color, sa = ee.toneMapped ? m.toneMapping : rs, oa = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color, wi = oa !== void 0 ? oa.length : 0, Rt = K.get(ee), aa = f.state.lights;
        if (Q === !0 && (Y === !0 || P !== S)) {
            let Mi = P === S && ee.id === b;
            D.setState(ee, P, Mi);
        }
        let yr = !1;
        ee.version === Rt.__version ? (Rt.needsLights && Rt.lightsStateVersion !== aa.state.version || Rt.outputEncoding !== nt || fe.isInstancedMesh && Rt.instancing === !1 || !fe.isInstancedMesh && Rt.instancing === !0 || fe.isSkinnedMesh && Rt.skinning === !1 || !fe.isSkinnedMesh && Rt.skinning === !0 || Rt.envMap !== it || ee.fog === !0 && Rt.fog !== Ue || Rt.numClippingPlanes !== void 0 && (Rt.numClippingPlanes !== D.numPlanes || Rt.numIntersection !== D.numIntersection) || Rt.vertexAlphas !== Et || Rt.vertexTangents !== St || Rt.morphTargets !== _t || Rt.morphNormals !== nr || Rt.morphColors !== xo || Rt.toneMapping !== sa || le.isWebGL2 === !0 && Rt.morphTargetsCount !== wi) && (yr = !0) : (yr = !0, Rt.__version = ee.version);
        let Si = Rt.currentProgram;
        yr === !0 && (Si = ut(ee, X, fe));
        let bs = !1, Ac = !1, pm = !1, en = Si.getUniforms(), Tc = Rt.uniforms;
        if (H.useProgram(Si.program) && (bs = !0, Ac = !0, pm = !0), ee.id !== b && (b = ee.id, Ac = !0), bs || S !== P) {
            if (en.setValue(W, "projectionMatrix", P.projectionMatrix), le.logarithmicDepthBuffer && en.setValue(W, "logDepthBufFC", 2 / (Math.log(P.far + 1) / Math.LN2)), S !== P && (S = P, Ac = !0, pm = !0), ee.isShaderMaterial || ee.isMeshPhongMaterial || ee.isMeshToonMaterial || ee.isMeshStandardMaterial || ee.envMap) {
                let Mi = en.map.cameraPosition;
                Mi !== void 0 && Mi.setValue(W, j.setFromMatrixPosition(P.matrixWorld));
            }
            (ee.isMeshPhongMaterial || ee.isMeshToonMaterial || ee.isMeshLambertMaterial || ee.isMeshBasicMaterial || ee.isMeshStandardMaterial || ee.isShaderMaterial) && en.setValue(W, "isOrthographic", P.isOrthographicCamera === !0), (ee.isMeshPhongMaterial || ee.isMeshToonMaterial || ee.isMeshLambertMaterial || ee.isMeshBasicMaterial || ee.isMeshStandardMaterial || ee.isShaderMaterial || ee.isShadowMaterial || fe.isSkinnedMesh) && en.setValue(W, "viewMatrix", P.matrixWorldInverse);
        }
        if (fe.isSkinnedMesh) {
            en.setOptional(W, fe, "bindMatrix"), en.setOptional(W, fe, "bindMatrixInverse");
            let Mi = fe.skeleton;
            Mi && (le.floatVertexTextures ? (Mi.boneTexture === null && Mi.computeBoneTexture(), en.setValue(W, "boneTexture", Mi.boneTexture, V), en.setValue(W, "boneTextureSize", Mi.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
        }
        let mm = ne.morphAttributes;
        return (mm.position !== void 0 || mm.normal !== void 0 || mm.color !== void 0 && le.isWebGL2 === !0) && Se.update(fe, ne, ee, Si), (Ac || Rt.receiveShadow !== fe.receiveShadow) && (Rt.receiveShadow = fe.receiveShadow, en.setValue(W, "receiveShadow", fe.receiveShadow)), Ac && (en.setValue(W, "toneMappingExposure", m.toneMappingExposure), Rt.needsLights && xt(Tc, pm), Ue && ee.fog === !0 && Pe.refreshFogUniforms(Tc, Ue), Pe.refreshMaterialUniforms(Tc, ee, C, _, F), Is.upload(W, Rt.uniformsList, Tc, V)), ee.isShaderMaterial && ee.uniformsNeedUpdate === !0 && (Is.upload(W, Rt.uniformsList, Tc, V), ee.uniformsNeedUpdate = !1), ee.isSpriteMaterial && en.setValue(W, "center", fe.center), en.setValue(W, "modelViewMatrix", fe.modelViewMatrix), en.setValue(W, "normalMatrix", fe.normalMatrix), en.setValue(W, "modelMatrix", fe.matrixWorld), Si;
    }
    function xt(P, X) {
        P.ambientLightColor.needsUpdate = X, P.lightProbe.needsUpdate = X, P.directionalLights.needsUpdate = X, P.directionalLightShadows.needsUpdate = X, P.pointLights.needsUpdate = X, P.pointLightShadows.needsUpdate = X, P.spotLights.needsUpdate = X, P.spotLightShadows.needsUpdate = X, P.rectAreaLights.needsUpdate = X, P.hemisphereLights.needsUpdate = X;
    }
    function It(P) {
        return P.isMeshLambertMaterial || P.isMeshToonMaterial || P.isMeshPhongMaterial || P.isMeshStandardMaterial || P.isShadowMaterial || P.isShaderMaterial && P.lights === !0;
    }
    this.getActiveCubeFace = function() {
        return v;
    }, this.getActiveMipmapLevel = function() {
        return y;
    }, this.getRenderTarget = function() {
        return w;
    }, this.setRenderTargetTextures = function(P, X, ne) {
        K.get(P.texture).__webglTexture = X, K.get(P.depthTexture).__webglTexture = ne;
        let ee = K.get(P);
        ee.__hasExternalTextures = !0, ee.__hasExternalTextures && (ee.__autoAllocateDepthBuffer = ne === void 0, ee.__autoAllocateDepthBuffer || oe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ee.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(P, X) {
        let ne = K.get(P);
        ne.__webglFramebuffer = X, ne.__useDefaultFramebuffer = X === void 0;
    }, this.setRenderTarget = function(P, X = 0, ne = 0) {
        w = P, v = X, y = ne;
        let ee = !0;
        if (P) {
            let it = K.get(P);
            it.__useDefaultFramebuffer !== void 0 ? (H.bindFramebuffer(36160, null), ee = !1) : it.__webglFramebuffer === void 0 ? V.setupRenderTarget(P) : it.__hasExternalTextures && V.rebindTextures(P, K.get(P.texture).__webglTexture, K.get(P.depthTexture).__webglTexture);
        }
        let fe = null, Ue = !1, He = !1;
        if (P) {
            let it = P.texture;
            (it.isData3DTexture || it.isDataArrayTexture) && (He = !0);
            let Et = K.get(P).__webglFramebuffer;
            P.isWebGLCubeRenderTarget ? (fe = Et[X], Ue = !0) : le.isWebGL2 && P.samples > 0 && V.useMultisampledRTT(P) === !1 ? fe = K.get(P).__webglMultisampledFramebuffer : fe = Et, T.copy(P.viewport), A.copy(P.scissor), x = P.scissorTest;
        } else T.copy(R).multiplyScalar(C).floor(), A.copy(k).multiplyScalar(C).floor(), x = G;
        if (H.bindFramebuffer(36160, fe) && le.drawBuffers && ee && H.drawBuffers(P, fe), H.viewport(T), H.scissor(A), H.setScissorTest(x), Ue) {
            let it = K.get(P.texture);
            W.framebufferTexture2D(36160, 36064, 34069 + X, it.__webglTexture, ne);
        } else if (He) {
            let it = K.get(P.texture), Et = X || 0;
            W.framebufferTextureLayer(36160, 36064, it.__webglTexture, ne || 0, Et);
        }
        b = -1;
    }, this.readRenderTargetPixels = function(P, X, ne, ee, fe, Ue, He) {
        if (!(P && P.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
        }
        let nt = K.get(P).__webglFramebuffer;
        if (P.isWebGLCubeRenderTarget && He !== void 0 && (nt = nt[He]), nt) {
            H.bindFramebuffer(36160, nt);
            try {
                let it = P.texture, Et = it.format, St = it.type;
                if (Et !== Fn && ue.convert(Et) !== W.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return;
                }
                let _t = St === Vc && (oe.has("EXT_color_buffer_half_float") || le.isWebGL2 && oe.has("EXT_color_buffer_float"));
                if (St !== qt && ue.convert(St) !== W.getParameter(35738) && !(St === Ds && (le.isWebGL2 || oe.has("OES_texture_float") || oe.has("WEBGL_color_buffer_float"))) && !_t) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return;
                }
                X >= 0 && X <= P.width - ee && ne >= 0 && ne <= P.height - fe && W.readPixels(X, ne, ee, fe, ue.convert(Et), ue.convert(St), Ue);
            } finally{
                let it = w !== null ? K.get(w).__webglFramebuffer : null;
                H.bindFramebuffer(36160, it);
            }
        }
    }, this.copyFramebufferToTexture = function(P, X, ne = 0) {
        if (X.isFramebufferTexture !== !0) {
            console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
            return;
        }
        let ee = Math.pow(2, -ne), fe = Math.floor(X.image.width * ee), Ue = Math.floor(X.image.height * ee);
        V.setTexture2D(X, 0), W.copyTexSubImage2D(3553, ne, 0, 0, P.x, P.y, fe, Ue), H.unbindTexture();
    }, this.copyTextureToTexture = function(P, X, ne, ee = 0) {
        let fe = X.image.width, Ue = X.image.height, He = ue.convert(ne.format), nt = ue.convert(ne.type);
        V.setTexture2D(ne, 0), W.pixelStorei(37440, ne.flipY), W.pixelStorei(37441, ne.premultiplyAlpha), W.pixelStorei(3317, ne.unpackAlignment), X.isDataTexture ? W.texSubImage2D(3553, ee, P.x, P.y, fe, Ue, He, nt, X.image.data) : X.isCompressedTexture ? W.compressedTexSubImage2D(3553, ee, P.x, P.y, X.mipmaps[0].width, X.mipmaps[0].height, He, X.mipmaps[0].data) : W.texSubImage2D(3553, ee, P.x, P.y, He, nt, X.image), ee === 0 && ne.generateMipmaps && W.generateMipmap(3553), H.unbindTexture();
    }, this.copyTextureToTexture3D = function(P, X, ne, ee, fe = 0) {
        if (m.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
        }
        let Ue = P.max.x - P.min.x + 1, He = P.max.y - P.min.y + 1, nt = P.max.z - P.min.z + 1, it = ue.convert(ee.format), Et = ue.convert(ee.type), St;
        if (ee.isData3DTexture) V.setTexture3D(ee, 0), St = 32879;
        else if (ee.isDataArrayTexture) V.setTexture2DArray(ee, 0), St = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
        }
        W.pixelStorei(37440, ee.flipY), W.pixelStorei(37441, ee.premultiplyAlpha), W.pixelStorei(3317, ee.unpackAlignment);
        let _t = W.getParameter(3314), nr = W.getParameter(32878), xo = W.getParameter(3316), sa = W.getParameter(3315), oa = W.getParameter(32877), wi = ne.isCompressedTexture ? ne.mipmaps[0] : ne.image;
        W.pixelStorei(3314, wi.width), W.pixelStorei(32878, wi.height), W.pixelStorei(3316, P.min.x), W.pixelStorei(3315, P.min.y), W.pixelStorei(32877, P.min.z), ne.isDataTexture || ne.isData3DTexture ? W.texSubImage3D(St, fe, X.x, X.y, X.z, Ue, He, nt, it, Et, wi.data) : ne.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), W.compressedTexSubImage3D(St, fe, X.x, X.y, X.z, Ue, He, nt, it, wi.data)) : W.texSubImage3D(St, fe, X.x, X.y, X.z, Ue, He, nt, it, Et, wi), W.pixelStorei(3314, _t), W.pixelStorei(32878, nr), W.pixelStorei(3316, xo), W.pixelStorei(3315, sa), W.pixelStorei(32877, oa), fe === 0 && ee.generateMipmaps && W.generateMipmap(St), H.unbindTexture();
    }, this.initTexture = function(P) {
        V.setTexture2D(P, 0), H.unbindTexture();
    }, this.resetState = function() {
        v = 0, y = 0, w = null, H.reset(), rt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
    }));
}
Pt.prototype.isWebGLRenderer = !0;
var mg = class extends Pt {
};
mg.prototype.isWebGL1Renderer = !0;
var Kc = class {
    constructor(e, t = 25e-5){
        this.name = "", this.color = new be(e), this.density = t;
    }
    clone() {
        return new Kc(this.color, this.density);
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    }
};
Kc.prototype.isFogExp2 = !0;
var Do = class {
    constructor(e, t = 1, r = 1e3){
        this.name = "", this.color = new be(e), this.near = t, this.far = r;
    }
    clone() {
        return new Do(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
};
Do.prototype.isFog = !0;
var on = class extends ot {
    constructor(){
        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }));
    }
    copy(e, t) {
        return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
    }
};
on.prototype.isScene = !0;
var ss = class {
    constructor(e, t){
        this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Hc, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = Un();
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setUsage(e) {
        return this.usage = e, this;
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
    }
    copyAt(e, t, r) {
        e *= this.stride, r *= t.stride;
        for(let n = 0, s = this.stride; n < s; n++)this.array[e + n] = t.array[r + n];
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Un()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride);
        return r.setUsage(this.usage), r;
    }
    onUpload(e) {
        return this.onUploadCallback = e, this;
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Un()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
};
ss.prototype.isInterleavedBuffer = !0;
var tn = new M, _i = class {
    constructor(e, t, r, n = !1){
        this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = n === !0;
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
        for(let t = 0, r = this.data.count; t < r; t++)tn.fromBufferAttribute(this, t), tn.applyMatrix4(e), this.setXYZ(t, tn.x, tn.y, tn.z);
        return this;
    }
    applyNormalMatrix(e) {
        for(let t = 0, r = this.count; t < r; t++)tn.fromBufferAttribute(this, t), tn.applyNormalMatrix(e), this.setXYZ(t, tn.x, tn.y, tn.z);
        return this;
    }
    transformDirection(e) {
        for(let t = 0, r = this.count; t < r; t++)tn.fromBufferAttribute(this, t), tn.transformDirection(e), this.setXYZ(t, tn.x, tn.y, tn.z);
        return this;
    }
    setX(e, t) {
        return this.data.array[e * this.data.stride + this.offset] = t, this;
    }
    setY(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
    }
    setZ(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
    }
    setW(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
    }
    getX(e) {
        return this.data.array[e * this.data.stride + this.offset];
    }
    getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
    }
    getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
    }
    getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
    }
    setXY(e, t, r) {
        return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
    }
    setXYZ(e, t, r, n) {
        return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this;
    }
    setXYZW(e, t, r, n, s) {
        return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = n, this.data.array[e + 3] = s, this;
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            let t = [];
            for(let r = 0; r < this.count; r++){
                let n = r * this.data.stride + this.offset;
                for(let s = 0; s < this.itemSize; s++)t.push(this.data.array[n + s]);
            }
            return new Ve(new this.array.constructor(t), this.itemSize, this.normalized);
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new _i(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            let t = [];
            for(let r = 0; r < this.count; r++){
                let n = r * this.data.stride + this.offset;
                for(let s = 0; s < this.itemSize; s++)t.push(this.data.array[n + s]);
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            };
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        };
    }
};
_i.prototype.isInterleavedBufferAttribute = !0;
var Zc = class extends ur {
    constructor(e){
        super(), this.type = "SpriteMaterial", this.color = new be(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
};
Zc.prototype.isSpriteMaterial = !0;
var Sa, Dc = new M, Ma = new M, Aa = new M, Ta = new B, Pc = new B, Cb = new Ae, Xu = new M, Lc = new M, Qu = new M, N0 = new B, Xm = new B, O0 = new B, gg = class extends ot {
    constructor(e){
        if (super(), this.type = "Sprite", Sa === void 0) {
            Sa = new Le;
            let t = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                .5,
                -0.5,
                0,
                1,
                0,
                .5,
                .5,
                0,
                1,
                1,
                -0.5,
                .5,
                0,
                0,
                1
            ]), r = new ss(t, 5);
            Sa.setIndex([
                0,
                1,
                2,
                0,
                2,
                3
            ]), Sa.setAttribute("position", new _i(r, 3, 0, !1)), Sa.setAttribute("uv", new _i(r, 2, 3, !1));
        }
        this.geometry = Sa, this.material = e !== void 0 ? e : new Zc, this.center = new B(.5, .5);
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ma.setFromMatrixScale(this.matrixWorld), Cb.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Aa.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Ma.multiplyScalar(-Aa.z);
        let r = this.material.rotation, n, s;
        r !== 0 && (s = Math.cos(r), n = Math.sin(r));
        let o = this.center;
        Ju(Xu.set(-0.5, -0.5, 0), Aa, o, Ma, n, s), Ju(Lc.set(.5, -0.5, 0), Aa, o, Ma, n, s), Ju(Qu.set(.5, .5, 0), Aa, o, Ma, n, s), N0.set(0, 0), Xm.set(1, 0), O0.set(1, 1);
        let a = e.ray.intersectTriangle(Xu, Lc, Qu, !1, Dc);
        if (a === null && (Ju(Lc.set(-0.5, .5, 0), Aa, o, Ma, n, s), Xm.set(0, 1), a = e.ray.intersectTriangle(Xu, Qu, Lc, !1, Dc), a === null)) return;
        let l = e.ray.origin.distanceTo(Dc);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: Dc.clone(),
            uv: Jt.getUV(Dc, Xu, Lc, Qu, N0, Xm, O0, new B),
            face: null,
            object: this
        });
    }
    copy(e) {
        return super.copy(e), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
    }
};
gg.prototype.isSprite = !0;
function Ju(i, e, t, r, n, s) {
    Ta.subVectors(i, t).addScalar(.5).multiply(r), n !== void 0 ? (Pc.x = s * Ta.x - n * Ta.y, Pc.y = n * Ta.x + s * Ta.y) : Pc.copy(Ta), i.copy(e), i.x += Pc.x, i.y += Pc.y, i.applyMatrix4(Cb);
}
var F0 = new M, U0 = new Je, z0 = new Je, PL = new M, G0 = new Ae, wf = class extends Vt {
    constructor(e, t){
        super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ae, this.bindMatrixInverse = new Ae;
    }
    copy(e) {
        return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
    }
    bind(e, t) {
        this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        let e = new Je, t = this.geometry.attributes.skinWeight;
        for(let r = 0, n = t.count; r < n; r++){
            e.fromBufferAttribute(t, r);
            let s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(e, t) {
        let r = this.skeleton, n = this.geometry;
        U0.fromBufferAttribute(n.attributes.skinIndex, e), z0.fromBufferAttribute(n.attributes.skinWeight, e), F0.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
        for(let s = 0; s < 4; s++){
            let o = z0.getComponent(s);
            if (o !== 0) {
                let a = U0.getComponent(s);
                G0.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]), t.addScaledVector(PL.copy(F0).applyMatrix4(G0), o);
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
    }
};
wf.prototype.isSkinnedMesh = !0;
var yg = class extends ot {
    constructor(){
        super(), this.type = "Bone";
    }
};
yg.prototype.isBone = !0;
var Sf = class extends Dt {
    constructor(e = null, t = 1, r = 1, n, s, o, a, l, c = hr, h = hr, u, f){
        super(null, o, a, l, c, h, n, s, u, f), this.image = {
            data: e,
            width: t,
            height: r
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
};
Sf.prototype.isDataTexture = !0;
var Oa = class extends Ve {
    constructor(e, t, r, n = 1){
        typeof r == "number" && (n = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, r), this.meshPerAttribute = n;
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
    }
};
Oa.prototype.isInstancedBufferAttribute = !0;
var k0 = new Ae, V0 = new Ae, Ku = [], Ic = new Vt, vg = class extends Vt {
    constructor(e, t, r){
        super(e, t), this.instanceMatrix = new Oa(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1;
    }
    copy(e) {
        return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16);
    }
    raycast(e, t) {
        let r = this.matrixWorld, n = this.count;
        if (Ic.geometry = this.geometry, Ic.material = this.material, Ic.material !== void 0) for(let s = 0; s < n; s++){
            this.getMatrixAt(s, k0), V0.multiplyMatrices(r, k0), Ic.matrixWorld = V0, Ic.raycast(e, Ku);
            for(let o = 0, a = Ku.length; o < a; o++){
                let l = Ku[o];
                l.instanceId = s, l.object = this, t.push(l);
            }
            Ku.length = 0;
        }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Oa(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16);
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
};
vg.prototype.isInstancedMesh = !0;
var kr = class extends ur {
    constructor(e){
        super(), this.type = "LineBasicMaterial", this.color = new be(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
    }
};
kr.prototype.isLineBasicMaterial = !0;
var H0 = new M, W0 = new M, j0 = new Ae, Qm = new si, Zu = new Lr, os = class extends ot {
    constructor(e = new Le, t = new kr){
        super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e) {
        return super.copy(e), this.material = e.material, this.geometry = e.geometry, this;
    }
    computeLineDistances() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            if (e.index === null) {
                let t = e.attributes.position, r = [
                    0
                ];
                for(let n = 1, s = t.count; n < s; n++)H0.fromBufferAttribute(t, n - 1), W0.fromBufferAttribute(t, n), r[n] = r[n - 1], r[n] += H0.distanceTo(W0);
                e.setAttribute("lineDistance", new Ce(r, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        } else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
    }
    raycast(e, t) {
        let r = this.geometry, n = this.matrixWorld, s = e.params.Line.threshold, o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(), Zu.copy(r.boundingSphere), Zu.applyMatrix4(n), Zu.radius += s, e.ray.intersectsSphere(Zu) === !1) return;
        j0.copy(n).invert(), Qm.copy(e.ray).applyMatrix4(j0);
        let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new M, h = new M, u = new M, f = new M, d = this.isLineSegments ? 2 : 1;
        if (r.isBufferGeometry) {
            let p = r.index, g = r.attributes.position;
            if (p !== null) {
                let v = Math.max(0, o.start), y = Math.min(p.count, o.start + o.count);
                for(let w = v, b = y - 1; w < b; w += d){
                    let S = p.getX(w), T = p.getX(w + 1);
                    if (c.fromBufferAttribute(g, S), h.fromBufferAttribute(g, T), Qm.distanceSqToSegment(c, h, f, u) > l) continue;
                    f.applyMatrix4(this.matrixWorld);
                    let x = e.ray.origin.distanceTo(f);
                    x < e.near || x > e.far || t.push({
                        distance: x,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: w,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else {
                let v = Math.max(0, o.start), y = Math.min(g.count, o.start + o.count);
                for(let w = v, b = y - 1; w < b; w += d){
                    if (c.fromBufferAttribute(g, w), h.fromBufferAttribute(g, w + 1), Qm.distanceSqToSegment(c, h, f, u) > l) continue;
                    f.applyMatrix4(this.matrixWorld);
                    let T = e.ray.origin.distanceTo(f);
                    T < e.near || T > e.far || t.push({
                        distance: T,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: w,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        } else r.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            let t = e.morphAttributes, r = Object.keys(t);
            if (r.length > 0) {
                let n = t[r[0]];
                if (n !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let s = 0, o = n.length; s < o; s++){
                        let a = n[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
                    }
                }
            }
        } else {
            let t = e.morphTargets;
            t !== void 0 && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    }
};
os.prototype.isLine = !0;
var q0 = new M, Y0 = new M, ai = class extends os {
    constructor(e, t){
        super(e, t), this.type = "LineSegments";
    }
    computeLineDistances() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            if (e.index === null) {
                let t = e.attributes.position, r = [];
                for(let n = 0, s = t.count; n < s; n += 2)q0.fromBufferAttribute(t, n), Y0.fromBufferAttribute(t, n + 1), r[n] = n === 0 ? 0 : r[n - 1], r[n + 1] = r[n] + q0.distanceTo(Y0);
                e.setAttribute("lineDistance", new Ce(r, 1));
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        } else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
    }
};
ai.prototype.isLineSegments = !0;
var xg = class extends os {
    constructor(e, t){
        super(e, t), this.type = "LineLoop";
    }
};
xg.prototype.isLineLoop = !0;
var $c = class extends ur {
    constructor(e){
        super(), this.type = "PointsMaterial", this.color = new be(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
};
$c.prototype.isPointsMaterial = !0;
var X0 = new Ae, bg = new si, $u = new Lr, ef = new M, wg = class extends ot {
    constructor(e = new Le, t = new $c){
        super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e) {
        return super.copy(e), this.material = e.material, this.geometry = e.geometry, this;
    }
    raycast(e, t) {
        let r = this.geometry, n = this.matrixWorld, s = e.params.Points.threshold, o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(), $u.copy(r.boundingSphere), $u.applyMatrix4(n), $u.radius += s, e.ray.intersectsSphere($u) === !1) return;
        X0.copy(n).invert(), bg.copy(e.ray).applyMatrix4(X0);
        let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a;
        if (r.isBufferGeometry) {
            let c = r.index, u = r.attributes.position;
            if (c !== null) {
                let f = Math.max(0, o.start), d = Math.min(c.count, o.start + o.count);
                for(let p = f, m = d; p < m; p++){
                    let g = c.getX(p);
                    ef.fromBufferAttribute(u, g), Q0(ef, g, l, n, e, t, this);
                }
            } else {
                let f = Math.max(0, o.start), d = Math.min(u.count, o.start + o.count);
                for(let p = f, m = d; p < m; p++)ef.fromBufferAttribute(u, p), Q0(ef, p, l, n, e, t, this);
            }
        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            let t = e.morphAttributes, r = Object.keys(t);
            if (r.length > 0) {
                let n = t[r[0]];
                if (n !== void 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let s = 0, o = n.length; s < o; s++){
                        let a = n[s].name || String(s);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
                    }
                }
            }
        } else {
            let t = e.morphTargets;
            t !== void 0 && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    }
};
wg.prototype.isPoints = !0;
function Q0(i, e, t, r, n, s, o) {
    let a = bg.distanceSqToPoint(i);
    if (a < t) {
        let l = new M;
        bg.closestPointToPoint(i, l), l.applyMatrix4(r);
        let c = n.ray.origin.distanceTo(l);
        if (c < n.near || c > n.far) return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        });
    }
}
var eh = class extends Dt {
    constructor(e, t, r, n, s, o, a, l, c){
        super(e, t, r, n, s, o, a, l, c), this.minFilter = o !== void 0 ? o : ct, this.magFilter = s !== void 0 ? s : ct, this.generateMipmaps = !1;
        let h = this;
        function u() {
            h.needsUpdate = !0, e.requestVideoFrameCallback(u);
        }
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        let e = this.image;
        "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
};
eh.prototype.isVideoTexture = !0;
var Sg = class extends Dt {
    constructor(e, t, r){
        super({
            width: e,
            height: t
        }), this.format = r, this.magFilter = hr, this.minFilter = hr, this.generateMipmaps = !1, this.needsUpdate = !0;
    }
};
Sg.prototype.isFramebufferTexture = !0;
var Mg = class extends Dt {
    constructor(e, t, r, n, s, o, a, l, c, h, u, f){
        super(null, o, a, l, c, h, n, s, u, f), this.image = {
            width: t,
            height: r
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
    }
};
Mg.prototype.isCompressedTexture = !0;
var Ag = class extends Dt {
    constructor(e, t, r, n, s, o, a, l, c){
        super(e, t, r, n, s, o, a, l, c), this.needsUpdate = !0;
    }
};
Ag.prototype.isCanvasTexture = !0;
var xn = class {
    constructor(){
        this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e, t) {
        let r = this.getUtoTmapping(e);
        return this.getPoint(r, t);
    }
    getPoints(e = 5) {
        let t = [];
        for(let r = 0; r <= e; r++)t.push(this.getPoint(r / e));
        return t;
    }
    getSpacedPoints(e = 5) {
        let t = [];
        for(let r = 0; r <= e; r++)t.push(this.getPointAt(r / e));
        return t;
    }
    getLength() {
        let e = this.getLengths();
        return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        let t = [], r, n = this.getPoint(0), s = 0;
        t.push(0);
        for(let o = 1; o <= e; o++)r = this.getPoint(o / e), s += r.distanceTo(n), t.push(s), n = r;
        return this.cacheArcLengths = t, t;
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths();
    }
    getUtoTmapping(e, t) {
        let r = this.getLengths(), n = 0, s = r.length, o;
        t ? o = t : o = e * r[s - 1];
        let a = 0, l = s - 1, c;
        for(; a <= l;)if (n = Math.floor(a + (l - a) / 2), c = r[n] - o, c < 0) a = n + 1;
        else if (c > 0) l = n - 1;
        else {
            l = n;
            break;
        }
        if (n = l, r[n] === o) return n / (s - 1);
        let h = r[n], f = r[n + 1] - h, d = (o - h) / f;
        return (n + d) / (s - 1);
    }
    getTangent(e, t) {
        let n = e - 1e-4, s = e + 1e-4;
        n < 0 && (n = 0), s > 1 && (s = 1);
        let o = this.getPoint(n), a = this.getPoint(s), l = t || (o.isVector2 ? new B : new M);
        return l.copy(a).sub(o).normalize(), l;
    }
    getTangentAt(e, t) {
        let r = this.getUtoTmapping(e);
        return this.getTangent(r, t);
    }
    computeFrenetFrames(e, t) {
        let r = new M, n = [], s = [], o = [], a = new M, l = new Ae;
        for(let d = 0; d <= e; d++){
            let p = d / e;
            n[d] = this.getTangentAt(p, new M);
        }
        s[0] = new M, o[0] = new M;
        let c = Number.MAX_VALUE, h = Math.abs(n[0].x), u = Math.abs(n[0].y), f = Math.abs(n[0].z);
        h <= c && (c = h, r.set(1, 0, 0)), u <= c && (c = u, r.set(0, 1, 0)), f <= c && r.set(0, 0, 1), a.crossVectors(n[0], r).normalize(), s[0].crossVectors(n[0], a), o[0].crossVectors(n[0], s[0]);
        for(let d6 = 1; d6 <= e; d6++){
            if (s[d6] = s[d6 - 1].clone(), o[d6] = o[d6 - 1].clone(), a.crossVectors(n[d6 - 1], n[d6]), a.length() > Number.EPSILON) {
                a.normalize();
                let p = Math.acos(xr(n[d6 - 1].dot(n[d6]), -1, 1));
                s[d6].applyMatrix4(l.makeRotationAxis(a, p));
            }
            o[d6].crossVectors(n[d6], s[d6]);
        }
        if (t === !0) {
            let d = Math.acos(xr(s[0].dot(s[e]), -1, 1));
            d /= e, n[0].dot(a.crossVectors(s[0], s[e])) > 0 && (d = -d);
            for(let p = 1; p <= e; p++)s[p].applyMatrix4(l.makeRotationAxis(n[p], d * p)), o[p].crossVectors(n[p], s[p]);
        }
        return {
            tangents: n,
            normals: s,
            binormals: o
        };
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
    toJSON() {
        let e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
}, Us = class extends xn {
    constructor(e = 0, t = 0, r = 1, n = 1, s = 0, o = Math.PI * 2, a = !1, l = 0){
        super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
    }
    getPoint(e, t) {
        let r = t || new B, n = Math.PI * 2, s = this.aEndAngle - this.aStartAngle, o = Math.abs(s) < Number.EPSILON;
        for(; s < 0;)s += n;
        for(; s > n;)s -= n;
        s < Number.EPSILON && (o ? s = 0 : s = n), this.aClockwise === !0 && !o && (s === n ? s = -n : s = s - n);
        let a = this.aStartAngle + e * s, l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            let h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), f = l - this.aX, d = c - this.aY;
            l = f * h - d * u + this.aX, c = f * u + d * h + this.aY;
        }
        return r.set(l, c);
    }
    copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
};
Us.prototype.isEllipseCurve = !0;
var Mf = class extends Us {
    constructor(e, t, r, n, s, o){
        super(e, t, r, r, n, s, o), this.type = "ArcCurve";
    }
};
Mf.prototype.isArcCurve = !0;
function ry() {
    let i = 0, e = 0, t = 0, r = 0;
    function n(s, o, a, l) {
        i = s, e = a, t = -3 * s + 3 * o - 2 * a - l, r = 2 * s - 2 * o + a + l;
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            n(o, a, c * (a - s), c * (l - o));
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, h, u) {
            let f = (o - s) / c - (a - s) / (c + h) + (a - o) / h, d = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            f *= h, d *= h, n(o, a, f, d);
        },
        calc: function(s) {
            let o = s * s, a = o * s;
            return i + e * s + t * o + r * a;
        }
    };
}
var tf = new M, Jm = new ry, Km = new ry, Zm = new ry, Af = class extends xn {
    constructor(e = [], t = !1, r = "centripetal", n = .5){
        super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = n;
    }
    getPoint(e, t = new M) {
        let r = t, n = this.points, s = n.length, o = (s - (this.closed ? 0 : 1)) * e, a = Math.floor(o), l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
        let c, h;
        this.closed || a > 0 ? c = n[(a - 1) % s] : (tf.subVectors(n[0], n[1]).add(n[0]), c = tf);
        let u = n[a % s], f = n[(a + 1) % s];
        if (this.closed || a + 2 < s ? h = n[(a + 2) % s] : (tf.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), h = tf), this.curveType === "centripetal" || this.curveType === "chordal") {
            let d = this.curveType === "chordal" ? .5 : .25, p = Math.pow(c.distanceToSquared(u), d), m = Math.pow(u.distanceToSquared(f), d), g = Math.pow(f.distanceToSquared(h), d);
            m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Jm.initNonuniformCatmullRom(c.x, u.x, f.x, h.x, p, m, g), Km.initNonuniformCatmullRom(c.y, u.y, f.y, h.y, p, m, g), Zm.initNonuniformCatmullRom(c.z, u.z, f.z, h.z, p, m, g);
        } else this.curveType === "catmullrom" && (Jm.initCatmullRom(c.x, u.x, f.x, h.x, this.tension), Km.initCatmullRom(c.y, u.y, f.y, h.y, this.tension), Zm.initCatmullRom(c.z, u.z, f.z, h.z, this.tension));
        return r.set(Jm.calc(l), Km.calc(l), Zm.calc(l)), r;
    }
    copy(e) {
        super.copy(e), this.points = [];
        for(let t = 0, r = e.points.length; t < r; t++){
            let n = e.points[t];
            this.points.push(n.clone());
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
    toJSON() {
        let e = super.toJSON();
        e.points = [];
        for(let t = 0, r = this.points.length; t < r; t++){
            let n = this.points[t];
            e.points.push(n.toArray());
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for(let t = 0, r = e.points.length; t < r; t++){
            let n = e.points[t];
            this.points.push(new M().fromArray(n));
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
};
Af.prototype.isCatmullRomCurve3 = !0;
function J0(i, e, t, r, n) {
    let s = (r - e) * .5, o = (n - t) * .5, a = i * i, l = i * a;
    return (2 * t - 2 * r + s + o) * l + (-3 * t + 3 * r - 2 * s - o) * a + s * i + t;
}
function LL(i, e) {
    let t = 1 - i;
    return t * t * e;
}
function IL(i, e) {
    return 2 * (1 - i) * i * e;
}
function RL(i, e) {
    return i * i * e;
}
function zc(i, e, t, r) {
    return LL(i, e) + IL(i, t) + RL(i, r);
}
function BL(i, e) {
    let t = 1 - i;
    return t * t * t * e;
}
function NL(i, e) {
    let t = 1 - i;
    return 3 * t * t * i * e;
}
function OL(i, e) {
    return 3 * (1 - i) * i * i * e;
}
function FL(i, e) {
    return i * i * i * e;
}
function Gc(i, e, t, r, n) {
    return BL(i, e) + NL(i, t) + OL(i, r) + FL(i, n);
}
var an = class extends xn {
    constructor(e = new B, t = new B, r = new B, n = new B){
        super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
    }
    getPoint(e, t = new B) {
        let r = t, n = this.v0, s = this.v1, o = this.v2, a = this.v3;
        return r.set(Gc(e, n.x, s.x, o.x, a.x), Gc(e, n.y, s.y, o.y, a.y)), r;
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
};
an.prototype.isCubicBezierCurve = !0;
var Tf = class extends xn {
    constructor(e = new M, t = new M, r = new M, n = new M){
        super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = n;
    }
    getPoint(e, t = new M) {
        let r = t, n = this.v0, s = this.v1, o = this.v2, a = this.v3;
        return r.set(Gc(e, n.x, s.x, o.x, a.x), Gc(e, n.y, s.y, o.y, a.y), Gc(e, n.z, s.z, o.z, a.z)), r;
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
};
Tf.prototype.isCubicBezierCurve3 = !0;
var ln = class extends xn {
    constructor(e = new B, t = new B){
        super(), this.type = "LineCurve", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new B) {
        let r = t;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    getTangent(e, t) {
        let r = t || new B;
        return r.copy(this.v2).sub(this.v1).normalize(), r;
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
};
ln.prototype.isLineCurve = !0;
var th = class extends xn {
    constructor(e = new M, t = new M){
        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new M) {
        let r = t;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
}, kn = class extends xn {
    constructor(e = new B, t = new B, r = new B){
        super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
    }
    getPoint(e, t = new B) {
        let r = t, n = this.v0, s = this.v1, o = this.v2;
        return r.set(zc(e, n.x, s.x, o.x), zc(e, n.y, s.y, o.y)), r;
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
};
kn.prototype.isQuadraticBezierCurve = !0;
var Ef = class extends xn {
    constructor(e = new M, t = new M, r = new M){
        super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
    }
    getPoint(e, t = new M) {
        let r = t, n = this.v0, s = this.v1, o = this.v2;
        return r.set(zc(e, n.x, s.x, o.x), zc(e, n.y, s.y, o.y), zc(e, n.z, s.z, o.z)), r;
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
};
Ef.prototype.isQuadraticBezierCurve3 = !0;
var Po = class extends xn {
    constructor(e = []){
        super(), this.type = "SplineCurve", this.points = e;
    }
    getPoint(e, t = new B) {
        let r = t, n = this.points, s = (n.length - 1) * e, o = Math.floor(s), a = s - o, l = n[o === 0 ? o : o - 1], c = n[o], h = n[o > n.length - 2 ? n.length - 1 : o + 1], u = n[o > n.length - 3 ? n.length - 1 : o + 2];
        return r.set(J0(a, l.x, c.x, h.x, u.x), J0(a, l.y, c.y, h.y, u.y)), r;
    }
    copy(e) {
        super.copy(e), this.points = [];
        for(let t = 0, r = e.points.length; t < r; t++){
            let n = e.points[t];
            this.points.push(n.clone());
        }
        return this;
    }
    toJSON() {
        let e = super.toJSON();
        e.points = [];
        for(let t = 0, r = this.points.length; t < r; t++){
            let n = this.points[t];
            e.points.push(n.toArray());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for(let t = 0, r = e.points.length; t < r; t++){
            let n = e.points[t];
            this.points.push(new B().fromArray(n));
        }
        return this;
    }
};
Po.prototype.isSplineCurve = !0;
var Db = Object.freeze({
    __proto__: null,
    ArcCurve: Mf,
    CatmullRomCurve3: Af,
    CubicBezierCurve: an,
    CubicBezierCurve3: Tf,
    EllipseCurve: Us,
    LineCurve: ln,
    LineCurve3: th,
    QuadraticBezierCurve: kn,
    QuadraticBezierCurve3: Ef,
    SplineCurve: Po
}), Tg = class extends xn {
    constructor(){
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
    }
    add(e) {
        this.curves.push(e);
    }
    closePath() {
        let e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new ln(t, e));
    }
    getPoint(e, t) {
        let r = e * this.getLength(), n = this.getCurveLengths(), s = 0;
        for(; s < n.length;){
            if (n[s] >= r) {
                let o = n[s] - r, a = this.curves[s], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t);
            }
            s++;
        }
        return null;
    }
    getLength() {
        let e = this.getCurveLengths();
        return e[e.length - 1];
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        let e = [], t = 0;
        for(let r = 0, n = this.curves.length; r < n; r++)t += this.curves[r].getLength(), e.push(t);
        return this.cacheLengths = e, e;
    }
    getSpacedPoints(e = 40) {
        let t = [];
        for(let r = 0; r <= e; r++)t.push(this.getPoint(r / e));
        return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
        let t = [], r;
        for(let n = 0, s = this.curves; n < s.length; n++){
            let o = s[n], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
            for(let c = 0; c < l.length; c++){
                let h = l[c];
                r && r.equals(h) || (t.push(h), r = h);
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
    }
    copy(e) {
        super.copy(e), this.curves = [];
        for(let t = 0, r = e.curves.length; t < r; t++){
            let n = e.curves[t];
            this.curves.push(n.clone());
        }
        return this.autoClose = e.autoClose, this;
    }
    toJSON() {
        let e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for(let t = 0, r = this.curves.length; t < r; t++){
            let n = this.curves[t];
            e.curves.push(n.toJSON());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for(let t = 0, r = e.curves.length; t < r; t++){
            let n = e.curves[t];
            this.curves.push(new Db[n.type]().fromJSON(n));
        }
        return this;
    }
}, Fa = class extends Tg {
    constructor(e){
        super(), this.type = "Path", this.currentPoint = new B, e && this.setFromPoints(e);
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for(let t = 1, r = e.length; t < r; t++)this.lineTo(e[t].x, e[t].y);
        return this;
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
        let r = new ln(this.currentPoint.clone(), new B(e, t));
        return this.curves.push(r), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, r, n) {
        let s = new kn(this.currentPoint.clone(), new B(e, t), new B(r, n));
        return this.curves.push(s), this.currentPoint.set(r, n), this;
    }
    bezierCurveTo(e, t, r, n, s, o) {
        let a = new an(this.currentPoint.clone(), new B(e, t), new B(r, n), new B(s, o));
        return this.curves.push(a), this.currentPoint.set(s, o), this;
    }
    splineThru(e) {
        let t = [
            this.currentPoint.clone()
        ].concat(e), r = new Po(t);
        return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, r, n, s, o) {
        let a = this.currentPoint.x, l = this.currentPoint.y;
        return this.absarc(e + a, t + l, r, n, s, o), this;
    }
    absarc(e, t, r, n, s, o) {
        return this.absellipse(e, t, r, r, n, s, o), this;
    }
    ellipse(e, t, r, n, s, o, a, l) {
        let c = this.currentPoint.x, h = this.currentPoint.y;
        return this.absellipse(e + c, t + h, r, n, s, o, a, l), this;
    }
    absellipse(e, t, r, n, s, o, a, l) {
        let c = new Us(e, t, r, n, s, o, a, l);
        if (this.curves.length > 0) {
            let u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
        }
        this.curves.push(c);
        let h = c.getPoint(1);
        return this.currentPoint.copy(h), this;
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
        let e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e;
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
    }
}, Ua = class extends Le {
    constructor(e = [
        new B(0, .5),
        new B(.5, 0),
        new B(0, -0.5)
    ], t = 12, r = 0, n = Math.PI * 2){
        super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: n
        }, t = Math.floor(t), n = xr(n, 0, Math.PI * 2);
        let s = [], o = [], a = [], l = [], c = [], h = 1 / t, u = new M, f = new B, d = new M, p = new M, m = new M, g = 0, v = 0;
        for(let y = 0; y <= e.length - 1; y++)switch(y){
            case 0:
                g = e[y + 1].x - e[y].x, v = e[y + 1].y - e[y].y, d.x = v * 1, d.y = -g, d.z = v * 0, m.copy(d), d.normalize(), l.push(d.x, d.y, d.z);
                break;
            case e.length - 1:
                l.push(m.x, m.y, m.z);
                break;
            default:
                g = e[y + 1].x - e[y].x, v = e[y + 1].y - e[y].y, d.x = v * 1, d.y = -g, d.z = v * 0, p.copy(d), d.x += m.x, d.y += m.y, d.z += m.z, d.normalize(), l.push(d.x, d.y, d.z), m.copy(p);
        }
        for(let y4 = 0; y4 <= t; y4++){
            let w = r + y4 * h * n, b = Math.sin(w), S = Math.cos(w);
            for(let T = 0; T <= e.length - 1; T++){
                u.x = e[T].x * b, u.y = e[T].y, u.z = e[T].x * S, o.push(u.x, u.y, u.z), f.x = y4 / t, f.y = T / (e.length - 1), a.push(f.x, f.y);
                let A = l[3 * T + 0] * b, x = l[3 * T + 1], E = l[3 * T + 0] * S;
                c.push(A, x, E);
            }
        }
        for(let y5 = 0; y5 < t; y5++)for(let w = 0; w < e.length - 1; w++){
            let b = w + y5 * e.length, S = b, T = b + e.length, A = b + e.length + 1, x = b + 1;
            s.push(S, T, x), s.push(A, x, T);
        }
        this.setIndex(s), this.setAttribute("position", new Ce(o, 3)), this.setAttribute("uv", new Ce(a, 2)), this.setAttribute("normal", new Ce(c, 3));
    }
    static fromJSON(e) {
        return new Ua(e.points, e.segments, e.phiStart, e.phiLength);
    }
};
var Lo = class extends Le {
    constructor(e = 1, t = 1, r = 1, n = 8, s = 1, o = !1, a = 0, l = Math.PI * 2){
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: n,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        let c = this;
        n = Math.floor(n), s = Math.floor(s);
        let h = [], u = [], f = [], d = [], p = 0, m = [], g = r / 2, v = 0;
        y(), o === !1 && (e > 0 && w(!0), t > 0 && w(!1)), this.setIndex(h), this.setAttribute("position", new Ce(u, 3)), this.setAttribute("normal", new Ce(f, 3)), this.setAttribute("uv", new Ce(d, 2));
        function y() {
            let b = new M, S = new M, T = 0, A = (t - e) / r;
            for(let x = 0; x <= s; x++){
                let E = [], _ = x / s, C = _ * (t - e) + e;
                for(let I = 0; I <= n; I++){
                    let N = I / n, R = N * l + a, k = Math.sin(R), G = Math.cos(R);
                    S.x = C * k, S.y = -_ * r + g, S.z = C * G, u.push(S.x, S.y, S.z), b.set(k, A, G).normalize(), f.push(b.x, b.y, b.z), d.push(N, 1 - _), E.push(p++);
                }
                m.push(E);
            }
            for(let x4 = 0; x4 < n; x4++)for(let E = 0; E < s; E++){
                let _ = m[E][x4], C = m[E + 1][x4], I = m[E + 1][x4 + 1], N = m[E][x4 + 1];
                h.push(_, C, N), h.push(C, I, N), T += 6;
            }
            c.addGroup(v, T, 0), v += T;
        }
        function w(b) {
            let S = p, T = new B, A = new M, x = 0, E = b === !0 ? e : t, _ = b === !0 ? 1 : -1;
            for(let I = 1; I <= n; I++)u.push(0, g * _, 0), f.push(0, _, 0), d.push(.5, .5), p++;
            let C = p;
            for(let I4 = 0; I4 <= n; I4++){
                let R = I4 / n * l + a, k = Math.cos(R), G = Math.sin(R);
                A.x = E * G, A.y = g * _, A.z = E * k, u.push(A.x, A.y, A.z), f.push(0, _, 0), T.x = k * .5 + .5, T.y = G * .5 * _ + .5, d.push(T.x, T.y), p++;
            }
            for(let I5 = 0; I5 < n; I5++){
                let N = S + I5, R = C + I5;
                b === !0 ? h.push(R, R + 1, N) : h.push(R + 1, R, N), x += 3;
            }
            c.addGroup(v, x, b === !0 ? 1 : 2), v += x;
        }
    }
    static fromJSON(e) {
        return new Lo(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
    }
}, za = class extends Lo {
    constructor(e = 1, t = 1, r = 8, n = 1, s = !1, o = 0, a = Math.PI * 2){
        super(0, e, t, r, n, s, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: n,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        };
    }
    static fromJSON(e) {
        return new za(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
    }
}, Ga = class extends Le {
    constructor(e = [], t = [], r = 1, n = 0){
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: n
        };
        let s = [], o = [];
        a(n), c(r), h(), this.setAttribute("position", new Ce(s, 3)), this.setAttribute("normal", new Ce(s.slice(), 3)), this.setAttribute("uv", new Ce(o, 2)), n === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(y) {
            let w = new M, b = new M, S = new M;
            for(let T = 0; T < t.length; T += 3)d(t[T + 0], w), d(t[T + 1], b), d(t[T + 2], S), l(w, b, S, y);
        }
        function l(y, w, b, S) {
            let T = S + 1, A = [];
            for(let x = 0; x <= T; x++){
                A[x] = [];
                let E = y.clone().lerp(b, x / T), _ = w.clone().lerp(b, x / T), C = T - x;
                for(let I = 0; I <= C; I++)I === 0 && x === T ? A[x][I] = E : A[x][I] = E.clone().lerp(_, I / C);
            }
            for(let x5 = 0; x5 < T; x5++)for(let E = 0; E < 2 * (T - x5) - 1; E++){
                let _ = Math.floor(E / 2);
                E % 2 === 0 ? (f(A[x5][_ + 1]), f(A[x5 + 1][_]), f(A[x5][_])) : (f(A[x5][_ + 1]), f(A[x5 + 1][_ + 1]), f(A[x5 + 1][_]));
            }
        }
        function c(y) {
            let w = new M;
            for(let b = 0; b < s.length; b += 3)w.x = s[b + 0], w.y = s[b + 1], w.z = s[b + 2], w.normalize().multiplyScalar(y), s[b + 0] = w.x, s[b + 1] = w.y, s[b + 2] = w.z;
        }
        function h() {
            let y = new M;
            for(let w = 0; w < s.length; w += 3){
                y.x = s[w + 0], y.y = s[w + 1], y.z = s[w + 2];
                let b = g(y) / 2 / Math.PI + .5, S = v(y) / Math.PI + .5;
                o.push(b, 1 - S);
            }
            p(), u();
        }
        function u() {
            for(let y = 0; y < o.length; y += 6){
                let w = o[y + 0], b = o[y + 2], S = o[y + 4], T = Math.max(w, b, S), A = Math.min(w, b, S);
                T > .9 && A < .1 && (w < .2 && (o[y + 0] += 1), b < .2 && (o[y + 2] += 1), S < .2 && (o[y + 4] += 1));
            }
        }
        function f(y) {
            s.push(y.x, y.y, y.z);
        }
        function d(y, w) {
            let b = y * 3;
            w.x = e[b + 0], w.y = e[b + 1], w.z = e[b + 2];
        }
        function p() {
            let y = new M, w = new M, b = new M, S = new M, T = new B, A = new B, x = new B;
            for(let E = 0, _ = 0; E < s.length; E += 9, _ += 6){
                y.set(s[E + 0], s[E + 1], s[E + 2]), w.set(s[E + 3], s[E + 4], s[E + 5]), b.set(s[E + 6], s[E + 7], s[E + 8]), T.set(o[_ + 0], o[_ + 1]), A.set(o[_ + 2], o[_ + 3]), x.set(o[_ + 4], o[_ + 5]), S.copy(y).add(w).add(b).divideScalar(3);
                let C = g(S);
                m(T, _ + 0, y, C), m(A, _ + 2, w, C), m(x, _ + 4, b, C);
            }
        }
        function m(y, w, b, S) {
            S < 0 && y.x === 1 && (o[w] = y.x - 1), b.x === 0 && b.z === 0 && (o[w] = S / 2 / Math.PI + .5);
        }
        function g(y) {
            return Math.atan2(y.z, -y.x);
        }
        function v(y) {
            return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
        }
    }
    static fromJSON(e) {
        return new Ga(e.vertices, e.indices, e.radius, e.details);
    }
}, ka = class extends Ga {
    constructor(e = 1, t = 0){
        let r = (1 + Math.sqrt(5)) / 2, n = 1 / r, s = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -n,
            -r,
            0,
            -n,
            r,
            0,
            n,
            -r,
            0,
            n,
            r,
            -n,
            -r,
            0,
            -n,
            r,
            0,
            n,
            -r,
            0,
            n,
            r,
            0,
            -r,
            0,
            -n,
            r,
            0,
            -n,
            -r,
            0,
            n,
            r,
            0,
            n
        ], o = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
        ];
        super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        };
    }
    static fromJSON(e) {
        return new ka(e.radius, e.detail);
    }
}, dG = new M, pG = new M, mG = new M, gG = new Jt;
var rn = class extends Fa {
    constructor(e){
        super(e), this.uuid = Un(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e) {
        let t = [];
        for(let r = 0, n = this.holes.length; r < n; r++)t[r] = this.holes[r].getPoints(e);
        return t;
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        };
    }
    copy(e) {
        super.copy(e), this.holes = [];
        for(let t = 0, r = e.holes.length; t < r; t++){
            let n = e.holes[t];
            this.holes.push(n.clone());
        }
        return this;
    }
    toJSON() {
        let e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for(let t = 0, r = this.holes.length; t < r; t++){
            let n = this.holes[t];
            e.holes.push(n.toJSON());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for(let t = 0, r = e.holes.length; t < r; t++){
            let n = e.holes[t];
            this.holes.push(new Fa().fromJSON(n));
        }
        return this;
    }
}, UL = {
    triangulate: function(i, e, t = 2) {
        let r = e && e.length, n = r ? e[0] * t : i.length, s = Pb(i, 0, n, t, !0), o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, c, h, u, f, d;
        if (r && (s = HL(i, e, s, t)), i.length > 80 * t) {
            a = c = i[0], l = h = i[1];
            for(let p = t; p < n; p += t)u = i[p], f = i[p + 1], u < a && (a = u), f < l && (l = f), u > c && (c = u), f > h && (h = f);
            d = Math.max(c - a, h - l), d = d !== 0 ? 1 / d : 0;
        }
        return rh(s, o, t, a, l, d), o;
    }
};
function Pb(i, e, t, r, n) {
    let s, o;
    if (n === e2(i, e, t, r) > 0) for(s = e; s < t; s += r)o = K0(s, i[s], i[s + 1], o);
    else for(s = t - r; s >= e; s -= r)o = K0(s, i[s], i[s + 1], o);
    return o && td(o, o.next) && (ih(o), o = o.next), o;
}
function zs(i, e) {
    if (!i) return i;
    e || (e = i);
    let t = i, r;
    do if (r = !1, !t.steiner && (td(t, t.next) || tr(t.prev, t, t.next) === 0)) {
        if (ih(t), t = e = t.prev, t === t.next) break;
        r = !0;
    } else t = t.next;
    while (r || t !== e)
    return e;
}
function rh(i, e, t, r, n, s, o) {
    if (!i) return;
    !o && s && XL(i, r, n, s);
    let a = i, l, c;
    for(; i.prev !== i.next;){
        if (l = i.prev, c = i.next, s ? GL(i, r, n, s) : zL(i)) {
            e.push(l.i / t), e.push(i.i / t), e.push(c.i / t), ih(i), i = c.next, a = c.next;
            continue;
        }
        if (i = c, i === a) {
            o ? o === 1 ? (i = kL(zs(i), e, t), rh(i, e, t, r, n, s, 2)) : o === 2 && VL(i, e, t, r, n, s) : rh(zs(i), e, t, r, n, s, 1);
            break;
        }
    }
}
function zL(i) {
    let e = i.prev, t = i, r = i.next;
    if (tr(e, t, r) >= 0) return !1;
    let n = i.next.next;
    for(; n !== i.prev;){
        if (Pa(e.x, e.y, t.x, t.y, r.x, r.y, n.x, n.y) && tr(n.prev, n, n.next) >= 0) return !1;
        n = n.next;
    }
    return !0;
}
function GL(i, e, t, r) {
    let n = i.prev, s = i, o = i.next;
    if (tr(n, s, o) >= 0) return !1;
    let a = n.x < s.x ? n.x < o.x ? n.x : o.x : s.x < o.x ? s.x : o.x, l = n.y < s.y ? n.y < o.y ? n.y : o.y : s.y < o.y ? s.y : o.y, c = n.x > s.x ? n.x > o.x ? n.x : o.x : s.x > o.x ? s.x : o.x, h = n.y > s.y ? n.y > o.y ? n.y : o.y : s.y > o.y ? s.y : o.y, u = Eg(a, l, e, t, r), f = Eg(c, h, e, t, r), d = i.prevZ, p = i.nextZ;
    for(; d && d.z >= u && p && p.z <= f;){
        if (d !== i.prev && d !== i.next && Pa(n.x, n.y, s.x, s.y, o.x, o.y, d.x, d.y) && tr(d.prev, d, d.next) >= 0 || (d = d.prevZ, p !== i.prev && p !== i.next && Pa(n.x, n.y, s.x, s.y, o.x, o.y, p.x, p.y) && tr(p.prev, p, p.next) >= 0)) return !1;
        p = p.nextZ;
    }
    for(; d && d.z >= u;){
        if (d !== i.prev && d !== i.next && Pa(n.x, n.y, s.x, s.y, o.x, o.y, d.x, d.y) && tr(d.prev, d, d.next) >= 0) return !1;
        d = d.prevZ;
    }
    for(; p && p.z <= f;){
        if (p !== i.prev && p !== i.next && Pa(n.x, n.y, s.x, s.y, o.x, o.y, p.x, p.y) && tr(p.prev, p, p.next) >= 0) return !1;
        p = p.nextZ;
    }
    return !0;
}
function kL(i, e, t) {
    let r = i;
    do {
        let n = r.prev, s = r.next.next;
        !td(n, s) && Lb(n, r, r.next, s) && nh(n, s) && nh(s, n) && (e.push(n.i / t), e.push(r.i / t), e.push(s.i / t), ih(r), ih(r.next), r = i = s), r = r.next;
    }while (r !== i)
    return zs(r);
}
function VL(i, e, t, r, n, s) {
    let o = i;
    do {
        let a = o.next.next;
        for(; a !== o.prev;){
            if (o.i !== a.i && KL(o, a)) {
                let l = Ib(o, a);
                o = zs(o, o.next), l = zs(l, l.next), rh(o, e, t, r, n, s), rh(l, e, t, r, n, s);
                return;
            }
            a = a.next;
        }
        o = o.next;
    }while (o !== i)
}
function HL(i, e, t, r) {
    let n = [], s, o, a, l, c;
    for(s = 0, o = e.length; s < o; s++)a = e[s] * r, l = s < o - 1 ? e[s + 1] * r : i.length, c = Pb(i, a, l, r, !1), c === c.next && (c.steiner = !0), n.push(JL(c));
    for(n.sort(WL), s = 0; s < n.length; s++)jL(n[s], t), t = zs(t, t.next);
    return t;
}
function WL(i, e) {
    return i.x - e.x;
}
function jL(i, e) {
    if (e = qL(i, e), e) {
        let t = Ib(e, i);
        zs(e, e.next), zs(t, t.next);
    }
}
function qL(i, e) {
    let t = e, r = i.x, n = i.y, s = -1 / 0, o;
    do {
        if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
            let f = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (f <= r && f > s) {
                if (s = f, f === r) {
                    if (n === t.y) return t;
                    if (n === t.next.y) return t.next;
                }
                o = t.x < t.next.x ? t : t.next;
            }
        }
        t = t.next;
    }while (t !== e)
    if (!o) return null;
    if (r === s) return o;
    let a = o, l = o.x, c = o.y, h = 1 / 0, u;
    t = o;
    do r >= t.x && t.x >= l && r !== t.x && Pa(n < c ? r : s, n, l, c, n < c ? s : r, n, t.x, t.y) && (u = Math.abs(n - t.y) / (r - t.x), nh(t, i) && (u < h || u === h && (t.x > o.x || t.x === o.x && YL(o, t))) && (o = t, h = u)), t = t.next;
    while (t !== a)
    return o;
}
function YL(i, e) {
    return tr(i.prev, i, e.prev) < 0 && tr(e.next, i, i.next) < 0;
}
function XL(i, e, t, r) {
    let n = i;
    do n.z === null && (n.z = Eg(n.x, n.y, e, t, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
    while (n !== i)
    n.prevZ.nextZ = null, n.prevZ = null, QL(n);
}
function QL(i) {
    let e, t, r, n, s, o, a, l, c = 1;
    do {
        for(t = i, i = null, s = null, o = 0; t;){
            for(o++, r = t, a = 0, e = 0; e < c && (a++, r = r.nextZ, !!r); e++);
            for(l = c; a > 0 || l > 0 && r;)a !== 0 && (l === 0 || !r || t.z <= r.z) ? (n = t, t = t.nextZ, a--) : (n = r, r = r.nextZ, l--), s ? s.nextZ = n : i = n, n.prevZ = s, s = n;
            t = r;
        }
        s.nextZ = null, c *= 2;
    }while (o > 1)
    return i;
}
function Eg(i, e, t, r, n) {
    return i = 32767 * (i - t) * n, e = 32767 * (e - r) * n, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function JL(i) {
    let e = i, t = i;
    do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
    while (e !== i)
    return t;
}
function Pa(i, e, t, r, n, s, o, a) {
    return (n - o) * (e - a) - (i - o) * (s - a) >= 0 && (i - o) * (r - a) - (t - o) * (e - a) >= 0 && (t - o) * (s - a) - (n - o) * (r - a) >= 0;
}
function KL(i, e) {
    return i.next.i !== e.i && i.prev.i !== e.i && !ZL(i, e) && (nh(i, e) && nh(e, i) && $L(i, e) && (tr(i.prev, i, e.prev) || tr(i, e.prev, e)) || td(i, e) && tr(i.prev, i, i.next) > 0 && tr(e.prev, e, e.next) > 0);
}
function tr(i, e, t) {
    return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function td(i, e) {
    return i.x === e.x && i.y === e.y;
}
function Lb(i, e, t, r) {
    let n = nf(tr(i, e, t)), s = nf(tr(i, e, r)), o = nf(tr(t, r, i)), a = nf(tr(t, r, e));
    return !!(n !== s && o !== a || n === 0 && rf(i, t, e) || s === 0 && rf(i, r, e) || o === 0 && rf(t, i, r) || a === 0 && rf(t, e, r));
}
function rf(i, e, t) {
    return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function nf(i) {
    return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function ZL(i, e) {
    let t = i;
    do {
        if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && Lb(t, t.next, i, e)) return !0;
        t = t.next;
    }while (t !== i)
    return !1;
}
function nh(i, e) {
    return tr(i.prev, i, i.next) < 0 ? tr(i, e, i.next) >= 0 && tr(i, i.prev, e) >= 0 : tr(i, e, i.prev) < 0 || tr(i, i.next, e) < 0;
}
function $L(i, e) {
    let t = i, r = !1, n = (i.x + e.x) / 2, s = (i.y + e.y) / 2;
    do t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
    while (t !== i)
    return r;
}
function Ib(i, e) {
    let t = new _g(i.i, i.x, i.y), r = new _g(e.i, e.x, e.y), n = i.next, s = e.prev;
    return i.next = e, e.prev = i, t.next = n, n.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function K0(i, e, t, r) {
    let n = new _g(i, e, t);
    return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function ih(i) {
    i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function _g(i, e, t) {
    this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function e2(i, e, t, r) {
    let n = 0;
    for(let s = e, o = t - r; s < t; s += r)n += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
    return n;
}
var ni = class {
    static area(e) {
        let t = e.length, r = 0;
        for(let n = t - 1, s = 0; s < t; n = s++)r += e[n].x * e[s].y - e[s].x * e[n].y;
        return r * .5;
    }
    static isClockWise(e) {
        return ni.area(e) < 0;
    }
    static triangulateShape(e, t) {
        let r = [], n = [], s = [];
        Z0(e), $0(r, e);
        let o = e.length;
        t.forEach(Z0);
        for(let l = 0; l < t.length; l++)n.push(o), o += t[l].length, $0(r, t[l]);
        let a = UL.triangulate(r, n);
        for(let l6 = 0; l6 < a.length; l6 += 3)s.push(a.slice(l6, l6 + 3));
        return s;
    }
};
function Z0(i) {
    let e = i.length;
    e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function $0(i, e) {
    for(let t = 0; t < e.length; t++)i.push(e[t].x), i.push(e[t].y);
}
var Gs = class extends Le {
    constructor(e = new rn([
        new B(.5, .5),
        new B(-0.5, .5),
        new B(-0.5, -0.5),
        new B(.5, -0.5)
    ]), t = {}){
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [
            e
        ];
        let r = this, n = [], s = [];
        for(let a7 = 0, l7 = e.length; a7 < l7; a7++){
            let c = e[a7];
            o(c);
        }
        this.setAttribute("position", new Ce(n, 3)), this.setAttribute("uv", new Ce(s, 2)), this.computeVertexNormals();
        function o(a) {
            let l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, u = t.depth !== void 0 ? t.depth : 1, f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, d = t.bevelThickness !== void 0 ? t.bevelThickness : .2, p = t.bevelSize !== void 0 ? t.bevelSize : d - .1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3, v = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : t2;
            t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = t.amount);
            let w, b = !1, S, T, A, x;
            v && (w = v.getSpacedPoints(h), b = !0, f = !1, S = v.computeFrenetFrames(h, !1), T = new M, A = new M, x = new M), f || (g = 0, d = 0, p = 0, m = 0);
            let E = a.extractPoints(c), _ = E.shape, C = E.holes;
            if (!ni.isClockWise(_)) {
                _ = _.reverse();
                for(let K = 0, V = C.length; K < V; K++){
                    let Z = C[K];
                    ni.isClockWise(Z) && (C[K] = Z.reverse());
                }
            }
            let N = ni.triangulateShape(_, C), R = _;
            for(let K10 = 0, V8 = C.length; K10 < V8; K10++){
                let Z = C[K10];
                _ = _.concat(Z);
            }
            function k(K, V, Z) {
                return V || console.error("THREE.ExtrudeGeometry: vec does not exist"), V.clone().multiplyScalar(Z).add(K);
            }
            let G = _.length, te = N.length;
            function Q(K, V, Z) {
                let ce, se, pe, ve = K.x - V.x, me = K.y - V.y, Pe = Z.x - K.x, ke = Z.y - K.y, L = ve * ve + me * me, D = ve * ke - me * Pe;
                if (Math.abs(D) > Number.EPSILON) {
                    let re = Math.sqrt(L), ye = Math.sqrt(Pe * Pe + ke * ke), Se = V.x - me / re, Ie = V.y + ve / re, Fe = Z.x - ke / ye, ue = Z.y + Pe / ye, rt = ((Fe - Se) * ke - (ue - Ie) * Pe) / (ve * ke - me * Pe);
                    ce = Se + ve * rt - K.x, se = Ie + me * rt - K.y;
                    let st = ce * ce + se * se;
                    if (st <= 2) return new B(ce, se);
                    pe = Math.sqrt(st / 2);
                } else {
                    let re = !1;
                    ve > Number.EPSILON ? Pe > Number.EPSILON && (re = !0) : ve < -Number.EPSILON ? Pe < -Number.EPSILON && (re = !0) : Math.sign(me) === Math.sign(ke) && (re = !0), re ? (ce = -me, se = ve, pe = Math.sqrt(L)) : (ce = ve, se = me, pe = Math.sqrt(L / 2));
                }
                return new B(ce / pe, se / pe);
            }
            let Y = [];
            for(let K4 = 0, V5 = R.length, Z4 = V5 - 1, ce1 = K4 + 1; K4 < V5; K4++, Z4++, ce1++)Z4 === V5 && (Z4 = 0), ce1 === V5 && (ce1 = 0), Y[K4] = Q(R[K4], R[Z4], R[ce1]);
            let F = [], z, O = Y.concat();
            for(let K5 = 0, V6 = C.length; K5 < V6; K5++){
                let Z = C[K5];
                z = [];
                for(let ce = 0, se = Z.length, pe = se - 1, ve = ce + 1; ce < se; ce++, pe++, ve++)pe === se && (pe = 0), ve === se && (ve = 0), z[ce] = Q(Z[ce], Z[pe], Z[ve]);
                F.push(z), O = O.concat(z);
            }
            for(let K6 = 0; K6 < g; K6++){
                let V = K6 / g, Z = d * Math.cos(V * Math.PI / 2), ce = p * Math.sin(V * Math.PI / 2) + m;
                for(let se = 0, pe = R.length; se < pe; se++){
                    let ve = k(R[se], Y[se], ce);
                    ge(ve.x, ve.y, -Z);
                }
                for(let se1 = 0, pe1 = C.length; se1 < pe1; se1++){
                    let ve = C[se1];
                    z = F[se1];
                    for(let me = 0, Pe = ve.length; me < Pe; me++){
                        let ke = k(ve[me], z[me], ce);
                        ge(ke.x, ke.y, -Z);
                    }
                }
            }
            let j = p + m;
            for(let K7 = 0; K7 < G; K7++){
                let V = f ? k(_[K7], O[K7], j) : _[K7];
                b ? (A.copy(S.normals[0]).multiplyScalar(V.x), T.copy(S.binormals[0]).multiplyScalar(V.y), x.copy(w[0]).add(A).add(T), ge(x.x, x.y, x.z)) : ge(V.x, V.y, 0);
            }
            for(let K8 = 1; K8 <= h; K8++)for(let V7 = 0; V7 < G; V7++){
                let Z = f ? k(_[V7], O[V7], j) : _[V7];
                b ? (A.copy(S.normals[K8]).multiplyScalar(Z.x), T.copy(S.binormals[K8]).multiplyScalar(Z.y), x.copy(w[K8]).add(A).add(T), ge(x.x, x.y, x.z)) : ge(Z.x, Z.y, u / h * K8);
            }
            for(let K9 = g - 1; K9 >= 0; K9--){
                let V = K9 / g, Z = d * Math.cos(V * Math.PI / 2), ce = p * Math.sin(V * Math.PI / 2) + m;
                for(let se = 0, pe = R.length; se < pe; se++){
                    let ve = k(R[se], Y[se], ce);
                    ge(ve.x, ve.y, u + Z);
                }
                for(let se2 = 0, pe2 = C.length; se2 < pe2; se2++){
                    let ve = C[se2];
                    z = F[se2];
                    for(let me = 0, Pe = ve.length; me < Pe; me++){
                        let ke = k(ve[me], z[me], ce);
                        b ? ge(ke.x, ke.y + w[h - 1].y, w[h - 1].x + Z) : ge(ke.x, ke.y, u + Z);
                    }
                }
            }
            q(), J();
            function q() {
                let K = n.length / 3;
                if (f) {
                    let V = 0, Z = G * V;
                    for(let ce = 0; ce < te; ce++){
                        let se = N[ce];
                        oe(se[2] + Z, se[1] + Z, se[0] + Z);
                    }
                    V = h + g * 2, Z = G * V;
                    for(let ce2 = 0; ce2 < te; ce2++){
                        let se = N[ce2];
                        oe(se[0] + Z, se[1] + Z, se[2] + Z);
                    }
                } else {
                    for(let V = 0; V < te; V++){
                        let Z = N[V];
                        oe(Z[2], Z[1], Z[0]);
                    }
                    for(let V9 = 0; V9 < te; V9++){
                        let Z = N[V9];
                        oe(Z[0] + G * h, Z[1] + G * h, Z[2] + G * h);
                    }
                }
                r.addGroup(K, n.length / 3 - K, 0);
            }
            function J() {
                let K = n.length / 3, V = 0;
                W(R, V), V += R.length;
                for(let Z = 0, ce = C.length; Z < ce; Z++){
                    let se = C[Z];
                    W(se, V), V += se.length;
                }
                r.addGroup(K, n.length / 3 - K, 1);
            }
            function W(K, V) {
                let Z = K.length;
                for(; --Z >= 0;){
                    let ce = Z, se = Z - 1;
                    se < 0 && (se = K.length - 1);
                    for(let pe = 0, ve = h + g * 2; pe < ve; pe++){
                        let me = G * pe, Pe = G * (pe + 1), ke = V + ce + me, L = V + se + me, D = V + se + Pe, re = V + ce + Pe;
                        le(ke, L, D, re);
                    }
                }
            }
            function ge(K, V, Z) {
                l.push(K), l.push(V), l.push(Z);
            }
            function oe(K, V, Z) {
                H(K), H(V), H(Z);
                let ce = n.length / 3, se = y.generateTopUV(r, n, ce - 3, ce - 2, ce - 1);
                he(se[0]), he(se[1]), he(se[2]);
            }
            function le(K, V, Z, ce) {
                H(K), H(V), H(ce), H(V), H(Z), H(ce);
                let se = n.length / 3, pe = y.generateSideWallUV(r, n, se - 6, se - 3, se - 2, se - 1);
                he(pe[0]), he(pe[1]), he(pe[3]), he(pe[1]), he(pe[2]), he(pe[3]);
            }
            function H(K) {
                n.push(l[K * 3 + 0]), n.push(l[K * 3 + 1]), n.push(l[K * 3 + 2]);
            }
            function he(K) {
                s.push(K.x), s.push(K.y);
            }
        }
    }
    toJSON() {
        let e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
        return r2(t, r, e);
    }
    static fromJSON(e, t) {
        let r = [];
        for(let s = 0, o = e.shapes.length; s < o; s++){
            let a = t[e.shapes[s]];
            r.push(a);
        }
        let n = e.options.extrudePath;
        return n !== void 0 && (e.options.extrudePath = new Db[n.type]().fromJSON(n)), new Gs(r, e.options);
    }
}, t2 = {
    generateTopUV: function(i, e, t, r, n) {
        let s = e[t * 3], o = e[t * 3 + 1], a = e[r * 3], l = e[r * 3 + 1], c = e[n * 3], h = e[n * 3 + 1];
        return [
            new B(s, o),
            new B(a, l),
            new B(c, h)
        ];
    },
    generateSideWallUV: function(i, e, t, r, n, s) {
        let o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[r * 3], h = e[r * 3 + 1], u = e[r * 3 + 2], f = e[n * 3], d = e[n * 3 + 1], p = e[n * 3 + 2], m = e[s * 3], g = e[s * 3 + 1], v = e[s * 3 + 2];
        return Math.abs(a - h) < Math.abs(o - c) ? [
            new B(o, 1 - l),
            new B(c, 1 - u),
            new B(f, 1 - p),
            new B(m, 1 - v)
        ] : [
            new B(a, 1 - l),
            new B(h, 1 - u),
            new B(d, 1 - p),
            new B(g, 1 - v)
        ];
    }
};
function r2(i, e, t) {
    if (t.shapes = [], Array.isArray(i)) for(let r = 0, n = i.length; r < n; r++){
        let s = i[r];
        t.shapes.push(s.uuid);
    }
    else t.shapes.push(i.uuid);
    return e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
var Va = class extends Ga {
    constructor(e = 1, t = 0){
        let r = (1 + Math.sqrt(5)) / 2, n = [
            -1,
            r,
            0,
            1,
            r,
            0,
            -1,
            -r,
            0,
            1,
            -r,
            0,
            0,
            -1,
            r,
            0,
            1,
            r,
            0,
            -1,
            -r,
            0,
            1,
            -r,
            r,
            0,
            -1,
            r,
            0,
            1,
            -r,
            0,
            -1,
            -r,
            0,
            1
        ], s = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
        ];
        super(n, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        };
    }
    static fromJSON(e) {
        return new Va(e.radius, e.detail);
    }
};
var Io = class extends Le {
    constructor(e = new rn([
        new B(0, .5),
        new B(-0.5, -0.5),
        new B(.5, -0.5)
    ]), t = 12){
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        };
        let r = [], n = [], s = [], o = [], a = 0, l = 0;
        if (Array.isArray(e) === !1) c(e);
        else for(let h5 = 0; h5 < e.length; h5++)c(e[h5]), this.addGroup(a, l, h5), a += l, l = 0;
        this.setIndex(r), this.setAttribute("position", new Ce(n, 3)), this.setAttribute("normal", new Ce(s, 3)), this.setAttribute("uv", new Ce(o, 2));
        function c(h) {
            let u = n.length / 3, f = h.extractPoints(t), d = f.shape, p = f.holes;
            ni.isClockWise(d) === !1 && (d = d.reverse());
            for(let g = 0, v = p.length; g < v; g++){
                let y = p[g];
                ni.isClockWise(y) === !0 && (p[g] = y.reverse());
            }
            let m = ni.triangulateShape(d, p);
            for(let g4 = 0, v5 = p.length; g4 < v5; g4++){
                let y = p[g4];
                d = d.concat(y);
            }
            for(let g5 = 0, v6 = d.length; g5 < v6; g5++){
                let y = d[g5];
                n.push(y.x, y.y, 0), s.push(0, 0, 1), o.push(y.x, y.y);
            }
            for(let g6 = 0, v7 = m.length; g6 < v7; g6++){
                let y = m[g6], w = y[0] + u, b = y[1] + u, S = y[2] + u;
                r.push(w, b, S), l += 3;
            }
        }
    }
    toJSON() {
        let e = super.toJSON(), t = this.parameters.shapes;
        return n2(t, e);
    }
    static fromJSON(e, t) {
        let r = [];
        for(let n = 0, s = e.shapes.length; n < s; n++){
            let o = t[e.shapes[n]];
            r.push(o);
        }
        return new Io(r, e.curveSegments);
    }
};
function n2(i, e) {
    if (e.shapes = [], Array.isArray(i)) for(let t = 0, r = i.length; t < r; t++){
        let n = i[t];
        e.shapes.push(n.uuid);
    }
    else e.shapes.push(i.uuid);
    return e;
}
var Ro = class extends Le {
    constructor(e = 1, t = 32, r = 16, n = 0, s = Math.PI * 2, o = 0, a = Math.PI){
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
        let l = Math.min(o + a, Math.PI), c = 0, h = [], u = new M, f = new M, d = [], p = [], m = [], g = [];
        for(let v = 0; v <= r; v++){
            let y = [], w = v / r, b = 0;
            v == 0 && o == 0 ? b = .5 / t : v == r && l == Math.PI && (b = -0.5 / t);
            for(let S = 0; S <= t; S++){
                let T = S / t;
                u.x = -e * Math.cos(n + T * s) * Math.sin(o + w * a), u.y = e * Math.cos(o + w * a), u.z = e * Math.sin(n + T * s) * Math.sin(o + w * a), p.push(u.x, u.y, u.z), f.copy(u).normalize(), m.push(f.x, f.y, f.z), g.push(T + b, 1 - w), y.push(c++);
            }
            h.push(y);
        }
        for(let v8 = 0; v8 < r; v8++)for(let y = 0; y < t; y++){
            let w = h[v8][y + 1], b = h[v8][y], S = h[v8 + 1][y], T = h[v8 + 1][y + 1];
            (v8 !== 0 || o > 0) && d.push(w, b, T), (v8 !== r - 1 || l < Math.PI) && d.push(b, S, T);
        }
        this.setIndex(d), this.setAttribute("position", new Ce(p, 3)), this.setAttribute("normal", new Ce(m, 3)), this.setAttribute("uv", new Ce(g, 2));
    }
    static fromJSON(e) {
        return new Ro(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
    }
};
var Ha = class extends Le {
    constructor(e = 1, t = .4, r = 64, n = 8, s = 2, o = 3){
        super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: n,
            p: s,
            q: o
        }, r = Math.floor(r), n = Math.floor(n);
        let a = [], l = [], c = [], h = [], u = new M, f = new M, d = new M, p = new M, m = new M, g = new M, v = new M;
        for(let w5 = 0; w5 <= r; ++w5){
            let b = w5 / r * s * Math.PI * 2;
            y(b, s, o, e, d), y(b + .01, s, o, e, p), g.subVectors(p, d), v.addVectors(p, d), m.crossVectors(g, v), v.crossVectors(m, g), m.normalize(), v.normalize();
            for(let S = 0; S <= n; ++S){
                let T = S / n * Math.PI * 2, A = -t * Math.cos(T), x = t * Math.sin(T);
                u.x = d.x + (A * v.x + x * m.x), u.y = d.y + (A * v.y + x * m.y), u.z = d.z + (A * v.z + x * m.z), l.push(u.x, u.y, u.z), f.subVectors(u, d).normalize(), c.push(f.x, f.y, f.z), h.push(w5 / r), h.push(S / n);
            }
        }
        for(let w4 = 1; w4 <= r; w4++)for(let b6 = 1; b6 <= n; b6++){
            let S = (n + 1) * (w4 - 1) + (b6 - 1), T = (n + 1) * w4 + (b6 - 1), A = (n + 1) * w4 + b6, x = (n + 1) * (w4 - 1) + b6;
            a.push(S, T, x), a.push(T, A, x);
        }
        this.setIndex(a), this.setAttribute("position", new Ce(l, 3)), this.setAttribute("normal", new Ce(c, 3)), this.setAttribute("uv", new Ce(h, 2));
        function y(w, b, S, T, A) {
            let x = Math.cos(w), E = Math.sin(w), _ = S / b * w, C = Math.cos(_);
            A.x = T * (2 + C) * .5 * x, A.y = T * (2 + C) * E * .5, A.z = T * Math.sin(_) * .5;
        }
    }
    static fromJSON(e) {
        return new Ha(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
    }
};
var _f = class extends ur {
    constructor(e){
        super(), this.type = "ShadowMaterial", this.color = new be(0), this.transparent = !0, this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
    }
};
_f.prototype.isShadowMaterial = !0;
var Cf = class extends Mt {
    constructor(e){
        super(e), this.type = "RawShaderMaterial";
    }
};
Cf.prototype.isRawShaderMaterial = !0;
var sh = class extends ur {
    constructor(e){
        super(), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new be(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new be(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xa, this.normalScale = new B(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
};
sh.prototype.isMeshStandardMaterial = !0;
var Df = class extends sh {
    constructor(e){
        super(), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new B(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return xr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t);
            }
        }), this.sheenColor = new be(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new be(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new be(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e);
    }
    get sheen() {
        return this._sheen;
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
    }
};
Df.prototype.isMeshPhysicalMaterial = !0;
var Pf = class extends ur {
    constructor(e){
        super(), this.type = "MeshPhongMaterial", this.color = new be(16777215), this.specular = new be(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new be(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xa, this.normalScale = new B(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $f, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
};
Pf.prototype.isMeshPhongMaterial = !0;
var Lf = class extends ur {
    constructor(e){
        super(), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new be(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new be(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xa, this.normalScale = new B(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
};
Lf.prototype.isMeshToonMaterial = !0;
var If = class extends ur {
    constructor(e){
        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xa, this.normalScale = new B(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
    }
};
If.prototype.isMeshNormalMaterial = !0;
var Rf = class extends ur {
    constructor(e){
        super(), this.type = "MeshLambertMaterial", this.color = new be(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new be(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $f, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
};
Rf.prototype.isMeshLambertMaterial = !0;
var Bf = class extends ur {
    constructor(e){
        super(), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new be(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xa, this.normalScale = new B(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
};
Bf.prototype.isMeshMatcapMaterial = !0;
var Nf = class extends kr {
    constructor(e){
        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
    }
    copy(e) {
        return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
    }
};
Nf.prototype.isLineDashedMaterial = !0;
var i2 = {
    ShadowMaterial: _f,
    SpriteMaterial: Zc,
    RawShaderMaterial: Cf,
    ShaderMaterial: Mt,
    PointsMaterial: $c,
    MeshPhysicalMaterial: Df,
    MeshStandardMaterial: sh,
    MeshPhongMaterial: Pf,
    MeshToonMaterial: Lf,
    MeshNormalMaterial: If,
    MeshLambertMaterial: Rf,
    MeshDepthMaterial: Qc,
    MeshDistanceMaterial: Jc,
    MeshBasicMaterial: zn,
    MeshMatcapMaterial: Bf,
    LineDashedMaterial: Nf,
    LineBasicMaterial: kr,
    Material: ur
};
ur.fromType = function(i) {
    return new i2[i];
};
var Qt = {
    arraySlice: function(i, e, t) {
        return Qt.isTypedArray(i) ? new i.constructor(i.subarray(e, t !== void 0 ? t : i.length)) : i.slice(e, t);
    },
    convertArray: function(i, e, t) {
        return !i || !t && i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
    },
    isTypedArray: function(i) {
        return ArrayBuffer.isView(i) && !(i instanceof DataView);
    },
    getKeyframeOrder: function(i) {
        function e(n, s) {
            return i[n] - i[s];
        }
        let t = i.length, r = new Array(t);
        for(let n5 = 0; n5 !== t; ++n5)r[n5] = n5;
        return r.sort(e), r;
    },
    sortedArray: function(i, e, t) {
        let r = i.length, n = new i.constructor(r);
        for(let s = 0, o = 0; o !== r; ++s){
            let a = t[s] * e;
            for(let l = 0; l !== e; ++l)n[o++] = i[a + l];
        }
        return n;
    },
    flattenJSON: function(i, e, t, r) {
        let n = 1, s = i[0];
        for(; s !== void 0 && s[r] === void 0;)s = i[n++];
        if (s === void 0) return;
        let o = s[r];
        if (o !== void 0) {
            if (Array.isArray(o)) do o = s[r], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = i[n++];
            while (s !== void 0)
            else if (o.toArray !== void 0) do o = s[r], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = i[n++];
            while (s !== void 0)
            else do o = s[r], o !== void 0 && (e.push(s.time), t.push(o)), s = i[n++];
            while (s !== void 0)
        }
    },
    subclip: function(i, e, t, r, n = 30) {
        let s = i.clone();
        s.name = e;
        let o = [];
        for(let l = 0; l < s.tracks.length; ++l){
            let c = s.tracks[l], h = c.getValueSize(), u = [], f = [];
            for(let d = 0; d < c.times.length; ++d){
                let p = c.times[d] * n;
                if (!(p < t || p >= r)) {
                    u.push(c.times[d]);
                    for(let m = 0; m < h; ++m)f.push(c.values[d * h + m]);
                }
            }
            u.length !== 0 && (c.times = Qt.convertArray(u, c.times.constructor), c.values = Qt.convertArray(f, c.values.constructor), o.push(c));
        }
        s.tracks = o;
        let a = 1 / 0;
        for(let l8 = 0; l8 < s.tracks.length; ++l8)a > s.tracks[l8].times[0] && (a = s.tracks[l8].times[0]);
        for(let l9 = 0; l9 < s.tracks.length; ++l9)s.tracks[l9].shift(-1 * a);
        return s.resetDuration(), s;
    },
    makeClipAdditive: function(i, e = 0, t = i, r = 30) {
        r <= 0 && (r = 30);
        let n = t.tracks.length, s = e / r;
        for(let o = 0; o < n; ++o){
            let a = t.tracks[o], l = a.ValueTypeName;
            if (l === "bool" || l === "string") continue;
            let c = i.tracks.find(function(v) {
                return v.name === a.name && v.ValueTypeName === l;
            });
            if (c === void 0) continue;
            let h = 0, u = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = u / 3);
            let f = 0, d = c.getValueSize();
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = d / 3);
            let p = a.times.length - 1, m;
            if (s <= a.times[0]) {
                let v = h, y = u - h;
                m = Qt.arraySlice(a.values, v, y);
            } else if (s >= a.times[p]) {
                let v = p * u + h, y = v + u - h;
                m = Qt.arraySlice(a.values, v, y);
            } else {
                let v = a.createInterpolant(), y = h, w = u - h;
                v.evaluate(s), m = Qt.arraySlice(v.resultBuffer, y, w);
            }
            l === "quaternion" && new zt().fromArray(m).normalize().conjugate().toArray(m);
            let g = c.times.length;
            for(let v9 = 0; v9 < g; ++v9){
                let y = v9 * d + f;
                if (l === "quaternion") zt.multiplyQuaternionsFlat(c.values, y, m, 0, c.values, y);
                else {
                    let w = d - f * 2;
                    for(let b = 0; b < w; ++b)c.values[y + b] -= m[b];
                }
            }
        }
        return i.blendMode = gb, i;
    }
}, Ci = class {
    constructor(e, t, r, n){
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(e) {
        let t = this.parameterPositions, r = this._cachedIndex, n = t[r], s = t[r - 1];
        e: {
            t: {
                let o;
                r: {
                    n: if (!(e < n)) {
                        for(let a = r + 2;;){
                            if (n === void 0) {
                                if (e < s) break n;
                                return r = t.length, this._cachedIndex = r, this.afterEnd_(r - 1, e, s);
                            }
                            if (r === a) break;
                            if (s = n, n = t[++r], e < n) break t;
                        }
                        o = t.length;
                        break r;
                    }
                    if (!(e >= s)) {
                        let a = t[1];
                        e < a && (r = 2, s = a);
                        for(let l = r - 2;;){
                            if (s === void 0) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (r === l) break;
                            if (n = s, s = t[--r - 1], e >= s) break t;
                        }
                        o = r, r = 0;
                        break r;
                    }
                    break e;
                }
                for(; r < o;){
                    let a = r + o >>> 1;
                    e < t[a] ? o = a : r = a + 1;
                }
                if (n = t[r], s = t[r - 1], s === void 0) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                if (n === void 0) return r = t.length, this._cachedIndex = r, this.afterEnd_(r - 1, s, e);
            }
            this._cachedIndex = r, this.intervalChanged_(r, s, n);
        }
        return this.interpolate_(r, s, e, n);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
        let t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, s = e * n;
        for(let o = 0; o !== n; ++o)t[o] = r[s + o];
        return t;
    }
    interpolate_() {
        throw new Error("call to abstract method");
    }
    intervalChanged_() {}
};
Ci.prototype.beforeStart_ = Ci.prototype.copySampleValue_;
Ci.prototype.afterEnd_ = Ci.prototype.copySampleValue_;
var Cg = class extends Ci {
    constructor(e, t, r, n){
        super(e, t, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: _a,
            endingEnd: _a
        };
    }
    intervalChanged_(e, t, r) {
        let n = this.parameterPositions, s = e - 2, o = e + 1, a = n[s], l = n[o];
        if (a === void 0) switch(this.getSettings_().endingStart){
            case Ca:
                s = e, a = 2 * t - r;
                break;
            case df:
                s = n.length - 2, a = t + n[s] - n[s + 1];
                break;
            default:
                s = e, a = r;
        }
        if (l === void 0) switch(this.getSettings_().endingEnd){
            case Ca:
                o = e, l = 2 * r - t;
                break;
            case df:
                o = 1, l = r + n[1] - n[0];
                break;
            default:
                o = e - 1, l = t;
        }
        let c = (r - t) * .5, h = this.valueSize;
        this._weightPrev = c / (t - a), this._weightNext = c / (l - r), this._offsetPrev = s * h, this._offsetNext = o * h;
    }
    interpolate_(e, t, r, n) {
        let s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = this._offsetPrev, u = this._offsetNext, f = this._weightPrev, d = this._weightNext, p = (r - t) / (n - t), m = p * p, g = m * p, v = -f * g + 2 * f * m - f * p, y = (1 + f) * g + (-1.5 - 2 * f) * m + (-0.5 + f) * p + 1, w = (-1 - d) * g + (1.5 + d) * m + .5 * p, b = d * g - d * m;
        for(let S = 0; S !== a; ++S)s[S] = v * o[h + S] + y * o[c + S] + w * o[l + S] + b * o[u + S];
        return s;
    }
}, Of = class extends Ci {
    constructor(e, t, r, n){
        super(e, t, r, n);
    }
    interpolate_(e, t, r, n) {
        let s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = (r - t) / (n - t), u = 1 - h;
        for(let f = 0; f !== a; ++f)s[f] = o[c + f] * u + o[l + f] * h;
        return s;
    }
}, Dg = class extends Ci {
    constructor(e, t, r, n){
        super(e, t, r, n);
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1);
    }
}, Vn = class {
    constructor(e, t, r, n){
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Qt.convertArray(t, this.TimeBufferType), this.values = Qt.convertArray(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
    }
    static toJSON(e) {
        let t = e.constructor, r;
        if (t.toJSON !== this.toJSON) r = t.toJSON(e);
        else {
            r = {
                name: e.name,
                times: Qt.convertArray(e.times, Array),
                values: Qt.convertArray(e.values, Array)
            };
            let n = e.getInterpolation();
            n !== e.DefaultInterpolation && (r.interpolation = n);
        }
        return r.type = e.ValueTypeName, r;
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new Dg(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
        return new Of(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Cg(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
        let t;
        switch(e){
            case uf:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case ff:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case wm:
                t = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (t === void 0) {
            let r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
                if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(r);
            }
            return console.warn("THREE.KeyframeTrack:", r), this;
        }
        return this.createInterpolant = t, this;
    }
    getInterpolation() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return uf;
            case this.InterpolantFactoryMethodLinear:
                return ff;
            case this.InterpolantFactoryMethodSmooth:
                return wm;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    shift(e) {
        if (e !== 0) {
            let t = this.times;
            for(let r = 0, n = t.length; r !== n; ++r)t[r] += e;
        }
        return this;
    }
    scale(e) {
        if (e !== 1) {
            let t = this.times;
            for(let r = 0, n = t.length; r !== n; ++r)t[r] *= e;
        }
        return this;
    }
    trim(e, t) {
        let r = this.times, n = r.length, s = 0, o = n - 1;
        for(; s !== n && r[s] < e;)++s;
        for(; o !== -1 && r[o] > t;)--o;
        if (++o, s !== 0 || o !== n) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            let a = this.getValueSize();
            this.times = Qt.arraySlice(r, s, o), this.values = Qt.arraySlice(this.values, s * a, o * a);
        }
        return this;
    }
    validate() {
        let e = !0, t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        let r = this.times, n = this.values, s = r.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let o = null;
        for(let a = 0; a !== s; a++){
            let l = r[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
                break;
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
                break;
            }
            o = l;
        }
        if (n !== void 0 && Qt.isTypedArray(n)) for(let a8 = 0, l = n.length; a8 !== l; ++a8){
            let c = n[a8];
            if (isNaN(c)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a8, c), e = !1;
                break;
            }
        }
        return e;
    }
    optimize() {
        let e = Qt.arraySlice(this.times), t = Qt.arraySlice(this.values), r = this.getValueSize(), n = this.getInterpolation() === wm, s = e.length - 1, o = 1;
        for(let a = 1; a < s; ++a){
            let l = !1, c = e[a], h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0])) {
                if (n) l = !0;
                else {
                    let u = a * r, f = u - r, d = u + r;
                    for(let p = 0; p !== r; ++p){
                        let m = t[u + p];
                        if (m !== t[f + p] || m !== t[d + p]) {
                            l = !0;
                            break;
                        }
                    }
                }
            }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    let u = a * r, f = o * r;
                    for(let d = 0; d !== r; ++d)t[f + d] = t[u + d];
                }
                ++o;
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for(let a = s * r, l = o * r, c = 0; c !== r; ++c)t[l + c] = t[a + c];
            ++o;
        }
        return o !== e.length ? (this.times = Qt.arraySlice(e, 0, o), this.values = Qt.arraySlice(t, 0, o * r)) : (this.times = e, this.values = t), this;
    }
    clone() {
        let e = Qt.arraySlice(this.times, 0), t = Qt.arraySlice(this.values, 0), r = this.constructor, n = new r(this.name, e, t);
        return n.createInterpolant = this.createInterpolant, n;
    }
};
Vn.prototype.TimeBufferType = Float32Array;
Vn.prototype.ValueBufferType = Float32Array;
Vn.prototype.DefaultInterpolation = ff;
var ks = class extends Vn {
};
ks.prototype.ValueTypeName = "bool";
ks.prototype.ValueBufferType = Array;
ks.prototype.DefaultInterpolation = uf;
ks.prototype.InterpolantFactoryMethodLinear = void 0;
ks.prototype.InterpolantFactoryMethodSmooth = void 0;
var Ff = class extends Vn {
};
Ff.prototype.ValueTypeName = "color";
var Wa = class extends Vn {
};
Wa.prototype.ValueTypeName = "number";
var Pg = class extends Ci {
    constructor(e, t, r, n){
        super(e, t, r, n);
    }
    interpolate_(e, t, r, n) {
        let s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (r - t) / (n - t), c = e * a;
        for(let h = c + a; c !== h; c += 4)zt.slerpFlat(s, 0, o, c - a, o, c, l);
        return s;
    }
}, Bo = class extends Vn {
    InterpolantFactoryMethodLinear(e) {
        return new Pg(this.times, this.values, this.getValueSize(), e);
    }
};
Bo.prototype.ValueTypeName = "quaternion";
Bo.prototype.DefaultInterpolation = ff;
Bo.prototype.InterpolantFactoryMethodSmooth = void 0;
var Vs = class extends Vn {
};
Vs.prototype.ValueTypeName = "string";
Vs.prototype.ValueBufferType = Array;
Vs.prototype.DefaultInterpolation = uf;
Vs.prototype.InterpolantFactoryMethodLinear = void 0;
Vs.prototype.InterpolantFactoryMethodSmooth = void 0;
var ja = class extends Vn {
};
ja.prototype.ValueTypeName = "vector";
var Uf = class {
    constructor(e, t = -1, r, n = $g){
        this.name = e, this.tracks = r, this.duration = t, this.blendMode = n, this.uuid = Un(), this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
        let t = [], r = e.tracks, n = 1 / (e.fps || 1);
        for(let o = 0, a = r.length; o !== a; ++o)t.push(o2(r[o]).scale(n));
        let s = new this(e.name, e.duration, t, e.blendMode);
        return s.uuid = e.uuid, s;
    }
    static toJSON(e) {
        let t = [], r = e.tracks, n = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for(let s = 0, o = r.length; s !== o; ++s)t.push(Vn.toJSON(r[s]));
        return n;
    }
    static CreateFromMorphTargetSequence(e, t, r, n) {
        let s = t.length, o = [];
        for(let a = 0; a < s; a++){
            let l = [], c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            let h = Qt.getKeyframeOrder(l);
            l = Qt.sortedArray(l, 1, h), c = Qt.sortedArray(c, 1, h), !n && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new Wa(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / r));
        }
        return new this(e, -1, o);
    }
    static findByName(e, t) {
        let r = e;
        if (!Array.isArray(e)) {
            let n = e;
            r = n.geometry && n.geometry.animations || n.animations;
        }
        for(let n = 0; n < r.length; n++)if (r[n].name === t) return r[n];
        return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, r) {
        let n = {}, s = /^([\w-]*?)([\d]+)$/;
        for(let a = 0, l = e.length; a < l; a++){
            let c = e[a], h = c.name.match(s);
            if (h && h.length > 1) {
                let u = h[1], f = n[u];
                f || (n[u] = f = []), f.push(c);
            }
        }
        let o = [];
        for(let a9 in n)o.push(this.CreateFromMorphTargetSequence(a9, n[a9], t, r));
        return o;
    }
    static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        let r = function(u, f, d, p, m) {
            if (d.length !== 0) {
                let g = [], v = [];
                Qt.flattenJSON(d, g, v, p), g.length !== 0 && m.push(new u(f, g, v));
            }
        }, n = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode, l = e.length || -1, c = e.hierarchy || [];
        for(let u4 = 0; u4 < c.length; u4++){
            let f = c[u4].keys;
            if (!(!f || f.length === 0)) {
                if (f[0].morphTargets) {
                    let d = {}, p;
                    for(p = 0; p < f.length; p++)if (f[p].morphTargets) for(let m = 0; m < f[p].morphTargets.length; m++)d[f[p].morphTargets[m]] = -1;
                    for(let m4 in d){
                        let g = [], v = [];
                        for(let y = 0; y !== f[p].morphTargets.length; ++y){
                            let w = f[p];
                            g.push(w.time), v.push(w.morphTarget === m4 ? 1 : 0);
                        }
                        n.push(new Wa(".morphTargetInfluence[" + m4 + "]", g, v));
                    }
                    l = d.length * o;
                } else {
                    let d = ".bones[" + t[u4].name + "]";
                    r(ja, d + ".position", f, "pos", n), r(Bo, d + ".quaternion", f, "rot", n), r(ja, d + ".scale", f, "scl", n);
                }
            }
        }
        return n.length === 0 ? null : new this(s, l, n, a);
    }
    resetDuration() {
        let e = this.tracks, t = 0;
        for(let r = 0, n = e.length; r !== n; ++r){
            let s = this.tracks[r];
            t = Math.max(t, s.times[s.times.length - 1]);
        }
        return this.duration = t, this;
    }
    trim() {
        for(let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration);
        return this;
    }
    validate() {
        let e = !0;
        for(let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate();
        return e;
    }
    optimize() {
        for(let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize();
        return this;
    }
    clone() {
        let e = [];
        for(let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
};
function s2(i) {
    switch(i.toLowerCase()){
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Wa;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return ja;
        case "color":
            return Ff;
        case "quaternion":
            return Bo;
        case "bool":
        case "boolean":
            return ks;
        case "string":
            return Vs;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function o2(i) {
    if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    let e = s2(i.type);
    if (i.times === void 0) {
        let t = [], r = [];
        Qt.flattenJSON(i.keys, t, r, "value"), i.times = t, i.values = r;
    }
    return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
var qa = {
    enabled: !1,
    files: {},
    add: function(i, e) {
        this.enabled !== !1 && (this.files[i] = e);
    },
    get: function(i) {
        if (this.enabled !== !1) return this.files[i];
    },
    remove: function(i) {
        delete this.files[i];
    },
    clear: function() {
        this.files = {};
    }
}, No = class {
    constructor(e, t, r){
        let n = this, s = !1, o = 0, a = 0, l, c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(h) {
            a++, s === !1 && n.onStart !== void 0 && n.onStart(h, o, a), s = !0;
        }, this.itemEnd = function(h) {
            o++, n.onProgress !== void 0 && n.onProgress(h, o, a), o === a && (s = !1, n.onLoad !== void 0 && n.onLoad());
        }, this.itemError = function(h) {
            n.onError !== void 0 && n.onError(h);
        }, this.resolveURL = function(h) {
            return l ? l(h) : h;
        }, this.setURLModifier = function(h) {
            return l = h, this;
        }, this.addHandler = function(h, u) {
            return c.push(h, u), this;
        }, this.removeHandler = function(h) {
            let u = c.indexOf(h);
            return u !== -1 && c.splice(u, 2), this;
        }, this.getHandler = function(h) {
            for(let u = 0, f = c.length; u < f; u += 2){
                let d = c[u], p = c[u + 1];
                if (d.global && (d.lastIndex = 0), d.test(h)) return p;
            }
            return null;
        };
    }
}, a2 = new No, cn = class {
    constructor(e){
        this.manager = e !== void 0 ? e : a2, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {}
    loadAsync(e, t) {
        let r = this;
        return new Promise(function(n, s) {
            r.load(e, n, t, s);
        });
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e, this;
    }
    setWithCredentials(e) {
        return this.withCredentials = e, this;
    }
    setPath(e) {
        return this.path = e, this;
    }
    setResourcePath(e) {
        return this.resourcePath = e, this;
    }
    setRequestHeader(e) {
        return this.requestHeader = e, this;
    }
}, $i = {}, as = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        let s = qa.get(e);
        if (s !== void 0) return this.manager.itemStart(e), setTimeout(()=>{
            t && t(s), this.manager.itemEnd(e);
        }, 0), s;
        if ($i[e] !== void 0) {
            $i[e].push({
                onLoad: t,
                onProgress: r,
                onError: n
            });
            return;
        }
        $i[e] = [], $i[e].push({
            onLoad: t,
            onProgress: r,
            onError: n
        });
        let o = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        }), a = this.mimeType, l = this.responseType;
        fetch(o).then((c)=>{
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                let h = $i[e], u = c.body.getReader(), f = c.headers.get("Content-Length"), d = f ? parseInt(f) : 0, p = d !== 0, m = 0, g = new ReadableStream({
                    start (v) {
                        y();
                        function y() {
                            u.read().then(({ done: w , value: b  })=>{
                                if (w) v.close();
                                else {
                                    m += b.byteLength;
                                    let S = new ProgressEvent("progress", {
                                        lengthComputable: p,
                                        loaded: m,
                                        total: d
                                    });
                                    for(let T = 0, A = h.length; T < A; T++){
                                        let x = h[T];
                                        x.onProgress && x.onProgress(S);
                                    }
                                    v.enqueue(b), y();
                                }
                            });
                        }
                    }
                });
                return new Response(g);
            } else throw Error(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`);
        }).then((c)=>{
            switch(l){
                case "arraybuffer":
                    return c.arrayBuffer();
                case "blob":
                    return c.blob();
                case "document":
                    return c.text().then((h)=>new DOMParser().parseFromString(h, a)
                    );
                case "json":
                    return c.json();
                default:
                    if (a === void 0) return c.text();
                    {
                        let u = /charset="?([^;"\s]*)"?/i.exec(a), f = u && u[1] ? u[1].toLowerCase() : void 0, d = new TextDecoder(f);
                        return c.arrayBuffer().then((p)=>d.decode(p)
                        );
                    }
            }
        }).then((c)=>{
            qa.add(e, c);
            let h = $i[e];
            delete $i[e];
            for(let u = 0, f = h.length; u < f; u++){
                let d = h[u];
                d.onLoad && d.onLoad(c);
            }
        }).catch((c)=>{
            let h = $i[e];
            if (h === void 0) throw this.manager.itemError(e), c;
            delete $i[e];
            for(let u = 0, f = h.length; u < f; u++){
                let d = h[u];
                d.onError && d.onError(c);
            }
            this.manager.itemError(e);
        }).finally(()=>{
            this.manager.itemEnd(e);
        }), this.manager.itemStart(e);
    }
    setResponseType(e) {
        return this.responseType = e, this;
    }
    setMimeType(e) {
        return this.mimeType = e, this;
    }
};
var zf = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        let s = this, o = qa.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            t && t(o), s.manager.itemEnd(e);
        }, 0), o;
        let a = jc("img");
        function l() {
            h(), qa.add(e, this), t && t(this), s.manager.itemEnd(e);
        }
        function c(u) {
            h(), n && n(u), s.manager.itemError(e), s.manager.itemEnd(e);
        }
        function h() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1);
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a;
    }
}, Lg = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        let s = new Fs, o = new zf(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;
        function l(c) {
            o.load(e[c], function(h) {
                s.images[c] = h, a++, a === 6 && (s.needsUpdate = !0, t && t(s));
            }, void 0, n);
        }
        for(let c7 = 0; c7 < e.length; ++c7)l(c7);
        return s;
    }
};
var Ig = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        let s = new Dt, o = new zf(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
            s.image = a, s.needsUpdate = !0, t !== void 0 && t(s);
        }, r, n), s;
    }
}, bn = class extends ot {
    constructor(e, t = 1){
        super(), this.type = "Light", this.color = new be(e), this.intensity = t;
    }
    dispose() {}
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
};
bn.prototype.isLight = !0;
var Hs = class extends bn {
    constructor(e, t, r){
        super(e, r), this.type = "HemisphereLight", this.position.copy(ot.DefaultUp), this.updateMatrix(), this.groundColor = new be(t);
    }
    copy(e) {
        return bn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
    }
};
Hs.prototype.isHemisphereLight = !0;
var eb = new Ae, tb = new M, rb = new M, oh = class {
    constructor(e){
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new B(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ae, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Na, this._frameExtents = new B(1, 1), this._viewportCount = 1, this._viewports = [
            new Je(0, 0, 1, 1)
        ];
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(e) {
        let t = this.camera, r = this.matrix;
        tb.setFromMatrixPosition(e.matrixWorld), t.position.copy(tb), rb.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(rb), t.updateMatrixWorld(), eb.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(eb), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(t.projectionMatrix), r.multiply(t.matrixWorldInverse);
    }
    getViewport(e) {
        return this._viewports[e];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
        return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        let e = {};
        return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
    }
}, Gf = class extends oh {
    constructor(){
        super(new sr(50, 1, .5, 500)), this.focus = 1;
    }
    updateMatrices(e) {
        let t = this.camera, r = Wc * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
        (r !== t.fov || n !== t.aspect || s !== t.far) && (t.fov = r, t.aspect = n, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
    }
    copy(e) {
        return super.copy(e), this.focus = e.focus, this;
    }
};
Gf.prototype.isSpotLightShadow = !0;
var ah = class extends bn {
    constructor(e, t, r = 0, n = Math.PI / 3, s = 0, o = 1){
        super(e, t), this.type = "SpotLight", this.position.copy(ot.DefaultUp), this.updateMatrix(), this.target = new ot, this.distance = r, this.angle = n, this.penumbra = s, this.decay = o, this.shadow = new Gf;
    }
    get power() {
        return this.intensity * Math.PI;
    }
    set power(e) {
        this.intensity = e / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
};
ah.prototype.isSpotLight = !0;
var nb = new Ae, Rc = new M, $m = new M, kf = class extends oh {
    constructor(){
        super(new sr(90, 1, .5, 500)), this._frameExtents = new B(4, 2), this._viewportCount = 6, this._viewports = [
            new Je(2, 1, 1, 1),
            new Je(0, 1, 1, 1),
            new Je(3, 1, 1, 1),
            new Je(1, 1, 1, 1),
            new Je(3, 0, 1, 1),
            new Je(1, 0, 1, 1)
        ], this._cubeDirections = [
            new M(1, 0, 0),
            new M(-1, 0, 0),
            new M(0, 0, 1),
            new M(0, 0, -1),
            new M(0, 1, 0),
            new M(0, -1, 0)
        ], this._cubeUps = [
            new M(0, 1, 0),
            new M(0, 1, 0),
            new M(0, 1, 0),
            new M(0, 1, 0),
            new M(0, 0, 1),
            new M(0, 0, -1)
        ];
    }
    updateMatrices(e, t = 0) {
        let r = this.camera, n = this.matrix, s = e.distance || r.far;
        s !== r.far && (r.far = s, r.updateProjectionMatrix()), Rc.setFromMatrixPosition(e.matrixWorld), r.position.copy(Rc), $m.copy(r.position), $m.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt($m), r.updateMatrixWorld(), n.makeTranslation(-Rc.x, -Rc.y, -Rc.z), nb.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(nb);
    }
};
kf.prototype.isPointLightShadow = !0;
var lh = class extends bn {
    constructor(e, t, r = 0, n = 1){
        super(e, t), this.type = "PointLight", this.distance = r, this.decay = n, this.shadow = new kf;
    }
    get power() {
        return this.intensity * 4 * Math.PI;
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
    }
};
lh.prototype.isPointLight = !0;
var Vf = class extends oh {
    constructor(){
        super(new Co(-5, 5, 5, -5, .5, 500));
    }
};
Vf.prototype.isDirectionalLightShadow = !0;
var ch = class extends bn {
    constructor(e, t){
        super(e, t), this.type = "DirectionalLight", this.position.copy(ot.DefaultUp), this.updateMatrix(), this.target = new ot, this.shadow = new Vf;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
};
ch.prototype.isDirectionalLight = !0;
var Rg = class extends bn {
    constructor(e, t){
        super(e, t), this.type = "AmbientLight";
    }
};
Rg.prototype.isAmbientLight = !0;
var Bg = class extends bn {
    constructor(e, t, r = 10, n = 10){
        super(e, t), this.type = "RectAreaLight", this.width = r, this.height = n;
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
        return super.copy(e), this.width = e.width, this.height = e.height, this;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.width = this.width, t.object.height = this.height, t;
    }
};
Bg.prototype.isRectAreaLight = !0;
var Hf = class {
    constructor(){
        this.coefficients = [];
        for(let e = 0; e < 9; e++)this.coefficients.push(new M);
    }
    set(e) {
        for(let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]);
        return this;
    }
    zero() {
        for(let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0);
        return this;
    }
    getAt(e, t) {
        let r = e.x, n = e.y, s = e.z, o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * n), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * r), t.addScaledVector(o[4], 1.092548 * (r * n)), t.addScaledVector(o[5], 1.092548 * (n * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (r * s)), t.addScaledVector(o[8], .546274 * (r * r - n * n)), t;
    }
    getIrradianceAt(e, t) {
        let r = e.x, n = e.y, s = e.z, o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 1.023328 * n), t.addScaledVector(o[2], 1.023328 * s), t.addScaledVector(o[3], 1.023328 * r), t.addScaledVector(o[4], 0.858086 * r * n), t.addScaledVector(o[5], 0.858086 * n * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 0.858086 * r * s), t.addScaledVector(o[8], .429043 * (r * r - n * n)), t;
    }
    add(e) {
        for(let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]);
        return this;
    }
    addScaledSH(e, t) {
        for(let r = 0; r < 9; r++)this.coefficients[r].addScaledVector(e.coefficients[r], t);
        return this;
    }
    scale(e) {
        for(let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e);
        return this;
    }
    lerp(e, t) {
        for(let r = 0; r < 9; r++)this.coefficients[r].lerp(e.coefficients[r], t);
        return this;
    }
    equals(e) {
        for(let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
    }
    copy(e) {
        return this.set(e.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
        let r = this.coefficients;
        for(let n = 0; n < 9; n++)r[n].fromArray(e, t + n * 3);
        return this;
    }
    toArray(e = [], t = 0) {
        let r = this.coefficients;
        for(let n = 0; n < 9; n++)r[n].toArray(e, t + n * 3);
        return e;
    }
    static getBasisAt(e, t) {
        let r = e.x, n = e.y, s = e.z;
        t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * s, t[3] = .488603 * r, t[4] = 1.092548 * r * n, t[5] = 1.092548 * n * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * r * s, t[8] = .546274 * (r * r - n * n);
    }
};
Hf.prototype.isSphericalHarmonics3 = !0;
var hh = class extends bn {
    constructor(e = new Hf, t = 1){
        super(void 0, t), this.sh = e;
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(), t;
    }
};
hh.prototype.isLightProbe = !0;
var Ng = class {
    static decodeText(e) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let t = "";
        for(let r = 0, n = e.length; r < n; r++)t += String.fromCharCode(e[r]);
        try {
            return decodeURIComponent(escape(t));
        } catch  {
            return t;
        }
    }
    static extractUrlBase(e) {
        let t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
    }
}, Wf = class extends Le {
    constructor(){
        super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(e) {
        return super.copy(e), this.instanceCount = e.instanceCount, this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        let e = super.toJSON(this);
        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
    }
};
Wf.prototype.isInstancedBufferGeometry = !0;
var Ws = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        let s = this, o = new as(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)));
            } catch (l) {
                n ? n(l) : console.error(l), s.manager.itemError(e);
            }
        }, r, n);
    }
    parse(e) {
        let t = {}, r = {};
        function n(d, p) {
            if (t[p] !== void 0) return t[p];
            let g = d.interleavedBuffers[p], v = s(d, g.buffer), y = _u(g.type, v), w = new ss(y, g.stride);
            return w.uuid = g.uuid, t[p] = w, w;
        }
        function s(d, p) {
            if (r[p] !== void 0) return r[p];
            let g = d.arrayBuffers[p], v = new Uint32Array(g).buffer;
            return r[p] = v, v;
        }
        let o = e.isInstancedBufferGeometry ? new Wf : new Le, a = e.data.index;
        if (a !== void 0) {
            let d = _u(a.type, a.array);
            o.setIndex(new Ve(d, 1));
        }
        let l = e.data.attributes;
        for(let d9 in l){
            let p = l[d9], m;
            if (p.isInterleavedBufferAttribute) {
                let g = n(e.data, p.data);
                m = new _i(g, p.itemSize, p.offset, p.normalized);
            } else {
                let g = _u(p.type, p.array), v = p.isInstancedBufferAttribute ? Oa : Ve;
                m = new v(g, p.itemSize, p.normalized);
            }
            p.name !== void 0 && (m.name = p.name), p.usage !== void 0 && m.setUsage(p.usage), p.updateRange !== void 0 && (m.updateRange.offset = p.updateRange.offset, m.updateRange.count = p.updateRange.count), o.setAttribute(d9, m);
        }
        let c = e.data.morphAttributes;
        if (c) for(let d7 in c){
            let p = c[d7], m = [];
            for(let g = 0, v = p.length; g < v; g++){
                let y = p[g], w;
                if (y.isInterleavedBufferAttribute) {
                    let b = n(e.data, y.data);
                    w = new _i(b, y.itemSize, y.offset, y.normalized);
                } else {
                    let b = _u(y.type, y.array);
                    w = new Ve(b, y.itemSize, y.normalized);
                }
                y.name !== void 0 && (w.name = y.name), m.push(w);
            }
            o.morphAttributes[d7] = m;
        }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        let u = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (u !== void 0) for(let d8 = 0, p5 = u.length; d8 !== p5; ++d8){
            let m = u[d8];
            o.addGroup(m.start, m.count, m.materialIndex);
        }
        let f = e.data.boundingSphere;
        if (f !== void 0) {
            let d = new M;
            f.center !== void 0 && d.fromArray(f.center), o.boundingSphere = new Lr(d, f.radius);
        }
        return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
    }
};
var Og = class extends cn {
    constructor(e){
        super(e), typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        };
    }
    setOptions(e) {
        return this.options = e, this;
    }
    load(e, t, r, n) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        let s = this, o = qa.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            t && t(o), s.manager.itemEnd(e);
        }, 0), o;
        let a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(l) {
            return l.blob();
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }));
        }).then(function(l) {
            qa.add(e, l), t && t(l), s.manager.itemEnd(e);
        }).catch(function(l) {
            n && n(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }), s.manager.itemStart(e);
    }
};
Og.prototype.isImageBitmapLoader = !0;
var sf, l2 = {
    getContext: function() {
        return sf === void 0 && (sf = new (window.AudioContext || window.webkitAudioContext)), sf;
    },
    setContext: function(i) {
        sf = i;
    }
}, Fg = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        let s = this, o = new as(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
            try {
                let l = a.slice(0);
                l2.getContext().decodeAudioData(l, function(h) {
                    t(h);
                });
            } catch (l) {
                n ? n(l) : console.error(l), s.manager.itemError(e);
            }
        }, r, n);
    }
}, Ug = class extends hh {
    constructor(e, t, r = 1){
        super(void 0, r);
        let n = new be().set(e), s = new be().set(t), o = new M(n.r, n.g, n.b), a = new M(s.r, s.g, s.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
    }
};
Ug.prototype.isHemisphereLightProbe = !0;
var zg = class extends hh {
    constructor(e, t = 1){
        super(void 0, t);
        let r = new be().set(e);
        this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
};
zg.prototype.isAmbientLightProbe = !0;
var jf = class {
    constructor(e = !0){
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
    }
    start() {
        this.startTime = ib(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
    }
    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1;
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            let t = ib();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
        }
        return e;
    }
};
function ib() {
    return (typeof performance > "u" ? Date : performance).now();
}
var Gg = class extends ot {
    constructor(e){
        super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
    }
    setBuffer(e) {
        return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this._startedAt = this.context.currentTime + e;
        let t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(e) {
        return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
    }
    setDetune(e) {
        if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(e) {
        return this.setFilters(e ? [
            e
        ] : []);
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = !1;
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
    }
    setLoopStart(e) {
        return this.loopStart = e, this;
    }
    setLoopEnd(e) {
        return this.loopEnd = e, this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this;
    }
};
var kg = class {
    constructor(e, t = 2048){
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
        let e = 0, t = this.getFrequencyData();
        for(let r = 0; r < t.length; r++)e += t[r];
        return e / t.length;
    }
}, Vg = class {
    constructor(e, t, r){
        this.binding = e, this.valueSize = r;
        let n, s, o;
        switch(t){
            case "quaternion":
                n = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                n = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
                break;
            default:
                n = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
        }
        this._mixBufferRegion = n, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(e, t) {
        let r = this.buffer, n = this.valueSize, s = e * n + n, o = this.cumulativeWeight;
        if (o === 0) {
            for(let a = 0; a !== n; ++a)r[s + a] = r[a];
            o = t;
        } else {
            o += t;
            let a = t / o;
            this._mixBufferRegion(r, s, 0, a, n);
        }
        this.cumulativeWeight = o;
    }
    accumulateAdditive(e) {
        let t = this.buffer, r = this.valueSize, n = r * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, r), this.cumulativeWeightAdditive += e;
    }
    apply(e) {
        let t = this.valueSize, r = this.buffer, n = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
            let l = t * this._origIndex;
            this._mixBufferRegion(r, n, l, 1 - s, t);
        }
        o > 0 && this._mixBufferRegionAdditive(r, n, this._addIndex * t, 1, t);
        for(let l = t, c = t + t; l !== c; ++l)if (r[l] !== r[l + t]) {
            a.setValue(r, n);
            break;
        }
    }
    saveOriginalState() {
        let e = this.binding, t = this.buffer, r = this.valueSize, n = r * this._origIndex;
        e.getValue(t, n);
        for(let s = r, o = n; s !== o; ++s)t[s] = t[n + s % r];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
        let e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
        let e = this._addIndex * this.valueSize, t = e + this.valueSize;
        for(let r = e; r < t; r++)this.buffer[r] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
        let e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
        for(let r = 0; r < this.valueSize; r++)this.buffer[t + r] = this.buffer[e + r];
    }
    _select(e, t, r, n, s) {
        if (n >= .5) for(let o = 0; o !== s; ++o)e[t + o] = e[r + o];
    }
    _slerp(e, t, r, n) {
        zt.slerpFlat(e, t, e, t, e, r, n);
    }
    _slerpAdditive(e, t, r, n, s) {
        let o = this._workIndex * s;
        zt.multiplyQuaternionsFlat(e, o, e, t, e, r), zt.slerpFlat(e, t, e, t, e, o, n);
    }
    _lerp(e, t, r, n, s) {
        let o = 1 - n;
        for(let a = 0; a !== s; ++a){
            let l = t + a;
            e[l] = e[l] * o + e[r + a] * n;
        }
    }
    _lerpAdditive(e, t, r, n, s) {
        for(let o = 0; o !== s; ++o){
            let a = t + o;
            e[a] = e[a] + e[r + o] * n;
        }
    }
}, ny = "\\[\\]\\.:\\/", c2 = new RegExp("[" + ny + "]", "g"), iy = "[^" + ny + "]", h2 = "[^" + ny.replace("\\.", "") + "]", u2 = /((?:WC+[\/:])*)/.source.replace("WC", iy), f2 = /(WCOD+)?/.source.replace("WCOD", h2), d2 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", iy), p2 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", iy), m2 = new RegExp("^" + u2 + f2 + d2 + p2 + "$"), g2 = [
    "material",
    "materials",
    "bones"
], Hg = class {
    constructor(e, t, r){
        let n = r || bt.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, n);
    }
    getValue(e, t) {
        this.bind();
        let r = this._targetGroup.nCachedObjects_, n = this._bindings[r];
        n !== void 0 && n.getValue(e, t);
    }
    setValue(e, t) {
        let r = this._bindings;
        for(let n = this._targetGroup.nCachedObjects_, s = r.length; n !== s; ++n)r[n].setValue(e, t);
    }
    bind() {
        let e = this._bindings;
        for(let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)e[t].bind();
    }
    unbind() {
        let e = this._bindings;
        for(let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)e[t].unbind();
    }
}, bt = class {
    constructor(e, t, r){
        this.path = t, this.parsedPath = r || bt.parseTrackName(t), this.node = bt.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e, t, r) {
        return e && e.isAnimationObjectGroup ? new bt.Composite(e, t, r) : new bt(e, t, r);
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(c2, "");
    }
    static parseTrackName(e) {
        let t = m2.exec(e);
        if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        let r = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }, n = r.nodeName && r.nodeName.lastIndexOf(".");
        if (n !== void 0 && n !== -1) {
            let s = r.nodeName.substring(n + 1);
            g2.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, n), r.objectName = s);
        }
        if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return r;
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
            let r = e.skeleton.getBoneByName(t);
            if (r !== void 0) return r;
        }
        if (e.children) {
            let r = function(s) {
                for(let o = 0; o < s.length; o++){
                    let a = s[o];
                    if (a.name === t || a.uuid === t) return a;
                    let l = r(a.children);
                    if (l) return l;
                }
                return null;
            }, n = r(e.children);
            if (n) return n;
        }
        return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
        let r = this.resolvedProperty;
        for(let n = 0, s = r.length; n !== s; ++n)e[t++] = r[n];
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_array(e, t) {
        let r = this.resolvedProperty;
        for(let n = 0, s = r.length; n !== s; ++n)r[n] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
        let r = this.resolvedProperty;
        for(let n = 0, s = r.length; n !== s; ++n)r[n] = e[t++];
        this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        let r = this.resolvedProperty;
        for(let n = 0, s = r.length; n !== s; ++n)r[n] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
    }
    bind() {
        let e = this.node, t = this.parsedPath, r = t.objectName, n = t.propertyName, s = t.propertyIndex;
        if (e || (e = bt.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
        }
        if (r) {
            let c = t.objectIndex;
            switch(r){
                case "materials":
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return;
                    }
                    if (!e.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return;
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return;
                    }
                    e = e.skeleton.bones;
                    for(let h = 0; h < e.length; h++)if (e[h].name === c) {
                        c = h;
                        break;
                    }
                    break;
                default:
                    if (e[r] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return;
                    }
                    e = e[r];
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return;
                }
                e = e[c];
            }
        }
        let o = e[n];
        if (o === void 0) {
            let c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
            return;
        }
        let a = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (n === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return;
                }
                if (e.geometry.isBufferGeometry) {
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
                } else {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    return;
                }
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
};
bt.Composite = Hg;
bt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
bt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
bt.prototype.GetterByBindingType = [
    bt.prototype._getValue_direct,
    bt.prototype._getValue_array,
    bt.prototype._getValue_arrayElement,
    bt.prototype._getValue_toArray
];
bt.prototype.SetterByBindingTypeAndVersioning = [
    [
        bt.prototype._setValue_direct,
        bt.prototype._setValue_direct_setNeedsUpdate,
        bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
        bt.prototype._setValue_array,
        bt.prototype._setValue_array_setNeedsUpdate,
        bt.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
        bt.prototype._setValue_arrayElement,
        bt.prototype._setValue_arrayElement_setNeedsUpdate,
        bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
        bt.prototype._setValue_fromArray,
        bt.prototype._setValue_fromArray_setNeedsUpdate,
        bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
];
var Wg = class {
    constructor(){
        this.uuid = Un(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        let e = {};
        this._indicesByUUID = e;
        for(let r = 0, n = arguments.length; r !== n; ++r)e[arguments[r].uuid] = r;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        let t = this;
        this.stats = {
            objects: {
                get total () {
                    return t._objects.length;
                },
                get inUse () {
                    return this.total - t.nCachedObjects_;
                }
            },
            get bindingsPerObject () {
                return t._bindings.length;
            }
        };
    }
    add() {
        let e = this._objects, t = this._indicesByUUID, r = this._paths, n = this._parsedPaths, s = this._bindings, o = s.length, a, l = e.length, c = this.nCachedObjects_;
        for(let h = 0, u = arguments.length; h !== u; ++h){
            let f = arguments[h], d = f.uuid, p = t[d];
            if (p === void 0) {
                p = l++, t[d] = p, e.push(f);
                for(let m = 0, g = o; m !== g; ++m)s[m].push(new bt(f, r[m], n[m]));
            } else if (p < c) {
                a = e[p];
                let m = --c, g = e[m];
                t[g.uuid] = p, e[p] = g, t[d] = m, e[m] = f;
                for(let v = 0, y = o; v !== y; ++v){
                    let w = s[v], b = w[m], S = w[p];
                    w[p] = b, S === void 0 && (S = new bt(f, r[v], n[v])), w[m] = S;
                }
            } else e[p] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
        this.nCachedObjects_ = c;
    }
    remove() {
        let e = this._objects, t = this._indicesByUUID, r = this._bindings, n = r.length, s = this.nCachedObjects_;
        for(let o = 0, a = arguments.length; o !== a; ++o){
            let l = arguments[o], c = l.uuid, h = t[c];
            if (h !== void 0 && h >= s) {
                let u = s++, f = e[u];
                t[f.uuid] = h, e[h] = f, t[c] = u, e[u] = l;
                for(let d = 0, p = n; d !== p; ++d){
                    let m = r[d], g = m[u], v = m[h];
                    m[h] = g, m[u] = v;
                }
            }
        }
        this.nCachedObjects_ = s;
    }
    uncache() {
        let e = this._objects, t = this._indicesByUUID, r = this._bindings, n = r.length, s = this.nCachedObjects_, o = e.length;
        for(let a = 0, l = arguments.length; a !== l; ++a){
            let c = arguments[a], h = c.uuid, u = t[h];
            if (u !== void 0) {
                if (delete t[h], u < s) {
                    let f = --s, d = e[f], p = --o, m = e[p];
                    t[d.uuid] = u, e[u] = d, t[m.uuid] = f, e[f] = m, e.pop();
                    for(let g = 0, v = n; g !== v; ++g){
                        let y = r[g], w = y[f], b = y[p];
                        y[u] = w, y[f] = b, y.pop();
                    }
                } else {
                    let f = --o, d = e[f];
                    f > 0 && (t[d.uuid] = u), e[u] = d, e.pop();
                    for(let p = 0, m = n; p !== m; ++p){
                        let g = r[p];
                        g[u] = g[f], g.pop();
                    }
                }
            }
        }
        this.nCachedObjects_ = s;
    }
    subscribe_(e, t) {
        let r = this._bindingsIndicesByPath, n = r[e], s = this._bindings;
        if (n !== void 0) return s[n];
        let o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, h = this.nCachedObjects_, u = new Array(c);
        n = s.length, r[e] = n, o.push(e), a.push(t), s.push(u);
        for(let f = h, d = l.length; f !== d; ++f){
            let p = l[f];
            u[f] = new bt(p, e, t);
        }
        return u;
    }
    unsubscribe_(e) {
        let t = this._bindingsIndicesByPath, r = t[e];
        if (r !== void 0) {
            let n = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = e[a];
            t[c] = r, o[r] = l, o.pop(), s[r] = s[a], s.pop(), n[r] = n[a], n.pop();
        }
    }
};
Wg.prototype.isAnimationObjectGroup = !0;
var jg = class {
    constructor(e, t, r = null, n = t.blendMode){
        this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = n;
        let s = t.tracks, o = s.length, a = new Array(o), l = {
            endingStart: _a,
            endingEnd: _a
        };
        for(let c = 0; c !== o; ++c){
            let h = s[c].createInterpolant(null);
            a[c] = h, h.settings = l;
        }
        this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = DE, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
    }
    play() {
        return this._mixer._activateAction(this), this;
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(e) {
        return this._startTime = e, this;
    }
    setLoop(e, t) {
        return this.loop = e, this.repetitions = t, this;
    }
    setEffectiveWeight(e) {
        return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
    }
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, r) {
        if (e.fadeOut(t), this.fadeIn(t), r) {
            let n = this._clip.duration, s = e._clip.duration, o = s / n, a = n / s;
            e.warp(1, o, t), this.warp(a, 1, t);
        }
        return this;
    }
    crossFadeTo(e, t, r) {
        return e.crossFadeFrom(this, t, r);
    }
    stopFading() {
        let e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e, this.stopWarping();
    }
    syncWith(e) {
        return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, r) {
        let n = this._mixer, s = n.time, o = this.timeScale, a = this._timeScaleInterpolant;
        a === null && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
        let l = a.parameterPositions, c = a.sampleValues;
        return l[0] = s, l[1] = s + r, c[0] = e / o, c[1] = t / o, this;
    }
    stopWarping() {
        let e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
    }
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    _update(e, t, r, n) {
        if (!this.enabled) {
            this._updateWeight(e);
            return;
        }
        let s = this._startTime;
        if (s !== null) {
            let l = (e - s) * r;
            if (l < 0 || r === 0) return;
            this._startTime = null, t = r * l;
        }
        t *= this._updateTimeScale(e);
        let o = this._updateTime(t), a = this._updateWeight(e);
        if (a > 0) {
            let l = this._interpolants, c = this._propertyBindings;
            switch(this.blendMode){
                case gb:
                    for(let h = 0, u = l.length; h !== u; ++h)l[h].evaluate(o), c[h].accumulateAdditive(a);
                    break;
                case $g:
                default:
                    for(let h6 = 0, u5 = l.length; h6 !== u5; ++h6)l[h6].evaluate(o), c[h6].accumulate(n, a);
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            let r = this._weightInterpolant;
            if (r !== null) {
                let n = r.evaluate(e)[0];
                t *= n, e > r.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = !1));
            }
        }
        return this._effectiveWeight = t, t;
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            let r = this._timeScaleInterpolant;
            r !== null && (t *= r.evaluate(e)[0], e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t));
        }
        return this._effectiveTimeScale = t, t;
    }
    _updateTime(e) {
        let t = this._clip.duration, r = this.loop, n = this.time + e, s = this._loopCount, o = r === PE;
        if (e === 0) return s === -1 ? n : o && (s & 1) === 1 ? t - n : n;
        if (r === CE) {
            s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
                if (n >= t) n = t;
                else if (n < 0) n = 0;
                else {
                    this.time = n;
                    break e;
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                });
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), n >= t || n < 0) {
                let a = Math.floor(n / t);
                n -= t * a, s += Math.abs(a);
                let l = this.repetitions - s;
                if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1
                });
                else {
                    if (l === 1) {
                        let c = e < 0;
                        this._setEndings(c, !c, o);
                    } else this._setEndings(!1, !1, o);
                    this._loopCount = s, this.time = n, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    });
                }
            } else this.time = n;
            if (o && (s & 1) === 1) return t - n;
        }
        return n;
    }
    _setEndings(e, t, r) {
        let n = this._interpolantSettings;
        r ? (n.endingStart = Ca, n.endingEnd = Ca) : (e ? n.endingStart = this.zeroSlopeAtStart ? Ca : _a : n.endingStart = df, t ? n.endingEnd = this.zeroSlopeAtEnd ? Ca : _a : n.endingEnd = df);
    }
    _scheduleFading(e, t, r) {
        let n = this._mixer, s = n.time, o = this._weightInterpolant;
        o === null && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
        let a = o.parameterPositions, l = o.sampleValues;
        return a[0] = s, l[0] = t, a[1] = s + e, l[1] = r, this;
    }
}, qg = class extends Yt {
    constructor(e){
        super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(e, t) {
        let r = e._localRoot || this._root, n = e._clip.tracks, s = n.length, o = e._propertyBindings, a = e._interpolants, l = r.uuid, c = this._bindingsByRootAndName, h = c[l];
        h === void 0 && (h = {}, c[l] = h);
        for(let u = 0; u !== s; ++u){
            let f = n[u], d = f.name, p = h[d];
            if (p !== void 0) ++p.referenceCount, o[u] = p;
            else {
                if (p = o[u], p !== void 0) {
                    p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, l, d));
                    continue;
                }
                let m = t && t._propertyBindings[u].binding.parsedPath;
                p = new Vg(bt.create(r, d, m), f.ValueTypeName, f.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, l, d), o[u] = p;
            }
            a[u].resultBuffer = p.buffer;
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                let r = (e._localRoot || this._root).uuid, n = e._clip.uuid, s = this._actionsByClip[n];
                this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, n, r);
            }
            let t = e._propertyBindings;
            for(let r = 0, n = t.length; r !== n; ++r){
                let s = t[r];
                (s.useCount++) === 0 && (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(e);
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            let t = e._propertyBindings;
            for(let r = 0, n = t.length; r !== n; ++r){
                let s = t[r];
                --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
            }
            this._takeBackAction(e);
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        let e = this;
        this.stats = {
            actions: {
                get total () {
                    return e._actions.length;
                },
                get inUse () {
                    return e._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return e._bindings.length;
                },
                get inUse () {
                    return e._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return e._controlInterpolants.length;
                },
                get inUse () {
                    return e._nActiveControlInterpolants;
                }
            }
        };
    }
    _isActiveAction(e) {
        let t = e._cacheIndex;
        return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, r) {
        let n = this._actions, s = this._actionsByClip, o = s[t];
        if (o === void 0) o = {
            knownActions: [
                e
            ],
            actionByRoot: {}
        }, e._byClipCacheIndex = 0, s[t] = o;
        else {
            let a = o.knownActions;
            e._byClipCacheIndex = a.length, a.push(e);
        }
        e._cacheIndex = n.length, n.push(e), o.actionByRoot[r] = e;
    }
    _removeInactiveAction(e) {
        let t = this._actions, r = t[t.length - 1], n = e._cacheIndex;
        r._cacheIndex = n, t[n] = r, t.pop(), e._cacheIndex = null;
        let s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, c = l[l.length - 1], h = e._byClipCacheIndex;
        c._byClipCacheIndex = h, l[h] = c, l.pop(), e._byClipCacheIndex = null;
        let u = a.actionByRoot, f = (e._localRoot || this._root).uuid;
        delete u[f], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
        let t = e._propertyBindings;
        for(let r = 0, n = t.length; r !== n; ++r){
            let s = t[r];
            --s.referenceCount === 0 && this._removeInactiveBinding(s);
        }
    }
    _lendAction(e) {
        let t = this._actions, r = e._cacheIndex, n = this._nActiveActions++, s = t[n];
        e._cacheIndex = n, t[n] = e, s._cacheIndex = r, t[r] = s;
    }
    _takeBackAction(e) {
        let t = this._actions, r = e._cacheIndex, n = --this._nActiveActions, s = t[n];
        e._cacheIndex = n, t[n] = e, s._cacheIndex = r, t[r] = s;
    }
    _addInactiveBinding(e, t, r) {
        let n = this._bindingsByRootAndName, s = this._bindings, o = n[t];
        o === void 0 && (o = {}, n[t] = o), o[r] = e, e._cacheIndex = s.length, s.push(e);
    }
    _removeInactiveBinding(e) {
        let t = this._bindings, r = e.binding, n = r.rootNode.uuid, s = r.path, o = this._bindingsByRootAndName, a = o[n], l = t[t.length - 1], c = e._cacheIndex;
        l._cacheIndex = c, t[c] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[n];
    }
    _lendBinding(e) {
        let t = this._bindings, r = e._cacheIndex, n = this._nActiveBindings++, s = t[n];
        e._cacheIndex = n, t[n] = e, s._cacheIndex = r, t[r] = s;
    }
    _takeBackBinding(e) {
        let t = this._bindings, r = e._cacheIndex, n = --this._nActiveBindings, s = t[n];
        e._cacheIndex = n, t[n] = e, s._cacheIndex = r, t[r] = s;
    }
    _lendControlInterpolant() {
        let e = this._controlInterpolants, t = this._nActiveControlInterpolants++, r = e[t];
        return r === void 0 && (r = new Of(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), r.__cacheIndex = t, e[t] = r), r;
    }
    _takeBackControlInterpolant(e) {
        let t = this._controlInterpolants, r = e.__cacheIndex, n = --this._nActiveControlInterpolants, s = t[n];
        e.__cacheIndex = n, t[n] = e, s.__cacheIndex = r, t[r] = s;
    }
    clipAction(e, t, r) {
        let n = t || this._root, s = n.uuid, o = typeof e == "string" ? Uf.findByName(n, e) : e, a = o !== null ? o.uuid : e, l = this._actionsByClip[a], c = null;
        if (r === void 0 && (o !== null ? r = o.blendMode : r = $g), l !== void 0) {
            let u = l.actionByRoot[s];
            if (u !== void 0 && u.blendMode === r) return u;
            c = l.knownActions[0], o === null && (o = c._clip);
        }
        if (o === null) return null;
        let h = new jg(this, o, t, r);
        return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
    }
    existingAction(e, t) {
        let r = t || this._root, n = r.uuid, s = typeof e == "string" ? Uf.findByName(r, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[n] || null;
    }
    stopAllAction() {
        let e = this._actions, t = this._nActiveActions;
        for(let r = t - 1; r >= 0; --r)e[r].stop();
        return this;
    }
    update(e) {
        e *= this.timeScale;
        let t = this._actions, r = this._nActiveActions, n = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1;
        for(let c = 0; c !== r; ++c)t[c]._update(n, e, s, o);
        let a = this._bindings, l = this._nActiveBindings;
        for(let c8 = 0; c8 !== l; ++c8)a[c8].apply(o);
        return this;
    }
    setTime(e) {
        this.time = 0;
        for(let t = 0; t < this._actions.length; t++)this._actions[t].time = 0;
        return this.update(e);
    }
    getRoot() {
        return this._root;
    }
    uncacheClip(e) {
        let t = this._actions, r = e.uuid, n = this._actionsByClip, s = n[r];
        if (s !== void 0) {
            let o = s.knownActions;
            for(let a = 0, l = o.length; a !== l; ++a){
                let c = o[a];
                this._deactivateAction(c);
                let h = c._cacheIndex, u = t[t.length - 1];
                c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = h, t[h] = u, t.pop(), this._removeInactiveBindingsForAction(c);
            }
            delete n[r];
        }
    }
    uncacheRoot(e) {
        let t = e.uuid, r = this._actionsByClip;
        for(let o in r){
            let a = r[o].actionByRoot, l = a[t];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
        }
        let n = this._bindingsByRootAndName, s = n[t];
        if (s !== void 0) for(let o6 in s){
            let a = s[o6];
            a.restoreOriginalState(), this._removeInactiveBinding(a);
        }
    }
    uncacheAction(e, t) {
        let r = this.existingAction(e, t);
        r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
    }
};
qg.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var _e = class {
    constructor(e){
        typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
    }
    clone() {
        return new _e(this.value.clone === void 0 ? this.value : this.value.clone());
    }
}, Yg = class extends ss {
    constructor(e, t, r = 1){
        super(e, t), this.meshPerAttribute = r;
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    clone(e) {
        let t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute, t;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
    }
};
Yg.prototype.isInstancedInterleavedBuffer = !0;
var Xg = class {
    constructor(e, t, r, n, s){
        this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = n, this.count = s, this.version = 0;
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setBuffer(e) {
        return this.buffer = e, this;
    }
    setType(e, t) {
        return this.type = e, this.elementSize = t, this;
    }
    setItemSize(e) {
        return this.itemSize = e, this;
    }
    setCount(e) {
        return this.count = e, this;
    }
};
Xg.prototype.isGLBufferAttribute = !0;
var qf = class {
    constructor(e, t, r = 0, n = 1 / 0){
        this.ray = new si(e, t), this.near = r, this.far = n, this.camera = null, this.layers = new Yc, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
    }
    set(e, t) {
        this.ray.set(e, t);
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    intersectObject(e, t = !0, r = []) {
        return Qg(e, this, r, t), r.sort(sb), r;
    }
    intersectObjects(e, t = !0, r = []) {
        for(let n = 0, s = e.length; n < s; n++)Qg(e[n], this, r, t);
        return r.sort(sb), r;
    }
};
function sb(i, e) {
    return i.distance - e.distance;
}
function Qg(i, e, t, r) {
    if (i.layers.test(e.layers) && i.raycast(e, t), r === !0) {
        let n = i.children;
        for(let s = 0, o = n.length; s < o; s++)Qg(n[s], e, t, !0);
    }
}
var uh = class {
    constructor(e = 1, t = 0, r = 0){
        return this.radius = e, this.phi = t, this.theta = r, this;
    }
    set(e, t, r) {
        return this.radius = e, this.phi = t, this.theta = r, this;
    }
    copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, r) {
        return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(xr(t / this.radius, -1, 1))), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
};
var ob = new B, Oo = class {
    constructor(e = new B(1 / 0, 1 / 0), t = new B(-1 / 0, -1 / 0)){
        this.min = e, this.max = t;
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
        this.makeEmpty();
        for(let t = 0, r = e.length; t < r; t++)this.expandByPoint(e[t]);
        return this;
    }
    setFromCenterAndSize(e, t) {
        let r = ob.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5);
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
        return ob.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this;
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
    }
};
Oo.prototype.isBox2 = !0;
var ab = new M, of = new M, Jr = class {
    constructor(e = new M, t = new M){
        this.start = e, this.end = t;
    }
    set(e, t) {
        return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5);
    }
    delta(e) {
        return e.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
        ab.subVectors(e, this.start), of.subVectors(this.end, this.start);
        let r = of.dot(of), s = of.dot(ab) / r;
        return t && (s = xr(s, 0, 1)), s;
    }
    closestPointToPoint(e, t, r) {
        let n = this.closestPointToPointParameter(e, t);
        return this.delta(r).multiplyScalar(n).add(this.start);
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}, lb = new M, Yf = class extends ot {
    constructor(e, t){
        super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
        let r = new Le, n = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
        ];
        for(let o = 0, a = 1, l = 32; o < l; o++, a++){
            let c = o / l * Math.PI * 2, h = a / l * Math.PI * 2;
            n.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1);
        }
        r.setAttribute("position", new Ce(n, 3));
        let s = new kr({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new ai(r, s), this.add(this.cone), this.update();
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
        this.light.updateMatrixWorld();
        let e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), lb.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(lb), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
}, Cs = new M, af = new Ae, eg = new Ae, Jg = class extends ai {
    constructor(e){
        let t = Rb(e), r = new Le, n = [], s = [], o = new be(0, 0, 1), a = new be(0, 1, 0);
        for(let c = 0; c < t.length; c++){
            let h = t[c];
            h.parent && h.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b));
        }
        r.setAttribute("position", new Ce(n, 3)), r.setAttribute("color", new Ce(s, 3));
        let l = new kr({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(r, l), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
    }
    updateMatrixWorld(e) {
        let t = this.bones, r = this.geometry, n = r.getAttribute("position");
        eg.copy(this.root.matrixWorld).invert();
        for(let s = 0, o = 0; s < t.length; s++){
            let a = t[s];
            a.parent && a.parent.isBone && (af.multiplyMatrices(eg, a.matrixWorld), Cs.setFromMatrixPosition(af), n.setXYZ(o, Cs.x, Cs.y, Cs.z), af.multiplyMatrices(eg, a.parent.matrixWorld), Cs.setFromMatrixPosition(af), n.setXYZ(o + 1, Cs.x, Cs.y, Cs.z), o += 2);
        }
        r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
    }
};
function Rb(i) {
    let e = [];
    i.isBone === !0 && e.push(i);
    for(let t = 0; t < i.children.length; t++)e.push.apply(e, Rb(i.children[t]));
    return e;
}
var Xf = class extends Vt {
    constructor(e, t, r){
        let n = new Ro(t, 4, 2), s = new zn({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(n, s), this.light = e, this.light.updateMatrixWorld(), this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
    update() {
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
};
var Kg = class extends ai {
    constructor(e = 10, t = 10, r = 4473924, n = 8947848){
        r = new be(r), n = new be(n);
        let s = t / 2, o = e / t, a = e / 2, l = [], c = [];
        for(let f = 0, d = 0, p = -a; f <= t; f++, p += o){
            l.push(-a, 0, p, a, 0, p), l.push(p, 0, -a, p, 0, a);
            let m = f === s ? r : n;
            m.toArray(c, d), d += 3, m.toArray(c, d), d += 3, m.toArray(c, d), d += 3, m.toArray(c, d), d += 3;
        }
        let h = new Le;
        h.setAttribute("position", new Ce(l, 3)), h.setAttribute("color", new Ce(c, 3));
        let u = new kr({
            vertexColors: !0,
            toneMapped: !1
        });
        super(h, u), this.type = "GridHelper";
    }
};
var cb = new M, lf = new M, hb = new M, Qf = class extends ot {
    constructor(e, t, r){
        super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, t === void 0 && (t = 1);
        let n = new Le;
        n.setAttribute("position", new Ce([
            -t,
            t,
            0,
            t,
            t,
            0,
            t,
            -t,
            0,
            -t,
            -t,
            0,
            -t,
            t,
            0
        ], 3));
        let s = new kr({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new os(n, s), this.add(this.lightPlane), n = new Le, n.setAttribute("position", new Ce([
            0,
            0,
            0,
            0,
            0,
            1
        ], 3)), this.targetLine = new os(n, s), this.add(this.targetLine), this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
        cb.setFromMatrixPosition(this.light.matrixWorld), lf.setFromMatrixPosition(this.light.target.matrixWorld), hb.subVectors(lf, cb), this.lightPlane.lookAt(lf), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(lf), this.targetLine.scale.z = hb.length();
    }
}, cf = new M, ir = new Gn, Hn = class extends ai {
    constructor(e){
        let t = new Le, r = new kr({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        }), n = [], s = [], o = {}, a = new be(16755200), l = new be(16711680), c = new be(43775), h = new be(16777215), u = new be(3355443);
        f("n1", "n2", a), f("n2", "n4", a), f("n4", "n3", a), f("n3", "n1", a), f("f1", "f2", a), f("f2", "f4", a), f("f4", "f3", a), f("f3", "f1", a), f("n1", "f1", a), f("n2", "f2", a), f("n3", "f3", a), f("n4", "f4", a), f("p", "n1", l), f("p", "n2", l), f("p", "n3", l), f("p", "n4", l), f("u1", "u2", c), f("u2", "u3", c), f("u3", "u1", c), f("c", "t", h), f("p", "c", u), f("cn1", "cn2", u), f("cn3", "cn4", u), f("cf1", "cf2", u), f("cf3", "cf4", u);
        function f(p, m, g) {
            d(p, g), d(m, g);
        }
        function d(p, m) {
            n.push(0, 0, 0), s.push(m.r, m.g, m.b), o[p] === void 0 && (o[p] = []), o[p].push(n.length / 3 - 1);
        }
        t.setAttribute("position", new Ce(n, 3)), t.setAttribute("color", new Ce(s, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    }
    update() {
        let e = this.geometry, t = this.pointMap, r = 1, n = 1;
        ir.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), cr("c", t, e, ir, 0, 0, -1), cr("t", t, e, ir, 0, 0, 1), cr("n1", t, e, ir, -r, -n, -1), cr("n2", t, e, ir, r, -n, -1), cr("n3", t, e, ir, -r, n, -1), cr("n4", t, e, ir, r, n, -1), cr("f1", t, e, ir, -r, -n, 1), cr("f2", t, e, ir, r, -n, 1), cr("f3", t, e, ir, -r, n, 1), cr("f4", t, e, ir, r, n, 1), cr("u1", t, e, ir, r * .7, n * 1.1, -1), cr("u2", t, e, ir, -r * .7, n * 1.1, -1), cr("u3", t, e, ir, 0, n * 2, -1), cr("cf1", t, e, ir, -r, 0, 1), cr("cf2", t, e, ir, r, 0, 1), cr("cf3", t, e, ir, 0, -n, 1), cr("cf4", t, e, ir, 0, n, 1), cr("cn1", t, e, ir, -r, 0, -1), cr("cn2", t, e, ir, r, 0, -1), cr("cn3", t, e, ir, 0, -n, -1), cr("cn4", t, e, ir, 0, n, -1), e.getAttribute("position").needsUpdate = !0;
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
};
function cr(i, e, t, r, n, s, o) {
    cf.set(n, s, o).unproject(r);
    let a = e[i];
    if (a !== void 0) {
        let l = t.getAttribute("position");
        for(let c = 0, h = a.length; c < h; c++)l.setXYZ(a[c], cf.x, cf.y, cf.z);
    }
}
var Fo = class extends ai {
    constructor(e, t = 16776960){
        let r = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]), n = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
        ], s = new Le;
        s.setIndex(new Ve(r, 1)), s.setAttribute("position", new Ce(n, 3)), super(s, new kr({
            color: t,
            toneMapped: !1
        })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
        let t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e));
    }
};
var Jf = class extends ai {
    constructor(e = 1){
        let t = [
            0,
            0,
            0,
            e,
            0,
            0,
            0,
            0,
            0,
            0,
            e,
            0,
            0,
            0,
            0,
            0,
            0,
            e
        ], r = [
            1,
            0,
            0,
            1,
            .6,
            0,
            0,
            1,
            0,
            .6,
            1,
            0,
            0,
            0,
            1,
            0,
            .6,
            1
        ], n = new Le;
        n.setAttribute("position", new Ce(t, 3)), n.setAttribute("color", new Ce(r, 3));
        let s = new kr({
            vertexColors: !0,
            toneMapped: !1
        });
        super(n, s), this.type = "AxesHelper";
    }
    setColors(e, t, r) {
        let n = new be, s = this.geometry.attributes.color.array;
        return n.set(e), n.toArray(s, 0), n.toArray(s, 3), n.set(t), n.toArray(s, 6), n.toArray(s, 9), n.set(r), n.toArray(s, 12), n.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
}, Kf = class {
    constructor(){
        this.type = "ShapePath", this.color = new be, this.subPaths = [], this.currentPath = null;
    }
    moveTo(e, t) {
        return this.currentPath = new Fa, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, r, n) {
        return this.currentPath.quadraticCurveTo(e, t, r, n), this;
    }
    bezierCurveTo(e, t, r, n, s, o) {
        return this.currentPath.bezierCurveTo(e, t, r, n, s, o), this;
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this;
    }
    toShapes(e, t) {
        function r(y) {
            let w = [];
            for(let b = 0, S = y.length; b < S; b++){
                let T = y[b], A = new rn;
                A.curves = T.curves, w.push(A);
            }
            return w;
        }
        function n(y, w) {
            let b = w.length, S = !1;
            for(let T = b - 1, A = 0; A < b; T = A++){
                let x = w[T], E = w[A], _ = E.x - x.x, C = E.y - x.y;
                if (Math.abs(C) > Number.EPSILON) {
                    if (C < 0 && (x = w[A], _ = -_, E = w[T], C = -C), y.y < x.y || y.y > E.y) continue;
                    if (y.y === x.y) {
                        if (y.x === x.x) return !0;
                    } else {
                        let I = C * (y.x - x.x) - _ * (y.y - x.y);
                        if (I === 0) return !0;
                        if (I < 0) continue;
                        S = !S;
                    }
                } else {
                    if (y.y !== x.y) continue;
                    if (E.x <= y.x && y.x <= x.x || x.x <= y.x && y.x <= E.x) return !0;
                }
            }
            return S;
        }
        let s = ni.isClockWise, o = this.subPaths;
        if (o.length === 0) return [];
        if (t === !0) return r(o);
        let a, l, c, h = [];
        if (o.length === 1) return l = o[0], c = new rn, c.curves = l.curves, h.push(c), h;
        let u = !s(o[0].getPoints());
        u = e ? !u : u;
        let f = [], d = [], p = [], m = 0, g;
        d[m] = void 0, p[m] = [];
        for(let y7 = 0, w7 = o.length; y7 < w7; y7++)l = o[y7], g = l.getPoints(), a = s(g), a = e ? !a : a, a ? (!u && d[m] && m++, d[m] = {
            s: new rn,
            p: g
        }, d[m].s.curves = l.curves, u && m++, p[m] = []) : p[m].push({
            h: l,
            p: g[0]
        });
        if (!d[0]) return r(o);
        if (d.length > 1) {
            let y = !1, w = 0;
            for(let b = 0, S = d.length; b < S; b++)f[b] = [];
            for(let b7 = 0, S4 = d.length; b7 < S4; b7++){
                let T = p[b7];
                for(let A = 0; A < T.length; A++){
                    let x = T[A], E = !0;
                    for(let _ = 0; _ < d.length; _++)n(x.p, d[_].p) && (b7 !== _ && w++, E ? (E = !1, f[_].push(x)) : y = !0);
                    E && f[b7].push(x);
                }
            }
            w > 0 && y === !1 && (p = f);
        }
        let v;
        for(let y6 = 0, w6 = d.length; y6 < w6; y6++){
            c = d[y6].s, h.push(c), v = p[y6];
            for(let b = 0, S = v.length; b < S; b++)c.holes.push(v[b].h);
        }
        return h;
    }
};
var Bb = new ArrayBuffer(4), yG = new Float32Array(Bb), vG = new Uint32Array(Bb), Ai = new Uint32Array(512), Ti = new Uint32Array(512);
for(let i1 = 0; i1 < 256; ++i1){
    let e = i1 - 127;
    e < -27 ? (Ai[i1] = 0, Ai[i1 | 256] = 32768, Ti[i1] = 24, Ti[i1 | 256] = 24) : e < -14 ? (Ai[i1] = 1024 >> -e - 14, Ai[i1 | 256] = 1024 >> -e - 14 | 32768, Ti[i1] = -e - 1, Ti[i1 | 256] = -e - 1) : e <= 15 ? (Ai[i1] = e + 15 << 10, Ai[i1 | 256] = e + 15 << 10 | 32768, Ti[i1] = 13, Ti[i1 | 256] = 13) : e < 128 ? (Ai[i1] = 31744, Ai[i1 | 256] = 64512, Ti[i1] = 24, Ti[i1 | 256] = 24) : (Ai[i1] = 31744, Ai[i1 | 256] = 64512, Ti[i1] = 13, Ti[i1 | 256] = 13);
}
var Nb = new Uint32Array(2048), fh = new Uint32Array(64), y2 = new Uint32Array(64);
for(let i3 = 1; i3 < 1024; ++i3){
    let e = i3 << 13, t = 0;
    for(; (e & 8388608) === 0;)e <<= 1, t -= 8388608;
    e &= -8388609, t += 947912704, Nb[i3] = e | t;
}
for(let i4 = 1024; i4 < 2048; ++i4)Nb[i4] = 939524096 + (i4 - 1024 << 13);
for(let i5 = 1; i5 < 31; ++i5)fh[i5] = i5 << 23;
fh[31] = 1199570944;
fh[32] = 2147483648;
for(let i6 = 33; i6 < 63; ++i6)fh[i6] = 2147483648 + (i6 - 32 << 23);
fh[63] = 3347054592;
for(let i7 = 1; i7 < 64; ++i7)i7 !== 32 && (y2[i7] = 1024);
xn.create = function(i, e) {
    return console.log("THREE.Curve.create() has been deprecated"), i.prototype = Object.create(xn.prototype), i.prototype.constructor = i, i.prototype.getPoint = e, i;
};
Fa.prototype.fromPoints = function(i) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(i);
};
Kg.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
Jg.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
cn.prototype.extractUrlBase = function(i) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ng.extractUrlBase(i);
};
cn.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
};
Oo.prototype.center = function(i) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(i);
};
Oo.prototype.empty = function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Oo.prototype.isIntersectionBox = function(i) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(i);
};
Oo.prototype.size = function(i) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(i);
};
Kt.prototype.center = function(i) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(i);
};
Kt.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Kt.prototype.isIntersectionBox = function(i) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(i);
};
Kt.prototype.isIntersectionSphere = function(i) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(i);
};
Kt.prototype.size = function(i) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(i);
};
yn.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
};
Lr.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
};
Na.prototype.setFromMatrix = function(i) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(i);
};
Jr.prototype.center = function(i) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(i);
};
Ft.prototype.flattenToArrayOffset = function(i, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(i, e);
};
Ft.prototype.multiplyVector3 = function(i) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), i.applyMatrix3(this);
};
Ft.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Ft.prototype.applyToBufferAttribute = function(i) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), i.applyMatrix3(this);
};
Ft.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Ft.prototype.getInverse = function(i) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(i).invert();
};
Ae.prototype.extractPosition = function(i) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(i);
};
Ae.prototype.flattenToArrayOffset = function(i, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(i, e);
};
Ae.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new M().setFromMatrixColumn(this, 3);
};
Ae.prototype.setRotationFromQuaternion = function(i) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(i);
};
Ae.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Ae.prototype.multiplyVector3 = function(i) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), i.applyMatrix4(this);
};
Ae.prototype.multiplyVector4 = function(i) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), i.applyMatrix4(this);
};
Ae.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Ae.prototype.rotateAxis = function(i) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), i.transformDirection(this);
};
Ae.prototype.crossVector = function(i) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), i.applyMatrix4(this);
};
Ae.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
};
Ae.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Ae.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Ae.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Ae.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Ae.prototype.applyToBufferAttribute = function(i) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), i.applyMatrix4(this);
};
Ae.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Ae.prototype.makeFrustum = function(i, e, t, r, n, s) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(i, e, r, t, n, s);
};
Ae.prototype.getInverse = function(i) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(i).invert();
};
Gr.prototype.isIntersectionLine = function(i) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(i);
};
zt.prototype.multiplyVector3 = function(i) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), i.applyQuaternion(this);
};
zt.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
};
si.prototype.isIntersectionBox = function(i) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(i);
};
si.prototype.isIntersectionPlane = function(i) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(i);
};
si.prototype.isIntersectionSphere = function(i) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(i);
};
Jt.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
};
Jt.prototype.barycoordFromPoint = function(i, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(i, e);
};
Jt.prototype.midpoint = function(i) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(i);
};
Jt.prototypenormal = function(i) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(i);
};
Jt.prototype.plane = function(i) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(i);
};
Jt.barycoordFromPoint = function(i, e, t, r, n) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Jt.getBarycoord(i, e, t, r, n);
};
Jt.normal = function(i, e, t, r) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Jt.getNormal(i, e, t, r);
};
rn.prototype.extractAllPoints = function(i) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(i);
};
rn.prototype.extrude = function(i) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Gs(this, i);
};
rn.prototype.makeGeometry = function(i) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Io(this, i);
};
B.prototype.fromAttribute = function(i, e, t) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(i, e, t);
};
B.prototype.distanceToManhattan = function(i) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(i);
};
B.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
M.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
M.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
M.prototype.getPositionFromMatrix = function(i) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(i);
};
M.prototype.getScaleFromMatrix = function(i) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(i);
};
M.prototype.getColumnFromMatrix = function(i, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, i);
};
M.prototype.applyProjection = function(i) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(i);
};
M.prototype.fromAttribute = function(i, e, t) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(i, e, t);
};
M.prototype.distanceToManhattan = function(i) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(i);
};
M.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
Je.prototype.fromAttribute = function(i, e, t) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(i, e, t);
};
Je.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
};
ot.prototype.getChildByName = function(i) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(i);
};
ot.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
ot.prototype.translate = function(i, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, i);
};
ot.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
ot.prototype.applyMatrix = function(i) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(i);
};
Object.defineProperties(ot.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
        },
        set: function(i) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = i;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
    }
});
Vt.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Vt.prototype, {
    drawMode: {
        get: function() {
            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), yb;
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
    }
});
wf.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
sr.prototype.setLens = function(i, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e !== void 0 && (this.filmGauge = e), this.setFocalLength(i);
};
Object.defineProperties(bn.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        }
    },
    shadowCameraFov: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = i;
        }
    },
    shadowCameraLeft: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = i;
        }
    },
    shadowCameraRight: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = i;
        }
    },
    shadowCameraTop: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = i;
        }
    },
    shadowCameraBottom: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = i;
        }
    },
    shadowCameraNear: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = i;
        }
    },
    shadowCameraFar: {
        set: function(i) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = i;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
    },
    shadowBias: {
        set: function(i) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = i;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
    },
    shadowMapWidth: {
        set: function(i) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = i;
        }
    },
    shadowMapHeight: {
        set: function(i) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = i;
        }
    }
});
Object.defineProperties(Ve.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
        }
    },
    dynamic: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === pf;
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(pf);
        }
    }
});
Ve.prototype.setDynamic = function(i) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(i === !0 ? pf : Hc), this;
};
Ve.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, Ve.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
Le.prototype.addIndex = function(i) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(i);
};
Le.prototype.addAttribute = function(i, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(i, new Ve(arguments[1], arguments[2]))) : i === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(i, e);
};
Le.prototype.addDrawCall = function(i, e, t) {
    t !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(i, e);
};
Le.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
};
Le.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
Le.prototype.removeAttribute = function(i) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(i);
};
Le.prototype.applyMatrix = function(i) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(i);
};
Object.defineProperties(Le.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
        }
    }
});
ss.prototype.setDynamic = function(i) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(i === !0 ? pf : Hc), this;
};
ss.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
Gs.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
Gs.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
Gs.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
on.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
};
_e.prototype.onUpdate = function() {
    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
};
Object.defineProperties(ur.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE.Material: .wrapRGB has been removed."), new be;
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(i) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === fb;
        }
    },
    stencilMask: {
        get: function() {
            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
        },
        set: function(i) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = i;
        }
    },
    vertexTangents: {
        get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        },
        set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        }
    }
});
Object.defineProperties(Mt.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
        },
        set: function(i) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = i;
        }
    }
});
Pt.prototype.clearTarget = function(i, e, t, r) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(i), this.clear(e, t, r);
};
Pt.prototype.animate = function(i) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(i);
};
Pt.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
};
Pt.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
};
Pt.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
};
Pt.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
};
Pt.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
};
Pt.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
};
Pt.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
};
Pt.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
};
Pt.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
Pt.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
};
Pt.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
};
Pt.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
};
Pt.prototype.enableScissorTest = function(i) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(i);
};
Pt.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
Pt.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
Pt.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
Pt.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
Pt.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
Pt.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
Pt.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
Pt.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
Pt.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
Pt.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
};
Object.defineProperties(Pt.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = i;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = i;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    context: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
        }
    },
    vr: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
        }
    },
    gammaInput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
    },
    gammaOutput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = i === !0 ? je : gn;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
    },
    gammaFactor: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        }
    }
});
Object.defineProperties(_b.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
    }
});
Object.defineProperties(mt.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = i;
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = i;
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = i;
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = i;
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = i;
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = i;
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = i;
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = i;
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = i;
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
        },
        set: function(i) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = i;
        }
    }
});
Gg.prototype.load = function(i) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    let e = this;
    return new Fg().load(i, function(r) {
        e.setBuffer(r);
    }), this;
};
kg.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
};
Xc.prototype.updateCubeMap = function(i, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(i, e);
};
Xc.prototype.clear = function(i, e, t, r) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(i, e, t, r);
};
ns.crossOrigin = void 0;
ns.loadTexture = function(i, e, t, r) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    let n = new Ig;
    n.setCrossOrigin(this.crossOrigin);
    let s = n.load(i, t, void 0, r);
    return e && (s.mapping = e), s;
};
ns.loadTextureCube = function(i, e, t, r) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    let n = new Lg;
    n.setCrossOrigin(this.crossOrigin);
    let s = n.load(i, t, void 0, r);
    return e && (s.mapping = e), s;
};
ns.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ns.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
var Zf = class extends mt {
    constructor(e, t, r){
        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, r), this.samples = 4;
    }
};
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: Uo
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Uo);
var Ja = ".", dh = Symbol("target"), sy = Symbol("unsubscribe");
function ph(i) {
    return i instanceof Date || i instanceof Set || i instanceof Map || i instanceof WeakSet || i instanceof WeakMap || ArrayBuffer.isView(i);
}
function Ob(i) {
    return (typeof i == "object" ? i === null : typeof i != "function") || i instanceof RegExp;
}
var Dn = Array.isArray;
function zo(i) {
    return typeof i == "symbol";
}
var v2 = {
    after: (i, e)=>Dn(i) ? i.slice(e.length) : e === "" ? i : i.slice(e.length + 1)
    ,
    concat: (i, e)=>Dn(i) ? (i = [
            ...i
        ], e && i.push(e), i) : e && e.toString !== void 0 ? (i !== "" && (i += Ja), zo(e) ? i + e.toString() : i + e) : i
    ,
    initial: (i)=>{
        if (Dn(i)) return i.slice(0, -1);
        if (i === "") return i;
        let e = i.lastIndexOf(Ja);
        return e === -1 ? "" : i.slice(0, e);
    },
    last: (i)=>{
        if (Dn(i)) return i[i.length - 1] || "";
        if (i === "") return i;
        let e = i.lastIndexOf(Ja);
        return e === -1 ? i : i.slice(e + 1);
    },
    walk: (i, e)=>{
        if (Dn(i)) for (let t of i)e(t);
        else if (i !== "") {
            let t = 0, r = i.indexOf(Ja);
            if (r === -1) e(i);
            else for(; t < i.length;)r === -1 && (r = i.length), e(i.slice(t, r)), t = r + 1, r = i.indexOf(Ja, t);
        }
    },
    get (i, e) {
        return this.walk(e, (t)=>{
            i && (i = i[t]);
        }), i;
    }
}, hn = v2;
function oy(i) {
    return typeof i == "object" && typeof i.next == "function";
}
function ay(i, e, t, r, n) {
    let s = i.next;
    if (e.name === "entries") i.next = function() {
        let o = s.call(this);
        return o.done === !1 && (o.value[0] = n(o.value[0], e, o.value[0], r), o.value[1] = n(o.value[1], e, o.value[0], r)), o;
    };
    else if (e.name === "values") {
        let o = t[dh].keys();
        i.next = function() {
            let a = s.call(this);
            return a.done === !1 && (a.value = n(a.value, e, o.next().value, r)), a;
        };
    } else i.next = function() {
        let o = s.call(this);
        return o.done === !1 && (o.value = n(o.value, e, o.value, r)), o;
    };
    return i;
}
function rd(i, e, t) {
    return i.isUnsubscribed || e.ignoreSymbols && zo(t) || e.ignoreUnderscores && t.charAt(0) === "_" || "ignoreKeys" in e && e.ignoreKeys.includes(t);
}
var mh = class {
    constructor(e){
        this._equals = e, this._proxyCache = new WeakMap, this._pathCache = new WeakMap, this.isUnsubscribed = !1;
    }
    _getDescriptorCache() {
        return this._descriptorCache === void 0 && (this._descriptorCache = new WeakMap), this._descriptorCache;
    }
    _getProperties(e) {
        let t = this._getDescriptorCache(), r = t.get(e);
        return r === void 0 && (r = {}, t.set(e, r)), r;
    }
    _getOwnPropertyDescriptor(e, t) {
        if (this.isUnsubscribed) return Reflect.getOwnPropertyDescriptor(e, t);
        let r = this._getProperties(e), n = r[t];
        return n === void 0 && (n = Reflect.getOwnPropertyDescriptor(e, t), r[t] = n), n;
    }
    getProxy(e, t, r, n) {
        if (this.isUnsubscribed) return e;
        let s = e[n], o = s || e;
        this._pathCache.set(o, t);
        let a = this._proxyCache.get(o);
        return a === void 0 && (a = s === void 0 ? new Proxy(e, r) : e, this._proxyCache.set(o, a)), a;
    }
    getPath(e) {
        return this.isUnsubscribed ? void 0 : this._pathCache.get(e);
    }
    isDetached(e, t) {
        return !Object.is(e, hn.get(t, this.getPath(e)));
    }
    defineProperty(e, t, r) {
        return Reflect.defineProperty(e, t, r) ? (this.isUnsubscribed || (this._getProperties(e)[t] = r), !0) : !1;
    }
    setProperty(e, t, r, n, s) {
        if (!this._equals(s, r) || !(t in e)) {
            let o = this._getOwnPropertyDescriptor(e, t);
            return o !== void 0 && "set" in o ? Reflect.set(e, t, r, n) : Reflect.set(e, t, r);
        }
        return !0;
    }
    deleteProperty(e, t, r) {
        if (Reflect.deleteProperty(e, t)) {
            if (!this.isUnsubscribed) {
                let n = this._getDescriptorCache().get(e);
                n && (delete n[t], this._pathCache.delete(r));
            }
            return !0;
        }
        return !1;
    }
    isSameDescriptor(e, t, r) {
        let n = this._getOwnPropertyDescriptor(t, r);
        return e !== void 0 && n !== void 0 && Object.is(e.value, n.value) && (e.writable || !1) === (n.writable || !1) && (e.enumerable || !1) === (n.enumerable || !1) && (e.configurable || !1) === (n.configurable || !1) && e.get === n.get && e.set === n.set;
    }
    isGetInvariant(e, t) {
        let r = this._getOwnPropertyDescriptor(e, t);
        return r !== void 0 && r.configurable !== !0 && r.writable !== !0;
    }
    unsubscribe() {
        this._descriptorCache = null, this._pathCache = null, this._proxyCache = null, this.isUnsubscribed = !0;
    }
};
function Ka(i) {
    return toString.call(i) === "[object Object]";
}
function Za() {
    return !0;
}
function qs(i, e) {
    return i.length !== e.length || i.some((t, r)=>e[r] !== t
    );
}
var nd = new Set([
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
]);
var x2 = new Set([
    "concat",
    "includes",
    "indexOf",
    "join",
    "keys",
    "lastIndexOf"
]), ly = {
    push: Za,
    pop: Za,
    shift: Za,
    unshift: Za,
    copyWithin: qs,
    reverse: qs,
    sort: qs,
    splice: qs,
    flat: qs,
    fill: qs
}, Fb = new Set([
    ...nd,
    ...x2,
    ...Object.keys(ly)
]);
function $a(i, e) {
    if (i.size !== e.size) return !0;
    for (let t of i)if (!e.has(t)) return !0;
    return !1;
}
var cy = [
    "keys",
    "values",
    "entries"
], hy = new Set([
    "has",
    "toString"
]), uy = {
    add: $a,
    clear: $a,
    delete: $a,
    forEach: $a
}, Ub = new Set([
    ...hy,
    ...Object.keys(uy),
    ...cy
]);
function el(i, e) {
    if (i.size !== e.size) return !0;
    let t;
    for (let [r, n] of i)if (t = e.get(r), t !== n || t === void 0 && !e.has(r)) return !0;
    return !1;
}
var b2 = new Set([
    ...hy,
    "get"
]), fy = {
    set: el,
    clear: el,
    delete: el,
    forEach: el
}, zb = new Set([
    ...b2,
    ...Object.keys(fy),
    ...cy
]);
var Rr = class {
    constructor(e, t, r, n){
        this._path = t, this._isChanged = !1, this._clonedCache = new Set, this._hasOnValidate = n, this._changes = n ? [] : null, this.clone = t === void 0 ? e : this._shallowClone(e);
    }
    static isHandledMethod(e) {
        return nd.has(e);
    }
    _shallowClone(e) {
        let t = e;
        if (Ka(e)) t = ie({}, e);
        else if (Dn(e)) t = [
            ...e
        ];
        else if (e instanceof Date) t = new Date(e);
        else if (e instanceof Set) t = new Set([
            ...e
        ].map((r)=>this._shallowClone(r)
        ));
        else if (e instanceof Map) {
            t = new Map;
            for (let [r, n] of e.entries())t.set(r, this._shallowClone(n));
        }
        return this._clonedCache.add(t), t;
    }
    preferredThisArg(e, t, r, n) {
        return e ? (Dn(n) ? this._onIsChanged = ly[t] : n instanceof Set ? this._onIsChanged = uy[t] : n instanceof Map && (this._onIsChanged = fy[t]), n) : r;
    }
    update(e, t, r) {
        let n = hn.after(e, this._path);
        if (t !== "length") {
            let s = this.clone;
            hn.walk(n, (o)=>{
                s && s[o] && (this._clonedCache.has(s[o]) || (s[o] = this._shallowClone(s[o])), s = s[o]);
            }), this._hasOnValidate && this._changes.push({
                path: n,
                property: t,
                previous: r
            }), s && s[t] && (s[t] = r);
        }
        this._isChanged = !0;
    }
    undo(e) {
        let t;
        for(let r = this._changes.length - 1; r !== -1; r--)t = this._changes[r], hn.get(e, t.path)[t.property] = t.previous;
    }
    isChanged(e) {
        return this._onIsChanged === void 0 ? this._isChanged : this._onIsChanged(this.clone, e);
    }
};
var tl = class extends Rr {
    static isHandledMethod(e) {
        return Fb.has(e);
    }
};
var gh = class extends Rr {
    undo(e) {
        e.setTime(this.clone.getTime());
    }
    isChanged(e, t) {
        return !t(this.clone.valueOf(), e.valueOf());
    }
};
var rl = class extends Rr {
    static isHandledMethod(e) {
        return Ub.has(e);
    }
    undo(e) {
        for (let t of this.clone)e.add(t);
        for (let t5 of e)this.clone.has(t5) || e.delete(t5);
    }
};
var nl = class extends Rr {
    static isHandledMethod(e) {
        return zb.has(e);
    }
    undo(e) {
        for (let [t, r] of this.clone.entries())e.set(t, r);
        for (let t6 of e.keys())this.clone.has(t6) || e.delete(t6);
    }
};
var yh = class extends Rr {
    constructor(e, t, r, n){
        super(void 0, t, r, n), this._arg1 = r[0], this._weakValue = e.has(this._arg1);
    }
    isChanged(e) {
        return this._weakValue !== e.has(this._arg1);
    }
    undo(e) {
        this._weakValue && !e.has(this._arg1) ? e.add(this._arg1) : e.delete(this._arg1);
    }
};
var vh = class extends Rr {
    constructor(e, t, r, n){
        super(void 0, t, r, n), this._weakKey = r[0], this._weakHas = e.has(this._weakKey), this._weakValue = e.get(this._weakKey);
    }
    isChanged(e) {
        return this._weakValue !== e.get(this._weakKey);
    }
    undo(e) {
        let t = e.has(this._weakKey);
        this._weakHas && !t ? e.set(this._weakKey, this._weakValue) : !this._weakHas && t ? e.delete(this._weakKey) : this._weakValue !== e.get(this._weakKey) && e.set(this._weakKey, this._weakValue);
    }
};
var ci = class {
    constructor(e){
        this._stack = [], this._hasOnValidate = e;
    }
    static isHandledType(e) {
        return Ka(e) || Dn(e) || ph(e);
    }
    static isHandledMethod(e, t) {
        return Ka(e) ? Rr.isHandledMethod(t) : Dn(e) ? tl.isHandledMethod(t) : e instanceof Set ? rl.isHandledMethod(t) : e instanceof Map ? nl.isHandledMethod(t) : ph(e);
    }
    get isCloning() {
        return this._stack.length > 0;
    }
    start(e, t, r) {
        let n = Rr;
        Dn(e) ? n = tl : e instanceof Date ? n = gh : e instanceof Set ? n = rl : e instanceof Map ? n = nl : e instanceof WeakSet ? n = yh : e instanceof WeakMap && (n = vh), this._stack.push(new n(e, t, r, this._hasOnValidate));
    }
    update(e, t, r) {
        this._stack[this._stack.length - 1].update(e, t, r);
    }
    preferredThisArg(e, t, r) {
        let { name: n  } = e, s = ci.isHandledMethod(r, n);
        return this._stack[this._stack.length - 1].preferredThisArg(s, n, t, r);
    }
    isChanged(e, t, r) {
        return this._stack[this._stack.length - 1].isChanged(e, t, r);
    }
    undo(e) {
        this._previousClone !== void 0 && this._previousClone.undo(e);
    }
    stop() {
        return this._previousClone = this._stack.pop(), this._previousClone.clone;
    }
};
var w2 = {
    equals: Object.is,
    isShallow: !1,
    pathAsArray: !1,
    ignoreSymbols: !1,
    ignoreUnderscores: !1,
    ignoreDetached: !1,
    details: !1
}, dy = (i, e, t = {})=>{
    t = ie(ie({}, w2), t);
    let r = Symbol("ProxyTarget"), { equals: n , isShallow: s , ignoreDetached: o , details: a  } = t, l = new mh(n), c = typeof t.onValidate == "function", h = new ci(c), u = (y, w, b, S, T)=>!c || h.isCloning || t.onValidate(hn.concat(l.getPath(y), w), b, S, T) === !0
    , f = (y, w, b, S)=>{
        !rd(l, t, w) && !(o && l.isDetached(y, i)) && d(l.getPath(y), w, b, S);
    }, d = (y, w, b, S, T)=>{
        h.isCloning ? h.update(y, w, S) : e(hn.concat(y, w), b, S, T);
    }, p = (y)=>y && (y[r] || y)
    , m = (y, w, b, S)=>Ob(y) || b === "constructor" || s && !ci.isHandledMethod(w, b) || rd(l, t, b) || l.isGetInvariant(w, b) || o && l.isDetached(w, i) ? y : (S === void 0 && (S = l.getPath(w)), l.getProxy(y, hn.concat(S, b), g, r))
    , g = {
        get (y, w, b) {
            if (zo(w)) {
                if (w === r || w === dh) return y;
                if (w === sy && !l.isUnsubscribed && l.getPath(y).length === 0) return l.unsubscribe(), y;
            }
            let S = ph(y) ? Reflect.get(y, w) : Reflect.get(y, w, b);
            return m(S, y, w);
        },
        set (y, w, b, S) {
            b = p(b);
            let T = y[r] || y, A = T[w];
            if (n(A, b) && w in y) return !0;
            let x = u(y, w, b, A);
            return x && l.setProperty(T, w, b, S, A) ? (f(y, w, y[w], A), !0) : !x;
        },
        defineProperty (y, w, b) {
            if (!l.isSameDescriptor(b, y, w)) {
                let S = y[w];
                u(y, w, b.value, S) && l.defineProperty(y, w, b, S) && f(y, w, b.value, S);
            }
            return !0;
        },
        deleteProperty (y, w) {
            if (!Reflect.has(y, w)) return !0;
            let b = Reflect.get(y, w), S = u(y, w, void 0, b);
            return S && l.deleteProperty(y, w, b) ? (f(y, w, void 0, b), !0) : !S;
        },
        apply (y, w, b) {
            let S = w[r] || w;
            if (l.isUnsubscribed) return Reflect.apply(y, S, b);
            if ((a === !1 || a !== !0 && !a.includes(y.name)) && ci.isHandledType(S)) {
                let T = hn.initial(l.getPath(y)), A = ci.isHandledMethod(S, y.name);
                h.start(S, T, b);
                let x = Reflect.apply(y, h.preferredThisArg(y, w, S), A ? b.map((C)=>p(C)
                ) : b), E = h.isChanged(S, n), _ = h.stop();
                if (ci.isHandledType(x) && A && (w instanceof Map && y.name === "get" && (T = hn.concat(T, b[0])), x = l.getProxy(x, T, g)), E) {
                    let C = {
                        name: y.name,
                        args: b,
                        result: x
                    }, I = h.isCloning ? hn.initial(T) : T, N = h.isCloning ? hn.last(T) : "";
                    u(hn.get(i, I), N, S, _, C) ? d(I, N, S, _, C) : h.undo(S);
                }
                return (w instanceof Map || w instanceof Set) && oy(x) ? ay(x, y, w, T, m) : x;
            }
            return Reflect.apply(y, w, b);
        }
    }, v = l.getProxy(i, t.pathAsArray ? [] : "", g);
    return e = e.bind(v), c && (t.onValidate = t.onValidate.bind(v)), v;
};
dy.target = (i)=>i && i[dh] || i
;
dy.unsubscribe = (i)=>i[sy] || i
;
var py = dy;
var S2 = typeof global == "object" && global && global.Object === Object && global, id = S2;
var M2 = typeof self == "object" && self && self.Object === Object && self, A2 = id || M2 || Function("return this")(), ar = A2;
var T2 = ar.Symbol, un = T2;
var Gb = Object.prototype, E2 = Gb.hasOwnProperty, _2 = Gb.toString, xh = un ? un.toStringTag : void 0;
function C2(i) {
    var e = E2.call(i, xh), t = i[xh];
    try {
        i[xh] = void 0;
        var r = !0;
    } catch  {}
    var n = _2.call(i);
    return r && (e ? i[xh] = t : delete i[xh]), n;
}
var kb = C2;
var D2 = Object.prototype, P2 = D2.toString;
function L2(i) {
    return P2.call(i);
}
var Vb = L2;
var I2 = "[object Null]", R2 = "[object Undefined]", Hb = un ? un.toStringTag : void 0;
function B2(i) {
    return i == null ? i === void 0 ? R2 : I2 : Hb && Hb in Object(i) ? kb(i) : Vb(i);
}
var Pn = B2;
function N2(i) {
    return i != null && typeof i == "object";
}
var Kr = N2;
var O2 = "[object Symbol]";
function F2(i) {
    return typeof i == "symbol" || Kr(i) && Pn(i) == O2;
}
var Ys = F2;
function U2(i, e) {
    for(var t = -1, r = i == null ? 0 : i.length, n = Array(r); ++t < r;)n[t] = e(i[t], t, i);
    return n;
}
var sd = U2;
var z2 = Array.isArray, Vr = z2;
var G2 = 1 / 0, Wb = un ? un.prototype : void 0, jb = Wb ? Wb.toString : void 0;
function qb(i) {
    if (typeof i == "string") return i;
    if (Vr(i)) return sd(i, qb) + "";
    if (Ys(i)) return jb ? jb.call(i) : "";
    var e = i + "";
    return e == "0" && 1 / i == -G2 ? "-0" : e;
}
var Yb = qb;
var k2 = /\s/;
function V2(i) {
    for(var e = i.length; e-- && k2.test(i.charAt(e)););
    return e;
}
var Xb = V2;
var H2 = /^\s+/;
function W2(i) {
    return i && i.slice(0, Xb(i) + 1).replace(H2, "");
}
var Qb = W2;
function j2(i) {
    var e = typeof i;
    return i != null && (e == "object" || e == "function");
}
var fr = j2;
var Jb = 0 / 0, q2 = /^[-+]0x[0-9a-f]+$/i, Y2 = /^0b[01]+$/i, X2 = /^0o[0-7]+$/i, Q2 = parseInt;
function J2(i) {
    if (typeof i == "number") return i;
    if (Ys(i)) return Jb;
    if (fr(i)) {
        var e = typeof i.valueOf == "function" ? i.valueOf() : i;
        i = fr(e) ? e + "" : e;
    }
    if (typeof i != "string") return i === 0 ? i : +i;
    i = Qb(i);
    var t = Y2.test(i);
    return t || X2.test(i) ? Q2(i.slice(2), t ? 2 : 8) : q2.test(i) ? Jb : +i;
}
var my = J2;
function K2(i) {
    return i;
}
var od = K2;
var Z2 = "[object AsyncFunction]", $2 = "[object Function]", eI = "[object GeneratorFunction]", tI = "[object Proxy]";
function rI(i) {
    if (!fr(i)) return !1;
    var e = Pn(i);
    return e == $2 || e == eI || e == Z2 || e == tI;
}
var il = rI;
var nI = ar["__core-js_shared__"], ad = nI;
var Kb = function() {
    var i = /[^.]+$/.exec(ad && ad.keys && ad.keys.IE_PROTO || "");
    return i ? "Symbol(src)_1." + i : "";
}();
function iI(i) {
    return !!Kb && Kb in i;
}
var Zb = iI;
var sI = Function.prototype, oI = sI.toString;
function aI(i) {
    if (i != null) {
        try {
            return oI.call(i);
        } catch  {}
        try {
            return i + "";
        } catch  {}
    }
    return "";
}
var ls = aI;
var lI = /[\\^$.*+?()[\]{}|]/g, cI = /^\[object .+?Constructor\]$/, hI = Function.prototype, uI = Object.prototype, fI = hI.toString, dI = uI.hasOwnProperty, pI = RegExp("^" + fI.call(dI).replace(lI, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function mI(i) {
    if (!fr(i) || Zb(i)) return !1;
    var e = il(i) ? pI : cI;
    return e.test(ls(i));
}
var $b = mI;
function gI(i, e) {
    return i == null ? void 0 : i[e];
}
var ew = gI;
function yI(i, e) {
    var t = ew(i, e);
    return $b(t) ? t : void 0;
}
var wn = yI;
var vI = wn(ar, "WeakMap"), ld = vI;
var tw = Object.create, xI = function() {
    function i() {}
    return function(e) {
        if (!fr(e)) return {};
        if (tw) return tw(e);
        i.prototype = e;
        var t = new i;
        return i.prototype = void 0, t;
    };
}(), rw = xI;
function bI(i, e, t) {
    switch(t.length){
        case 0:
            return i.call(e);
        case 1:
            return i.call(e, t[0]);
        case 2:
            return i.call(e, t[0], t[1]);
        case 3:
            return i.call(e, t[0], t[1], t[2]);
    }
    return i.apply(e, t);
}
var nw = bI;
function wI(i, e) {
    var t = -1, r = i.length;
    for(e || (e = Array(r)); ++t < r;)e[t] = i[t];
    return e;
}
var cd = wI;
var SI = 800, MI = 16, AI = Date.now;
function TI(i) {
    var e = 0, t = 0;
    return function() {
        var r = AI(), n = MI - (r - t);
        if (t = r, n > 0) {
            if (++e >= SI) return arguments[0];
        } else e = 0;
        return i.apply(void 0, arguments);
    };
}
var iw = TI;
function EI(i) {
    return function() {
        return i;
    };
}
var sw = EI;
var _I = function() {
    try {
        var i = wn(Object, "defineProperty");
        return i({}, "", {}), i;
    } catch  {}
}(), sl = _I;
var CI = sl ? function(i, e) {
    return sl(i, "toString", {
        configurable: !0,
        enumerable: !1,
        value: sw(e),
        writable: !0
    });
} : od, ow = CI;
var DI = iw(ow), hd = DI;
function PI(i, e) {
    for(var t = -1, r = i == null ? 0 : i.length; ++t < r && e(i[t], t, i) !== !1;);
    return i;
}
var aw = PI;
var LI = 9007199254740991, II = /^(?:0|[1-9]\d*)$/;
function RI(i, e) {
    var t = typeof i;
    return e = e == null ? LI : e, !!e && (t == "number" || t != "symbol" && II.test(i)) && i > -1 && i % 1 == 0 && i < e;
}
var ud = RI;
function BI(i, e, t) {
    e == "__proto__" && sl ? sl(i, e, {
        configurable: !0,
        enumerable: !0,
        value: t,
        writable: !0
    }) : i[e] = t;
}
var ol = BI;
function NI(i, e) {
    return i === e || i !== i && e !== e;
}
var Xs = NI;
var OI = Object.prototype, FI = OI.hasOwnProperty;
function UI(i, e, t) {
    var r = i[e];
    (!(FI.call(i, e) && Xs(r, t)) || t === void 0 && !(e in i)) && ol(i, e, t);
}
var fd = UI;
function zI(i, e, t, r) {
    var n = !t;
    t || (t = {});
    for(var s = -1, o = e.length; ++s < o;){
        var a = e[s], l = r ? r(t[a], i[a], a, t, i) : void 0;
        l === void 0 && (l = i[a]), n ? ol(t, a, l) : fd(t, a, l);
    }
    return t;
}
var Wn = zI;
var lw = Math.max;
function GI(i, e, t) {
    return e = lw(e === void 0 ? i.length - 1 : e, 0), function() {
        for(var r = arguments, n = -1, s = lw(r.length - e, 0), o = Array(s); ++n < s;)o[n] = r[e + n];
        n = -1;
        for(var a = Array(e + 1); ++n < e;)a[n] = r[n];
        return a[e] = t(o), nw(i, this, a);
    };
}
var dd = GI;
function kI(i, e) {
    return hd(dd(i, e, od), i + "");
}
var cw = kI;
var VI = 9007199254740991;
function HI(i) {
    return typeof i == "number" && i > -1 && i % 1 == 0 && i <= VI;
}
var pd = HI;
function WI(i) {
    return i != null && pd(i.length) && !il(i);
}
var Qs = WI;
function jI(i, e, t) {
    if (!fr(t)) return !1;
    var r = typeof e;
    return (r == "number" ? Qs(t) && ud(e, t.length) : r == "string" && e in t) ? Xs(t[e], i) : !1;
}
var hw = jI;
function qI(i) {
    return cw(function(e, t) {
        var r = -1, n = t.length, s = n > 1 ? t[n - 1] : void 0, o = n > 2 ? t[2] : void 0;
        for(s = i.length > 3 && typeof s == "function" ? (n--, s) : void 0, o && hw(t[0], t[1], o) && (s = n < 3 ? void 0 : s, n = 1), e = Object(e); ++r < n;){
            var a = t[r];
            a && i(e, a, r, s);
        }
        return e;
    });
}
var uw = qI;
var YI = Object.prototype;
function XI(i) {
    var e = i && i.constructor, t = typeof e == "function" && e.prototype || YI;
    return i === t;
}
var al = XI;
function QI(i, e) {
    for(var t = -1, r = Array(i); ++t < i;)r[t] = e(t);
    return r;
}
var fw = QI;
var JI = "[object Arguments]";
function KI(i) {
    return Kr(i) && Pn(i) == JI;
}
var gy = KI;
var dw = Object.prototype, ZI = dw.hasOwnProperty, $I = dw.propertyIsEnumerable, eR = gy(function() {
    return arguments;
}()) ? gy : function(i) {
    return Kr(i) && ZI.call(i, "callee") && !$I.call(i, "callee");
}, Go = eR;
function tR() {
    return !1;
}
var pw = tR;
var yw = exports && !exports.nodeType && exports, mw = yw && true && module && !module.nodeType && module, rR = mw && mw.exports === yw, gw = rR ? ar.Buffer : void 0, nR = gw ? gw.isBuffer : void 0, iR = nR || pw, ll = iR;
var sR = "[object Arguments]", oR = "[object Array]", aR = "[object Boolean]", lR = "[object Date]", cR = "[object Error]", hR = "[object Function]", uR = "[object Map]", fR = "[object Number]", dR = "[object Object]", pR = "[object RegExp]", mR = "[object Set]", gR = "[object String]", yR = "[object WeakMap]", vR = "[object ArrayBuffer]", xR = "[object DataView]", bR = "[object Float32Array]", wR = "[object Float64Array]", SR = "[object Int8Array]", MR = "[object Int16Array]", AR = "[object Int32Array]", TR = "[object Uint8Array]", ER = "[object Uint8ClampedArray]", _R = "[object Uint16Array]", CR = "[object Uint32Array]", Xt = {};
Xt[bR] = Xt[wR] = Xt[SR] = Xt[MR] = Xt[AR] = Xt[TR] = Xt[ER] = Xt[_R] = Xt[CR] = !0;
Xt[sR] = Xt[oR] = Xt[vR] = Xt[aR] = Xt[xR] = Xt[lR] = Xt[cR] = Xt[hR] = Xt[uR] = Xt[fR] = Xt[dR] = Xt[pR] = Xt[mR] = Xt[gR] = Xt[yR] = !1;
function DR(i) {
    return Kr(i) && pd(i.length) && !!Xt[Pn(i)];
}
var vw = DR;
function PR(i) {
    return function(e) {
        return i(e);
    };
}
var cl = PR;
var xw = exports && !exports.nodeType && exports, bh = xw && true && module && !module.nodeType && module, LR = bh && bh.exports === xw, yy = LR && id.process, IR = function() {
    try {
        var i = bh && bh.require && bh.require("util").types;
        return i || yy && yy.binding && yy.binding("util");
    } catch  {}
}(), cs = IR;
var bw = cs && cs.isTypedArray, RR = bw ? cl(bw) : vw, md = RR;
var BR = Object.prototype, NR = BR.hasOwnProperty;
function OR(i, e) {
    var t = Vr(i), r = !t && Go(i), n = !t && !r && ll(i), s = !t && !r && !n && md(i), o = t || r || n || s, a = o ? fw(i.length, String) : [], l = a.length;
    for(var c in i)(e || NR.call(i, c)) && !(o && (c == "length" || n && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || ud(c, l))) && a.push(c);
    return a;
}
var gd = OR;
function FR(i, e) {
    return function(t) {
        return i(e(t));
    };
}
var yd = FR;
var UR = yd(Object.keys, Object), ww = UR;
var zR = Object.prototype, GR = zR.hasOwnProperty;
function kR(i) {
    if (!al(i)) return ww(i);
    var e = [];
    for(var t in Object(i))GR.call(i, t) && t != "constructor" && e.push(t);
    return e;
}
var Sw = kR;
function VR(i) {
    return Qs(i) ? gd(i) : Sw(i);
}
var hl = VR;
function HR(i) {
    var e = [];
    if (i != null) for(var t in Object(i))e.push(t);
    return e;
}
var Mw = HR;
var WR = Object.prototype, jR = WR.hasOwnProperty;
function qR(i) {
    if (!fr(i)) return Mw(i);
    var e = al(i), t = [];
    for(var r in i)r == "constructor" && (e || !jR.call(i, r)) || t.push(r);
    return t;
}
var Aw = qR;
function YR(i) {
    return Qs(i) ? gd(i, !0) : Aw(i);
}
var Di = YR;
var XR = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, QR = /^\w*$/;
function JR(i, e) {
    if (Vr(i)) return !1;
    var t = typeof i;
    return t == "number" || t == "symbol" || t == "boolean" || i == null || Ys(i) ? !0 : QR.test(i) || !XR.test(i) || e != null && i in Object(e);
}
var Tw = JR;
var KR = wn(Object, "create"), hs = KR;
function ZR() {
    this.__data__ = hs ? hs(null) : {}, this.size = 0;
}
var Ew = ZR;
function $R(i) {
    var e = this.has(i) && delete this.__data__[i];
    return this.size -= e ? 1 : 0, e;
}
var _w = $R;
var eB = "__lodash_hash_undefined__", tB = Object.prototype, rB = tB.hasOwnProperty;
function nB(i) {
    var e = this.__data__;
    if (hs) {
        var t = e[i];
        return t === eB ? void 0 : t;
    }
    return rB.call(e, i) ? e[i] : void 0;
}
var Cw = nB;
var iB = Object.prototype, sB = iB.hasOwnProperty;
function oB(i) {
    var e = this.__data__;
    return hs ? e[i] !== void 0 : sB.call(e, i);
}
var Dw = oB;
var aB = "__lodash_hash_undefined__";
function lB(i, e) {
    var t = this.__data__;
    return this.size += this.has(i) ? 0 : 1, t[i] = hs && e === void 0 ? aB : e, this;
}
var Pw = lB;
function ul(i) {
    var e = -1, t = i == null ? 0 : i.length;
    for(this.clear(); ++e < t;){
        var r = i[e];
        this.set(r[0], r[1]);
    }
}
ul.prototype.clear = Ew;
ul.prototype.delete = _w;
ul.prototype.get = Cw;
ul.prototype.has = Dw;
ul.prototype.set = Pw;
var vy = ul;
function cB() {
    this.__data__ = [], this.size = 0;
}
var Lw = cB;
function hB(i, e) {
    for(var t = i.length; t--;)if (Xs(i[t][0], e)) return t;
    return -1;
}
var Js = hB;
var uB = Array.prototype, fB = uB.splice;
function dB(i) {
    var e = this.__data__, t = Js(e, i);
    if (t < 0) return !1;
    var r = e.length - 1;
    return t == r ? e.pop() : fB.call(e, t, 1), --this.size, !0;
}
var Iw = dB;
function pB(i) {
    var e = this.__data__, t = Js(e, i);
    return t < 0 ? void 0 : e[t][1];
}
var Rw = pB;
function mB(i) {
    return Js(this.__data__, i) > -1;
}
var Bw = mB;
function gB(i, e) {
    var t = this.__data__, r = Js(t, i);
    return r < 0 ? (++this.size, t.push([
        i,
        e
    ])) : t[r][1] = e, this;
}
var Nw = gB;
function fl(i) {
    var e = -1, t = i == null ? 0 : i.length;
    for(this.clear(); ++e < t;){
        var r = i[e];
        this.set(r[0], r[1]);
    }
}
fl.prototype.clear = Lw;
fl.prototype.delete = Iw;
fl.prototype.get = Rw;
fl.prototype.has = Bw;
fl.prototype.set = Nw;
var Ks = fl;
var yB = wn(ar, "Map"), Zs = yB;
function vB() {
    this.size = 0, this.__data__ = {
        hash: new vy,
        map: new (Zs || Ks),
        string: new vy
    };
}
var Ow = vB;
function xB(i) {
    var e = typeof i;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? i !== "__proto__" : i === null;
}
var Fw = xB;
function bB(i, e) {
    var t = i.__data__;
    return Fw(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
var $s = bB;
function wB(i) {
    var e = $s(this, i).delete(i);
    return this.size -= e ? 1 : 0, e;
}
var Uw = wB;
function SB(i) {
    return $s(this, i).get(i);
}
var zw = SB;
function MB(i) {
    return $s(this, i).has(i);
}
var Gw = MB;
function AB(i, e) {
    var t = $s(this, i), r = t.size;
    return t.set(i, e), this.size += t.size == r ? 0 : 1, this;
}
var kw = AB;
function dl(i) {
    var e = -1, t = i == null ? 0 : i.length;
    for(this.clear(); ++e < t;){
        var r = i[e];
        this.set(r[0], r[1]);
    }
}
dl.prototype.clear = Ow;
dl.prototype.delete = Uw;
dl.prototype.get = zw;
dl.prototype.has = Gw;
dl.prototype.set = kw;
var wh = dl;
var TB = "Expected a function";
function xy(i, e) {
    if (typeof i != "function" || e != null && typeof e != "function") throw new TypeError(TB);
    var t = function() {
        var r = arguments, n = e ? e.apply(this, r) : r[0], s = t.cache;
        if (s.has(n)) return s.get(n);
        var o = i.apply(this, r);
        return t.cache = s.set(n, o) || s, o;
    };
    return t.cache = new (xy.Cache || wh), t;
}
xy.Cache = wh;
var Vw = xy;
var EB = 500;
function _B(i) {
    var e = Vw(i, function(r) {
        return t.size === EB && t.clear(), r;
    }), t = e.cache;
    return e;
}
var Hw = _B;
var CB = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, DB = /\\(\\)?/g, PB = Hw(function(i) {
    var e = [];
    return i.charCodeAt(0) === 46 && e.push(""), i.replace(CB, function(t, r, n, s) {
        e.push(n ? s.replace(DB, "$1") : r || t);
    }), e;
}), Ww = PB;
function LB(i) {
    return i == null ? "" : Yb(i);
}
var jw = LB;
function IB(i, e) {
    return Vr(i) ? i : Tw(i, e) ? [
        i
    ] : Ww(jw(i));
}
var pl = IB;
var RB = 1 / 0;
function BB(i) {
    if (typeof i == "string" || Ys(i)) return i;
    var e = i + "";
    return e == "0" && 1 / i == -RB ? "-0" : e;
}
var vd = BB;
function NB(i, e) {
    e = pl(e, i);
    for(var t = 0, r = e.length; i != null && t < r;)i = i[vd(e[t++])];
    return t && t == r ? i : void 0;
}
var qw = NB;
function OB(i, e) {
    for(var t = -1, r = e.length, n = i.length; ++t < r;)i[n + t] = e[t];
    return i;
}
var ml = OB;
var Yw = un ? un.isConcatSpreadable : void 0;
function FB(i) {
    return Vr(i) || Go(i) || !!(Yw && i && i[Yw]);
}
var Xw = FB;
function Qw(i, e, t, r, n) {
    var s = -1, o = i.length;
    for(t || (t = Xw), n || (n = []); ++s < o;){
        var a = i[s];
        e > 0 && t(a) ? e > 1 ? Qw(a, e - 1, t, r, n) : ml(n, a) : r || (n[n.length] = a);
    }
    return n;
}
var Jw = Qw;
function UB(i) {
    var e = i == null ? 0 : i.length;
    return e ? Jw(i, 1) : [];
}
var Kw = UB;
function zB(i) {
    return hd(dd(i, void 0, Kw), i + "");
}
var Zw = zB;
var GB = yd(Object.getPrototypeOf, Object), gl = GB;
var kB = "[object Object]", VB = Function.prototype, HB = Object.prototype, $w = VB.toString, WB = HB.hasOwnProperty, jB = $w.call(Object);
function qB(i) {
    if (!Kr(i) || Pn(i) != kB) return !1;
    var e = gl(i);
    if (e === null) return !0;
    var t = WB.call(e, "constructor") && e.constructor;
    return typeof t == "function" && t instanceof t && $w.call(t) == jB;
}
var xd = qB;
function YB(i, e, t) {
    var r = -1, n = i.length;
    e < 0 && (e = -e > n ? 0 : n + e), t = t > n ? n : t, t < 0 && (t += n), n = e > t ? 0 : t - e >>> 0, e >>>= 0;
    for(var s = Array(n); ++r < n;)s[r] = i[r + e];
    return s;
}
var eS = YB;
function XB() {
    this.__data__ = new Ks, this.size = 0;
}
var tS = XB;
function QB(i) {
    var e = this.__data__, t = e.delete(i);
    return this.size = e.size, t;
}
var rS = QB;
function JB(i) {
    return this.__data__.get(i);
}
var nS = JB;
function KB(i) {
    return this.__data__.has(i);
}
var iS = KB;
var ZB = 200;
function $B(i, e) {
    var t = this.__data__;
    if (t instanceof Ks) {
        var r = t.__data__;
        if (!Zs || r.length < ZB - 1) return r.push([
            i,
            e
        ]), this.size = ++t.size, this;
        t = this.__data__ = new wh(r);
    }
    return t.set(i, e), this.size = t.size, this;
}
var sS = $B;
function yl(i) {
    var e = this.__data__ = new Ks(i);
    this.size = e.size;
}
yl.prototype.clear = tS;
yl.prototype.delete = rS;
yl.prototype.get = nS;
yl.prototype.has = iS;
yl.prototype.set = sS;
var bd = yl;
function eN(i, e) {
    return i && Wn(e, hl(e), i);
}
var oS = eN;
function tN(i, e) {
    return i && Wn(e, Di(e), i);
}
var aS = tN;
var uS = exports && !exports.nodeType && exports, lS = uS && true && module && !module.nodeType && module, rN = lS && lS.exports === uS, cS = rN ? ar.Buffer : void 0, hS = cS ? cS.allocUnsafe : void 0;
function nN(i, e) {
    if (e) return i.slice();
    var t = i.length, r = hS ? hS(t) : new i.constructor(t);
    return i.copy(r), r;
}
var wd = nN;
function iN(i, e) {
    for(var t = -1, r = i == null ? 0 : i.length, n = 0, s = []; ++t < r;){
        var o = i[t];
        e(o, t, i) && (s[n++] = o);
    }
    return s;
}
var fS = iN;
function sN() {
    return [];
}
var Sd = sN;
var oN = Object.prototype, aN = oN.propertyIsEnumerable, dS = Object.getOwnPropertySymbols, lN = dS ? function(i) {
    return i == null ? [] : (i = Object(i), fS(dS(i), function(e) {
        return aN.call(i, e);
    }));
} : Sd, vl = lN;
function cN(i, e) {
    return Wn(i, vl(i), e);
}
var pS = cN;
var hN = Object.getOwnPropertySymbols, uN = hN ? function(i) {
    for(var e = []; i;)ml(e, vl(i)), i = gl(i);
    return e;
} : Sd, Md = uN;
function fN(i, e) {
    return Wn(i, Md(i), e);
}
var mS = fN;
function dN(i, e, t) {
    var r = e(i);
    return Vr(i) ? r : ml(r, t(i));
}
var Ad = dN;
function pN(i) {
    return Ad(i, hl, vl);
}
var gS = pN;
function mN(i) {
    return Ad(i, Di, Md);
}
var Td = mN;
var gN = wn(ar, "DataView"), Ed = gN;
var yN = wn(ar, "Promise"), _d = yN;
var vN = wn(ar, "Set"), Cd = vN;
var yS = "[object Map]", xN = "[object Object]", vS = "[object Promise]", xS = "[object Set]", bS = "[object WeakMap]", wS = "[object DataView]", bN = ls(Ed), wN = ls(Zs), SN = ls(_d), MN = ls(Cd), AN = ls(ld), ko = Pn;
(Ed && ko(new Ed(new ArrayBuffer(1))) != wS || Zs && ko(new Zs) != yS || _d && ko(_d.resolve()) != vS || Cd && ko(new Cd) != xS || ld && ko(new ld) != bS) && (ko = function(i) {
    var e = Pn(i), t = e == xN ? i.constructor : void 0, r = t ? ls(t) : "";
    if (r) switch(r){
        case bN:
            return wS;
        case wN:
            return yS;
        case SN:
            return vS;
        case MN:
            return xS;
        case AN:
            return bS;
    }
    return e;
});
var xl = ko;
var TN = Object.prototype, EN = TN.hasOwnProperty;
function _N(i) {
    var e = i.length, t = new i.constructor(e);
    return e && typeof i[0] == "string" && EN.call(i, "index") && (t.index = i.index, t.input = i.input), t;
}
var SS = _N;
var CN = ar.Uint8Array, by = CN;
function DN(i) {
    var e = new i.constructor(i.byteLength);
    return new by(e).set(new by(i)), e;
}
var bl = DN;
function PN(i, e) {
    var t = e ? bl(i.buffer) : i.buffer;
    return new i.constructor(t, i.byteOffset, i.byteLength);
}
var MS = PN;
var LN = /\w*$/;
function IN(i) {
    var e = new i.constructor(i.source, LN.exec(i));
    return e.lastIndex = i.lastIndex, e;
}
var AS = IN;
var TS = un ? un.prototype : void 0, ES = TS ? TS.valueOf : void 0;
function RN(i) {
    return ES ? Object(ES.call(i)) : {};
}
var _S = RN;
function BN(i, e) {
    var t = e ? bl(i.buffer) : i.buffer;
    return new i.constructor(t, i.byteOffset, i.length);
}
var Dd = BN;
var NN = "[object Boolean]", ON = "[object Date]", FN = "[object Map]", UN = "[object Number]", zN = "[object RegExp]", GN = "[object Set]", kN = "[object String]", VN = "[object Symbol]", HN = "[object ArrayBuffer]", WN = "[object DataView]", jN = "[object Float32Array]", qN = "[object Float64Array]", YN = "[object Int8Array]", XN = "[object Int16Array]", QN = "[object Int32Array]", JN = "[object Uint8Array]", KN = "[object Uint8ClampedArray]", ZN = "[object Uint16Array]", $N = "[object Uint32Array]";
function e3(i, e, t) {
    var r = i.constructor;
    switch(e){
        case HN:
            return bl(i);
        case NN:
        case ON:
            return new r(+i);
        case WN:
            return MS(i, t);
        case jN:
        case qN:
        case YN:
        case XN:
        case QN:
        case JN:
        case KN:
        case ZN:
        case $N:
            return Dd(i, t);
        case FN:
            return new r;
        case UN:
        case kN:
            return new r(i);
        case zN:
            return AS(i);
        case GN:
            return new r;
        case VN:
            return _S(i);
    }
}
var CS = e3;
function t3(i) {
    return typeof i.constructor == "function" && !al(i) ? rw(gl(i)) : {};
}
var Pd = t3;
var r3 = "[object Map]";
function n3(i) {
    return Kr(i) && xl(i) == r3;
}
var DS = n3;
var PS = cs && cs.isMap, i311 = PS ? cl(PS) : DS, LS = i311;
var s3 = "[object Set]";
function o3(i) {
    return Kr(i) && xl(i) == s3;
}
var IS = o3;
var RS = cs && cs.isSet, a3 = RS ? cl(RS) : IS, BS = a3;
var l3 = 1, c3 = 2, h3 = 4, NS = "[object Arguments]", u3 = "[object Array]", f3 = "[object Boolean]", d3 = "[object Date]", p3 = "[object Error]", OS = "[object Function]", m3 = "[object GeneratorFunction]", g3 = "[object Map]", y3 = "[object Number]", FS = "[object Object]", v3 = "[object RegExp]", x3 = "[object Set]", b3 = "[object String]", w3 = "[object Symbol]", S3 = "[object WeakMap]", M3 = "[object ArrayBuffer]", A3 = "[object DataView]", T3 = "[object Float32Array]", E3 = "[object Float64Array]", _3 = "[object Int8Array]", C3 = "[object Int16Array]", D3 = "[object Int32Array]", P3 = "[object Uint8Array]", L3 = "[object Uint8ClampedArray]", I3 = "[object Uint16Array]", R3 = "[object Uint32Array]", Wt = {};
Wt[NS] = Wt[u3] = Wt[M3] = Wt[A3] = Wt[f3] = Wt[d3] = Wt[T3] = Wt[E3] = Wt[_3] = Wt[C3] = Wt[D3] = Wt[g3] = Wt[y3] = Wt[FS] = Wt[v3] = Wt[x3] = Wt[b3] = Wt[w3] = Wt[P3] = Wt[L3] = Wt[I3] = Wt[R3] = !0;
Wt[p3] = Wt[OS] = Wt[S3] = !1;
function Ld(i, e, t, r, n, s) {
    var o, a = e & l3, l = e & c3, c = e & h3;
    if (t && (o = n ? t(i, r, n, s) : t(i)), o !== void 0) return o;
    if (!fr(i)) return i;
    var h = Vr(i);
    if (h) {
        if (o = SS(i), !a) return cd(i, o);
    } else {
        var u = xl(i), f = u == OS || u == m3;
        if (ll(i)) return wd(i, a);
        if (u == FS || u == NS || f && !n) {
            if (o = l || f ? {} : Pd(i), !a) return l ? mS(i, aS(o, i)) : pS(i, oS(o, i));
        } else {
            if (!Wt[u]) return n ? i : {};
            o = CS(i, u, a);
        }
    }
    s || (s = new bd);
    var d = s.get(i);
    if (d) return d;
    s.set(i, o), BS(i) ? i.forEach(function(g) {
        o.add(Ld(g, e, t, g, i, s));
    }) : LS(i) && i.forEach(function(g, v) {
        o.set(v, Ld(g, e, t, v, i, s));
    });
    var p = c ? l ? Td : gS : l ? Di : hl, m = h ? void 0 : p(i);
    return aw(m || i, function(g, v) {
        m && (v = g, g = i[v]), fd(o, v, Ld(g, e, t, v, i, s));
    }), o;
}
var Id = Ld;
var B3 = 1, N3 = 4;
function O3(i) {
    return Id(i, B3 | N3);
}
var Sh = O3;
function F3(i) {
    return function(e, t, r) {
        for(var n = -1, s = Object(e), o = r(e), a = o.length; a--;){
            var l = o[i ? a : ++n];
            if (t(s[l], l, s) === !1) break;
        }
        return e;
    };
}
var US = F3;
var U3 = US(), zS = U3;
var z3 = function() {
    return ar.Date.now();
}, Rd = z3;
var G3 = "Expected a function", k3 = Math.max, V3 = Math.min;
function H3(i, e, t) {
    var r, n, s, o, a, l, c = 0, h = !1, u = !1, f = !0;
    if (typeof i != "function") throw new TypeError(G3);
    e = my(e) || 0, fr(t) && (h = !!t.leading, u = "maxWait" in t, s = u ? k3(my(t.maxWait) || 0, e) : s, f = "trailing" in t ? !!t.trailing : f);
    function d(T) {
        var A = r, x = n;
        return r = n = void 0, c = T, o = i.apply(x, A), o;
    }
    function p(T) {
        return c = T, a = setTimeout(v, e), h ? d(T) : o;
    }
    function m(T) {
        var A = T - l, x = T - c, E = e - A;
        return u ? V3(E, s - x) : E;
    }
    function g(T) {
        var A = T - l, x = T - c;
        return l === void 0 || A >= e || A < 0 || u && x >= s;
    }
    function v() {
        var T = Rd();
        if (g(T)) return y(T);
        a = setTimeout(v, m(T));
    }
    function y(T) {
        return a = void 0, f && r ? d(T) : (r = n = void 0, o);
    }
    function w() {
        a !== void 0 && clearTimeout(a), c = 0, r = l = n = a = void 0;
    }
    function b() {
        return a === void 0 ? o : y(Rd());
    }
    function S() {
        var T = Rd(), A = g(T);
        if (r = arguments, n = this, l = T, A) {
            if (a === void 0) return p(l);
            if (u) return clearTimeout(a), a = setTimeout(v, e), d(l);
        }
        return a === void 0 && (a = setTimeout(v, e)), o;
    }
    return S.cancel = w, S.flush = b, S;
}
var Mh = H3;
function W3(i, e, t) {
    (t !== void 0 && !Xs(i[e], t) || t === void 0 && !(e in i)) && ol(i, e, t);
}
var Ah = W3;
function j3(i) {
    return Kr(i) && Qs(i);
}
var GS = j3;
function q3(i, e) {
    if (!(e === "constructor" && typeof i[e] == "function") && e != "__proto__") return i[e];
}
var Th = q3;
function Y3(i) {
    return Wn(i, Di(i));
}
var kS = Y3;
function X3(i, e, t, r, n, s, o) {
    var a = Th(i, t), l = Th(e, t), c = o.get(l);
    if (c) {
        Ah(i, t, c);
        return;
    }
    var h = s ? s(a, l, t + "", i, e, o) : void 0, u = h === void 0;
    if (u) {
        var f = Vr(l), d = !f && ll(l), p = !f && !d && md(l);
        h = l, f || d || p ? Vr(a) ? h = a : GS(a) ? h = cd(a) : d ? (u = !1, h = wd(l, !0)) : p ? (u = !1, h = Dd(l, !0)) : h = [] : xd(l) || Go(l) ? (h = a, Go(a) ? h = kS(a) : (!fr(a) || il(a)) && (h = Pd(l))) : u = !1;
    }
    u && (o.set(l, h), n(h, l, r, s, o), o.delete(l)), Ah(i, t, h);
}
var VS = X3;
function HS(i, e, t, r, n) {
    i !== e && zS(e, function(s, o) {
        if (n || (n = new bd), fr(s)) VS(i, e, o, t, HS, r, n);
        else {
            var a = r ? r(Th(i, o), s, o + "", i, e, n) : void 0;
            a === void 0 && (a = s), Ah(i, o, a);
        }
    }, Di);
}
var WS = HS;
function Q3(i) {
    var e = i == null ? 0 : i.length;
    return e ? i[e - 1] : void 0;
}
var jS = Q3;
function J3(i, e) {
    return e.length < 2 ? i : qw(i, eS(e, 0, -1));
}
var qS = J3;
var K3 = uw(function(i, e, t) {
    WS(i, e, t);
}), Vo = K3;
function Z3(i, e) {
    return e = pl(e, i), i = qS(i, e), i == null || delete i[vd(jS(e))];
}
var YS = Z3;
function $3(i) {
    return xd(i) ? void 0 : i;
}
var XS = $3;
var eO = 1, tO = 2, rO = 4, nO = Zw(function(i, e) {
    var t = {};
    if (i == null) return t;
    var r = !1;
    e = sd(e, function(s) {
        return s = pl(s, i), r || (r = s.length > 1), s;
    }), Wn(i, Td(i), t), r && (t = Id(t, eO | tO | rO, XS));
    for(var n = e.length; n--;)YS(t, e[n]);
    return t;
}), wl = nO;
var QS = (i)=>new Promise((e)=>setTimeout(e, i)
    )
;
var iO = ()=>typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().includes(" electron/")
, sO = ()=>typeof window > "u" ? !1 : window.navigator.platform.toUpperCase().includes("MAC")
, oO = ()=>typeof window > "u" ? !1 : /iPad|iPhone|iPod/.test(window.navigator.userAgent) || Eh && "ontouchend" in document
, aO = ()=>typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1
, lO = ()=>typeof window > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0
, cO = ()=>{
    let i = navigator.userAgent, e = navigator.vendor;
    return /Safari/i.test(i) && /Apple Computer/.test(e);
}, e9 = iO(), Eh = sO(), Ho = oO(), JS = aO(), Bd = lO(), KS = cO();
function ZS(i) {
    return Array.isArray(i) ? i : [
        i
    ];
}
function _h(i) {
    return Eh ? i.metaKey : i.ctrlKey;
}
var eo;
((t)=>{
    t.all = [
        "PerspectiveCamera",
        "OrthographicCamera"
    ];
    function e(r) {
        return t.all.includes(r);
    }
    t.is = e;
})(eo || (eo = {}));
var Wo;
((n)=>{
    n.DefaultUp = [
        0,
        1,
        0
    ], n.DefaultTargetOffset = 1e3, n.defaultData = {
        far: 1e5,
        type: "OrthographicCamera",
        perspective: {
            near: 5,
            fov: 45,
            zoom: 1
        },
        orthographic: {
            near: -100000,
            zoom: 1
        },
        up: n.DefaultUp,
        isUpVectorFlipped: !1,
        targetOffset: n.DefaultTargetOffset
    };
    function r(s) {
        return s.type === "PerspectiveCamera" ? s.perspective.zoom : s.orthographic.zoom;
    }
    n.getZoom = r;
})(Wo || (Wo = {}));
var us;
((t)=>{
    function i(r, n) {
        return r[0] === n[0] && r[1] === n[1];
    }
    t.isEqual = i;
    function e(r, n, s) {
        return [
            r[0] + (n[0] - r[0]) * s,
            r[1] + (n[1] - r[1]) * s
        ];
    }
    t.lerp = e;
})(us || (us = {}));
var br;
((n)=>{
    function i(s, o) {
        return s[0] === o[0] && s[1] === o[1] && s[2] === o[2];
    }
    n.isEqual = i;
    function e(s, o) {
        return [
            s[0] + o[0],
            s[1] + o[1],
            s[2] + o[2]
        ];
    }
    n.add = e;
    function t(s, o) {
        return [
            s[0] - o[0],
            s[1] - o[1],
            s[2] - o[2]
        ];
    }
    n.sub = t;
    function r(s, o, a) {
        return [
            s[0] + (o[0] - s[0]) * a,
            s[1] + (o[1] - s[1]) * a,
            s[2] + (o[2] - s[2]) * a
        ];
    }
    n.lerp = r;
})(br || (br = {}));
var Ch;
((t)=>{
    function i(r, n) {
        return r[0] === n[0] && r[1] === n[1] && r[2] === n[2] && r[3] === n[3];
    }
    t.isEqual = i;
    function e(r, n, s) {
        return [
            r[0] + (n[0] - r[0]) * s,
            r[1] + (n[1] - r[1]) * s,
            r[2] + (n[2] - r[2]) * s,
            r[3] + (n[3] - r[3]) * s
        ];
    }
    t.lerp = e;
})(Ch || (Ch = {}));
var Pi;
((n)=>{
    n.identity = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
    function e(s, o) {
        for(let a = 0; a < 16; a++)if (s[a] !== o[a]) return !1;
        return !0;
    }
    n.isEqual = e;
    function t(s) {
        return s != null ? s : n.identity;
    }
    n.simplify = t;
    function r(s, o) {
        let a = o.slice(0);
        for(var l = 0, c = o.length; l < c; l += 3){
            let h = s[3] * o[l] + s[7] * o[l + 1] + s[11] * o[l + 2] + s[15];
            a[l] = (s[0] * o[l] + s[4] * o[l + 1] + s[8] * o[l + 2] + s[12]) / h, a[l + 1] = (s[1] * o[l] + s[5] * o[l + 1] + s[9] * o[l + 2] + s[13]) / h, a[l + 2] = (s[2] * o[l] + s[6] * o[l + 1] + s[10] * o[l + 2] + s[14]) / h;
        }
        return a;
    }
    n.applyMatrix4 = r;
})(Pi || (Pi = {}));
var Ar;
((l)=>{
    l.white = {
        r: 1,
        g: 1,
        b: 1
    }, l.red = {
        r: 1,
        g: 0,
        b: 0
    }, l.black = {
        r: 0,
        g: 0,
        b: 0
    };
    function r(c) {
        return {
            r: Math.round(c.r * 255),
            g: Math.round(c.g * 255),
            b: Math.round(c.b * 255),
            a: 1
        };
    }
    l.toRgb255a1 = r;
    function n(c) {
        return {
            r: c.r,
            g: c.g,
            b: c.b
        };
    }
    l.clone = n;
    function s(c) {
        return c = Math.floor(c), {
            r: (c >> 16 & 255) / 255,
            g: (c >> 8 & 255) / 255,
            b: (c & 255) / 255
        };
    }
    l.fromHex = s;
    function o(c, h) {
        return c.r === h.r && c.g === h.g && c.b === h.b;
    }
    l.equals = o;
    function a(c, h, u) {
        return {
            r: c.r + (h.r - c.r) * u,
            g: c.g + (h.g - c.g) * u,
            b: c.b + (h.b - c.b) * u
        };
    }
    l.lerp = a;
})(Ar || (Ar = {}));
var Ln;
((o)=>{
    o.white = xe(ie({}, Ar.white), {
        a: 1
    });
    function e(a) {
        return {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a[3]
        };
    }
    o.from0to1 = e;
    function t(a, l) {
        return xe(ie({}, Ar.fromHex(a)), {
            a: l
        });
    }
    o.fromHexAndA = t;
    function r(a) {
        return {
            r: Math.round(a.r * 255),
            g: Math.round(a.g * 255),
            b: Math.round(a.b * 255),
            a: a.a
        };
    }
    o.toRgb255a1 = r;
    function n(a, l) {
        return Ar.equals(a, l) && a.a === l.a;
    }
    o.equals = n;
    function s(a, l, c) {
        return {
            r: a.r + (l.r - a.r) * c,
            g: a.g + (l.g - a.g) * c,
            b: a.b + (l.b - a.b) * c,
            a: a.a + (l.a - a.a) * c
        };
    }
    o.lerp = s;
})(Ln || (Ln = {}));
var Nd;
((e)=>e.identity = {
        position: [
            0,
            0,
            0
        ],
        rotation: [
            0,
            0,
            0
        ],
        scale: [
            1,
            1,
            1
        ]
    }
)(Nd || (Nd = {}));
var Od;
((e)=>e.defaultData = {
        mass: 1,
        stiffness: 80,
        damping: 10,
        velocity: 0
    }
)(Od || (Od = {}));
var Fd;
((e)=>e.defaultData = {
        control1: [
            .5,
            .05
        ],
        control2: [
            .1,
            .3
        ]
    }
)(Fd || (Fd = {}));
var Ud;
((e)=>{
    function i(t, r = .1) {
        return {
            type: "radial",
            hideBase: !1,
            count: 3,
            radial: {
                radius: Math.max(t[0], t[1]) * 2,
                start: 0,
                end: 360,
                alignment: !1,
                axis: "y",
                scale: [
                    1,
                    1,
                    1
                ],
                rotation: [
                    0,
                    0,
                    0
                ],
                position: [
                    0,
                    0,
                    0
                ]
            },
            linear: {
                scale: [
                    1,
                    1,
                    1
                ],
                rotation: [
                    0,
                    0,
                    0
                ],
                position: [
                    t[0] + t[0] * r,
                    0,
                    0
                ]
            },
            grid: {
                count: [
                    2,
                    2,
                    2
                ],
                size: t.map((n)=>n * (1 + r)
                ),
                useCenter: !0
            }
        };
    }
    e.defaultData = i;
})(Ud || (Ud = {}));
var jn = class {
    modifyById(e, t) {
        let r = this;
        if (r[e] === void 0) throw new Error("not expected");
        {
            let s = xe(ie({}, r), {
                [e]: t
            });
            return Object.setPrototypeOf(s, jn.prototype), s;
        }
    }
    add(e, t) {
        var n;
        let r = this.runOp({
            type: 1,
            id: e,
            data: t
        });
        return (n = r == null ? void 0 : r.data) != null ? n : this;
    }
    runOp(e) {
        let t = this;
        if (e.type === 1) {
            let r = t[e.id], n;
            r === void 0 ? n = {
                type: 2,
                id: e.id
            } : n = {
                type: 1,
                id: e.id,
                data: r
            };
            let { id: s , data: o  } = e, a = xe(ie({}, t), {
                [s]: o
            });
            return Object.setPrototypeOf(a, jn.prototype), {
                data: a,
                actual: e,
                reverse: n
            };
        } else if (e.type === 2) {
            let { id: r  } = e, n = t[r];
            if (n === void 0) return null;
            {
                let s = ie({}, t);
                return Object.setPrototypeOf(s, jn.prototype), delete s[r], {
                    data: s,
                    actual: e,
                    reverse: {
                        type: 1,
                        id: r,
                        data: n
                    }
                };
            }
        }
        throw new Error("illegal arg");
    }
};
function Dh(i) {
    if (i.deepFreeze !== void 0) {
        i.deepFreeze(i);
        return;
    }
    let e = Object.getOwnPropertyNames(i);
    for (let t of e){
        let r = i[t];
        r && typeof r == "object" && Dh(r);
    }
    return Object.freeze(i);
}
function $S(i, e) {
    let t = 0;
    for(; t < i.length && t < e.length;){
        if (i[t] < e[t]) return -1;
        if (i[t] > e[t]) return 1;
        t += 1;
    }
    return t !== e.length ? -1 : t !== i.length ? 1 : 0;
}
var zd = class extends Error {
};
function Li(i, e, t) {
    if (i === void 0 ? e === void 0 ? (i = 0, e = 10) : i = e - 10 : e === void 0 && (e = i + 10), i > e) {
        let s = i;
        i = e, e = s;
    }
    let r = [], n = 1 / (t + 1);
    for(let s = 0; s < t; s++){
        let o = i + (e - i) * (s + .75 + Math.random() * .5) * n;
        r.push(o);
    }
    return r;
}
function eM(i) {
    return i instanceof Uint8Array || i instanceof Uint16Array || i instanceof Uint32Array || i instanceof Int8Array || i instanceof Int16Array || i instanceof Int32Array || i instanceof Float32Array || i instanceof Float64Array;
}
function tM() {
    return typeof process < "u";
}
function rM(i, e) {
    for (let t of i)e(t.id, t.data), rM(t.children, e);
}
function nM(i, e) {
    e(i.id, i.data);
    for (let t of i.children)nM(t, e);
}
var qn = class extends Array {
    constructor(...t){
        super(...t);
        Object.setPrototypeOf(this, qn.prototype);
    }
    deepFreeze() {
        let t = 0;
        for(; t < this.length;)Dh(this[t]), t++;
    }
    fillCaches0(t, r) {
        this.objCaches.set(t.id, t), this.parentCaches.set(t.id, r);
        for (let n of t.children)this.fillCaches0(n, t.id);
    }
    fillCaches() {
        if (this.objCaches === void 0) {
            this.objCaches = new Map, this.parentCaches = new Map;
            for (let t of this)this.fillCaches0(t, null);
        }
    }
    randomId() {
        this.fillCaches();
        let t = Array.from(this.objCaches.keys());
        if (t.length !== 0) return t[Math.max(0, Math.floor(Math.random() * t.length) - 1)];
    }
    isDescendantOf(t, r) {
        for(; t;){
            let n = this.parent(t);
            if (n === r) return !0;
            t = n;
        }
        return !1;
    }
    data(t) {
        var r;
        return (r = this.get(t)) == null ? void 0 : r.data;
    }
    has(t) {
        return this.childrenOf(t) !== void 0;
    }
    get(t) {
        return this.fillCaches(), this.objCaches.get(t);
    }
    childrenOf(t) {
        var r;
        return t === null ? this : (r = this.get(t)) == null ? void 0 : r.children;
    }
    traverseFrom(t, r) {
        if (t === null) this.traverse(r);
        else {
            let n = this.get(t);
            n && nM(n, r);
        }
    }
    traverse(t) {
        rM(this, t);
    }
    totalSize() {
        return this.fillCaches(), this.objCaches.size;
    }
    parent(t) {
        return this.fillCaches(), this.parentCaches.get(t);
    }
    childrenArray(t) {
        return t === null ? this : this.get(t).children;
    }
    modifyById(t, r) {
        if (this.get(t) === void 0) throw new Error("not expected");
        {
            let s = this.parent(t), o = this.childrenArray(s), a = o.findIndex((h)=>h.id === t
            );
            if (a < 0) throw new Error("not expected");
            let l = o[a];
            return o = [
                ...o
            ], o[a] = xe(ie({}, l), {
                data: r
            }), this.modifyArrayBy(s, o);
        }
    }
    modifyArrayBy(t, r) {
        let n = t, s = r;
        for(; n !== null;){
            let a = s, l = n;
            if (n = this.parent(n), n === void 0) throw new Error;
            s = this.childrenArray(n);
            let c = s.findIndex((h)=>h.id === l
            );
            if (c < 0) throw new Error;
            s = [
                ...s
            ], s[c] = xe(ie({}, s[c]), {
                children: a
            });
        }
        Object.setPrototypeOf(s, qn.prototype);
        let o = s;
        return o.fillCaches(), o;
    }
    runOp(t) {
        switch(t.type){
            case 7:
                return this.addOp(t);
            case 8:
                return this.deleteOp(t);
            case 9:
                return this.moveOp(t);
        }
    }
    checkDuplicatedIdRec({ id: t , children: r  }) {
        if (this.get(t) !== void 0) return !0;
        for (let n of r)if (this.checkDuplicatedIdRec(n)) return !0;
        return !1;
    }
    addOp(t) {
        let { parent: r , fi: n , id: s , data: o , children: a  } = t;
        if (r !== null && this.get(r) === void 0) return null;
        if (this.checkDuplicatedIdRec(t)) return null;
        {
            let l = r, c = this.childrenArray(l), h = {
                fi: n,
                id: s,
                data: o,
                children: a
            };
            return c = [
                ...c,
                h
            ], c.sort((f, d)=>f.fi - d.fi
            ), t.localIndex = c.indexOf(h), {
                data: this.modifyArrayBy(l, c),
                actual: t,
                reverse: {
                    type: 8,
                    id: s
                }
            };
        }
    }
    deleteOp(t) {
        let { id: r  } = t;
        if (this.get(r) === null) return null;
        {
            let n = this.parent(r);
            if (n === void 0) return null;
            let s = this.childrenArray(n), o = s.findIndex((c)=>c.id === r
            );
            t.localIndex = o, s = [
                ...s
            ];
            let a = s.splice(o, 1)[0];
            return {
                data: this.modifyArrayBy(n, s),
                actual: t,
                reverse: xe(ie({
                    type: 7
                }, a), {
                    parent: n
                })
            };
        }
    }
    moveOp(t) {
        let { parent: r , fi: n , id: s  } = t;
        if (r !== null && this.get(r) === void 0) return this.deleteOp({
            type: 8,
            id: s
        });
        if (r !== null) {
            let d = r;
            for(; d !== null;){
                if (d === void 0) throw new Error;
                if (d === s) throw new zd("cyclic tree");
                d = this.parent(d);
            }
        }
        let o = this.parent(s);
        if (o === void 0) return null;
        let a = o, l = this.childrenArray(o), c = l.findIndex((d)=>d.id === s
        );
        l = [
            ...l
        ];
        let h = l.splice(c, 1)[0], u = this.modifyArrayBy(o, l);
        o = r, l = u.childrenArray(o);
        let f = h.fi;
        return h = xe(ie({}, h), {
            fi: n
        }), l = [
            ...l,
            h
        ], l.sort((d, p)=>d.fi - p.fi
        ), t.localIndex = l.indexOf(h), u = u.modifyArrayBy(o, l), {
            data: u,
            actual: t,
            reverse: {
                type: 9,
                parent: a,
                fi: f,
                id: s
            }
        };
    }
    previous(t, r) {
        if (r === null) {
            let s = this.childrenArray(t);
            return s.length === 0 ? null : s[s.length - 1].id;
        }
        let n = null;
        for (let s of this.childrenArray(t)){
            if (s.id === r) return n;
            n = s.id;
        }
        return null;
    }
    traverseSortNext(t) {
        let r = this.parent(t);
        if (r !== void 0) {
            let n = this.childrenArray(r), s = n.findIndex((o)=>o.id === t
            ) + 1;
            if (s < n.length) return n[s].id;
            if (r) return this.traverseSortNext(r);
        }
    }
    sortNext(t) {
        let r = this.childrenArray(t);
        return r.length > 0 ? r[0].id : this.traverseSortNext(t);
    }
    traverseSortPrevious(t) {
        let r = this.childrenArray(t);
        return r.length > 0 ? this.traverseSortPrevious(r[r.length - 1].id) : t;
    }
    sortPrevious(t) {
        let r = this.parent(t);
        if (r !== void 0) {
            let n = this.childrenArray(r), s = n.findIndex((o)=>o.id === t
            ) - 1;
            return s >= 0 ? this.traverseSortPrevious(n[s].id) : r;
        }
    }
    getAllSorted(t) {
        let r = [];
        for (let n7 of t){
            let s = this.getWithSortKey(n7.id);
            s !== void 0 && r.push(ie(ie({}, n7), s));
        }
        r.sort((n, s)=>$S(n.sortKey, s.sortKey)
        );
        for (let n6 of r)delete n6.sortKey;
        return r;
    }
    getWithSortKey(t) {
        var r = t;
        let n = [], s = this.get(r), o = s;
        if (s !== void 0) {
            for(; r;)n.splice(0, 0, s.fi), r = this.parent(r), r !== null && (s = this.get(r));
            return xe(ie({}, o), {
                sortKey: n
            });
        }
    }
    insertBeforeHelper(t, r, n) {
        return this.insertAfterHelper(t, this.previous(t, r), n);
    }
    insertAfterHelper(t, r, n) {
        let s = this.childrenArray(t);
        if (r === null) {
            if (s.length === 0) return Li(0, n, n);
            {
                let o = s[0].fi;
                return Li(o - n, o, n);
            }
        } else {
            let o = this.get(r);
            if (o === void 0 || this.parent(r) !== t) throw new Error("illegal args");
            let a = s.find((l)=>l.fi > o.fi
            );
            if (a === void 0) {
                let l = s[s.length - 1].fi;
                return Li(l, l + n, n);
            } else return Li(o.fi, a.fi, n);
        }
    }
};
var Gd;
((e)=>{
    function i(t, r) {
        if (Array.isArray(t)) {
            let n = r.props, s = {}, o = [
                ...t
            ], a = !1;
            if (n) for (let l of Object.keys(n)){
                let c = parseInt(l);
                if (isNaN(c)) throw new Error("wrong index");
                s[l] = o[c], o[c] = n[l], a = !0;
            }
            return a ? {
                data: o,
                actual: r,
                reverse: {
                    type: 0,
                    props: s
                }
            } : null;
        } else {
            let n = r.props, s = {}, o = ie({}, t), a = !1;
            if (n) for (let l of Object.keys(n)){
                s[l] = o[l];
                let c = n[l];
                c === void 0 ? delete o[l] : o[l] = c, a = !0;
            }
            return a ? {
                data: o,
                actual: r,
                reverse: {
                    type: 0,
                    props: s
                }
            } : null;
        }
    }
    e.runOp = i;
})(Gd || (Gd = {}));
var rr = class extends Array {
    constructor(...t){
        super(...t);
        Object.setPrototypeOf(this, rr.prototype);
    }
    deepFreeze() {
        let t = 0;
        for(; t < this.length;)Dh(this[t]), t++;
    }
    fillCaches0(t) {
        this.objCaches.set(t.id, t);
    }
    fillCaches() {
        if (this.objCaches === void 0) {
            this.objCaches = new Map, Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = !1;
            for (let t of this)this.fillCaches0(t);
        }
    }
    randomId() {
        this.fillCaches();
        let t = Array.from(this.objCaches.keys());
        if (t.length !== 0) return t[Math.max(0, Math.floor(Math.random() * t.length) - 1)];
    }
    data(t) {
        var r;
        return (r = this.get(t)) == null ? void 0 : r.data;
    }
    get(t) {
        return this.fillCaches(), this.objCaches.get(t);
    }
    modifyById(t, r) {
        if (this.get(t) === void 0) throw new Error("not expected");
        {
            let s = this, o = s.findIndex((c)=>c.id === t
            );
            if (o < 0) throw new Error("not expected");
            let a = s[o];
            return s = [
                ...s
            ], s[o] = xe(ie({}, a), {
                data: r
            }), this.modifyArrayBy(s);
        }
    }
    modifyArrayBy(t) {
        Object.setPrototypeOf(t, rr.prototype);
        let r = t;
        return tM() || r.fillCaches(), r;
    }
    runOp(t) {
        switch(t.type){
            case 4:
                return this.addOp(t);
            case 5:
                return this.deleteOp(t);
            case 6:
                return this.moveOp(t);
        }
    }
    addOp(t) {
        let { fi: r , id: n , data: s  } = t, o = this, a = {
            fi: r,
            id: n,
            data: s
        };
        return o = [
            ...o,
            a
        ], o.sort((c, h)=>c.fi - h.fi
        ), t.localIndex = o.indexOf(a), {
            data: this.modifyArrayBy(o),
            actual: t,
            reverse: {
                type: 5,
                id: n
            }
        };
    }
    deleteOp(t) {
        let { id: r  } = t, n = this, s = n.findIndex((l)=>l.id === r
        );
        if (s === -1) return null;
        t.localIndex = s, n = [
            ...n
        ];
        let o = n.splice(s, 1)[0];
        return {
            data: this.modifyArrayBy(n),
            actual: t,
            reverse: ie({
                type: 4
            }, o)
        };
    }
    moveOp(t) {
        let { fi: r , id: n  } = t, s = this;
        s = [
            ...s
        ];
        let o = s.findIndex((h)=>h.id === n
        );
        if (o === -1) return null;
        let a = s[o].fi, l = xe(ie({}, s[o]), {
            fi: r
        });
        return s[o] = l, s.sort((h, u)=>h.fi - u.fi
        ), t.localIndex = s.indexOf(l), {
            data: this.modifyArrayBy(s),
            actual: t,
            reverse: {
                type: 6,
                fi: a,
                id: n
            }
        };
    }
    previous(t) {
        if (t === null) return this.length === 0 ? null : this[this.length - 1].id;
        let r = null;
        for (let n of this){
            if (n.id === t) return r;
            r = n.id;
        }
        return null;
    }
    insertBeforeHelper(t, r) {
        return this.insertAfterHelper(this.previous(t), r);
    }
    insertAfterHelper(t, r) {
        let n = this;
        if (t === null) {
            if (n.length === 0) return Li(0, r, r);
            {
                let s = n[0].fi;
                return Li(s - r, s, r);
            }
        } else {
            let s = this.get(t);
            if (s === void 0) throw new Error("illegal args");
            let o = n.find((a)=>a.fi > s.fi
            );
            if (o === void 0) {
                let a = n[n.length - 1].fi;
                return Li(a, a + r, r);
            } else return Li(s.fi, o.fi, r);
        }
    }
};
var iM = Symbol(), Vd = Symbol(), Sl = class {
    reportOp(e, t) {
        let r = this;
        if (t === null) return;
        r._current = t.data;
        let n = [];
        for(; !(r instanceof kd);){
            let s = r._path, o = r._current;
            if (s !== "" && n.splice(0, 0, s), r = r._parent, r === null) return;
            r.update(s, o);
        }
        r.push(n, e, t.actual, t.reverse);
    }
    deleteChildren(e) {
        if (this._children) {
            let t = this._children[e];
            if (t) {
                let r = t[Vd];
                r && r(), delete this._children[e];
            }
        }
    }
}, Sy = class extends Sl {
    constructor(e, t, r){
        super(), this._parent = e, this._path = t, this._current = r;
    }
    update(e, t) {
        if (Array.isArray(this._current)) {
            if (typeof e == "string" && (e = parseInt(e), isNaN(e))) throw new Error("Invalid path");
            this._current = [
                ...this._current
            ], this._current[e] = t;
        } else this._current = xe(ie({}, this._current), {
            [e]: t
        });
    }
    runOp(e) {
        this.reportOp(e, Gd.runOp(this._current, e));
    }
}, My = class extends Sl {
    constructor(e, t, r){
        super(), this._parent = e, this._path = t, this._current = r;
    }
    update(e, t) {
        this._current = xe(ie({}, this._current), {
            [e]: t
        }), Object.setPrototypeOf(this._current, jn.prototype);
    }
    runOp(e) {
        this.reportOp(e, this._current.runOp(e));
    }
}, sM = {
    get (i, e) {
        if (e === Vd) return ()=>{
            i._parent = null;
        };
        if (e === iM) return i._current;
        let { _current: t , _children: r  } = i;
        if (e === "push" && Array.isArray(t)) throw new Error("not supported to expand array");
        let n = r === void 0 ? void 0 : r[e];
        if (n !== void 0) return n;
        let s = t[e], o = Hd(i, e, s);
        return o !== s ? (r === void 0 && (r = {}, i._children = r), r[e] = o, o) : s;
    },
    has (i, e) {
        return e in i._current;
    },
    ownKeys (i) {
        return Reflect.ownKeys(i._current);
    },
    defineProperty () {
        throw Error("not supported");
    },
    getPrototypeOf (i) {
        return Object.getPrototypeOf(i._current);
    },
    setPrototypeOf () {
        throw Error("not supported");
    },
    getOwnPropertyDescriptor (i, e) {
        let t = i._current, r = Reflect.getOwnPropertyDescriptor(t, e);
        return r && {
            writable: !0,
            configurable: !0,
            enumerable: r.enumerable,
            value: t[e]
        };
    }
}, hO = xe(ie({}, sM), {
    set (i, e, t) {
        var n;
        let r = {
            type: 0,
            props: {
                [e]: (n = Ey(t)) != null ? n : t
            }
        };
        return i.deleteChildren(e), i.runOp(r), !0;
    },
    deleteProperty (i, e) {
        let t = {
            type: 0,
            props: {
                [e]: void 0
            }
        };
        return i.deleteChildren(e), i.runOp(t), !0;
    }
}), uO = xe(ie({}, sM), {
    set (i, e, t) {
        return t === void 0 ? this.deleteProperty(i, e) : (i.deleteChildren(e), i.runOp({
            type: 1,
            id: e,
            data: t
        })), !0;
    },
    deleteProperty (i, e) {
        return i.runOp({
            type: 2,
            id: e
        }), !0;
    }
}), Ml = class extends Sl {
    constructor(e, t, r){
        super(), this._children = {}, this._parent = e, this._path = t, this._current = r, this[Vd] = ()=>{
            this._parent = null;
        };
    }
    unproxy() {
        return this._current;
    }
    update(e, t) {
        this._current = this._current.modifyById(e, t);
    }
    runOp(e) {
        this.reportOp(e, this._current.runOp(e));
    }
    randomId() {
        return this._current.randomId();
    }
    isDescendantOf(e, t) {
        return this._current.isDescendantOf(e, t);
    }
    childrenOf(e) {
        return this._current.childrenOf(e);
    }
    traverse(e) {
        return this._current.traverse(e);
    }
    get(e) {
        return this._current.get(e);
    }
    parent(e) {
        return this._current.parent(e);
    }
    traverse(e) {
        this._current.traverse((t, r)=>{
            e(t, this.data(t));
        });
    }
    data(e) {
        var a;
        let { _current: t , _children: r  } = this, n = r === void 0 ? void 0 : r[e];
        if (n !== void 0) return n;
        let s = (a = t.get(e)) == null ? void 0 : a.data, o = Hd(this, e, s);
        return o !== s ? (r === void 0 && (r = {}, this._children = r), r[e] = o, o) : s;
    }
    add(e, t, r, n, s) {
        this.runOp({
            type: 7,
            parent: e,
            fi: t,
            id: r,
            data: n,
            children: s
        });
    }
    move(e, t, r) {
        this.runOp({
            type: 9,
            parent: e,
            fi: t,
            id: r
        });
    }
    insertAfter(e, t, r) {
        let n = this._current.insertAfterHelper(e, t, r.length);
        for(let s = 0; s < r.length; s++){
            let o = r[s];
            this.add(e, n[s], o.id, o.data, o.children);
        }
    }
    insertBefore(e, t, r) {
        let n = this._current.insertBeforeHelper(e, t, r.length);
        for(let s = 0; s < r.length; s++){
            let o = r[s];
            this.add(e, n[s], o.id, o.data, o.children);
        }
    }
    moveAfter(e, t, r) {
        let n = this._current.insertAfterHelper(e, t, r.length);
        for(let s = 0; s < r.length; s++){
            let o = r[s];
            this.move(e, n[s], o);
        }
    }
    moveBefore(e, t, r) {
        let n = this._current.insertBeforeHelper(e, t, r.length);
        for(let s = 0; s < r.length; s++){
            let o = r[s];
            this.move(e, n[s], o);
        }
    }
    delete(e) {
        this.deleteChildren(e), this.runOp({
            type: 8,
            id: e
        });
    }
    sortNext(e) {
        return this._current.sortNext(e);
    }
    sortPrevious(e) {
        return this._current.sortPrevious(e);
    }
    getAllSorted(e) {
        return this._current.getAllSorted(e);
    }
}, Al = class extends Sl {
    constructor(e, t, r){
        super(), this._children = {}, this._parent = e, this._path = t, this._current = r, this[Vd] = ()=>{
            this._parent = null;
        };
    }
    unproxy() {
        return this._current;
    }
    get length() {
        return this._current.length;
    }
    forEach(e) {
        let t = this.length;
        for(let r = 0; r < t; r++){
            let n = this._current[r].id;
            e(this.data(this._current[r].id), n);
        }
    }
    update(e, t) {
        this._current = this._current.modifyById(e, t);
    }
    randomId() {
        return this._current.randomId();
    }
    get(e) {
        return xe(ie({}, this._current.get(e)), {
            data: this.data(e)
        });
    }
    data(e) {
        var a;
        let { _current: t , _children: r  } = this, n = r === void 0 ? void 0 : r[e];
        if (n !== void 0) return n;
        let s = (a = t.get(e)) == null ? void 0 : a.data, o = Hd(this, e, s);
        return o !== s ? (r === void 0 && (r = {}, this._children = r), r[e] = o, o) : s;
    }
    runOp(e) {
        this.reportOp(e, this._current.runOp(e));
    }
    add(e, t, r) {
        this.runOp({
            type: 4,
            fi: e,
            id: t,
            data: r
        });
    }
    move(e, t) {
        this.runOp({
            type: 6,
            fi: e,
            id: t
        });
    }
    insertAfter(e, t) {
        let r = this._current.insertAfterHelper(e, t.length);
        for(let n = 0; n < t.length; n++){
            let s = t[n];
            this.add(r[n], s.id, s.data);
        }
    }
    insertBefore(e, t) {
        let r = this._current.insertBeforeHelper(e, t.length);
        for(let n = 0; n < t.length; n++){
            let s = t[n];
            this.add(r[n], s.id, s.data);
        }
    }
    moveAfter(e, t) {
        let r = this._current.insertAfterHelper(e, t.length);
        for(let n = 0; n < t.length; n++){
            let s = t[n];
            this.move(r[n], s);
        }
    }
    moveBefore(e, t) {
        let r = this._current.insertBeforeHelper(e, t.length);
        for(let n = 0; n < t.length; n++){
            let s = t[n];
            this.move(r[n], s);
        }
    }
    delete(e) {
        this.deleteChildren(e), this.runOp({
            type: 5,
            id: e
        });
    }
};
function wy(i, e, t) {
    if (i.length > 0) {
        let r = i[i.length - 1];
        if (r.type === 0 && e.type === 0 && Wd.equal(r.path, t)) {
            Object.assign(r.props, e.props);
            return;
        }
    }
    i.push(xe(ie({}, e), {
        path: t
    }));
}
var kd = class {
    constructor(e){
        this.ts = [], this.actual = [], this.reverse = [], this._current = e;
    }
    update(e, t) {
        if (e !== "") throw new Error("");
        this._current = t;
    }
    push(e, t, r, n) {
        wy(this.ts, t, e), wy(this.actual, r, e), wy(this.reverse, n, e);
    }
    result() {
        return {
            data: this._current,
            ts: this.ts,
            actual: this.actual,
            reverse: this.reverse.reverse()
        };
    }
};
function Hd(i, e, t) {
    return t instanceof qn ? new Ml(i, e, t) : t instanceof rr ? new Al(i, e, t) : t instanceof jn ? new Proxy(new My(i, e, t), uO) : t !== null && typeof t == "object" ? eM(t) ? t : new Proxy(new Sy(i, e, t), hO) : t;
}
function Ay(i) {
    let e = new kd(i);
    return [
        Hd(e, "", i),
        e
    ];
}
function Ty(i, e) {
    let [t, r] = Ay(i);
    return e(t), r.result();
}
function Ey(i) {
    return i instanceof Ml || i instanceof Al ? i._current : i !== null && typeof i == "object" ? i[iM] : i;
}
var Wd;
((r)=>{
    function i(n, s) {
        if (s.length === n.length) for(var o = 0; o < n.length;){
            if (n[o] !== s[o]) return !1;
            o += 1;
        }
        else return !1;
        return !0;
    }
    r.equal = i;
    function e(n, s, o) {
        let a = t(o, n);
        if (a !== void 0 && typeof a == "object" && a !== null) {
            let l = ie({}, s);
            return Object.keys(a).forEach((c)=>{
                delete l[c];
            }), l;
        } else return s;
    }
    r.removeOverridden = e;
    function t(n, s, o = 0) {
        if (s.length <= o) return n;
        if ((n instanceof qn || n instanceof Ml) && typeof s[o] == "string") return t(n.data(s[o]), s, o + 1);
        if ((n instanceof rr || n instanceof Al) && typeof s[o] == "string") return t(n.data(s[o]), s, o + 1);
        if (typeof s[o] == "number" && Array.isArray(n)) return t(n[s[o]], s, o + 1);
        if (typeof s[o] == "string" && typeof n == "object") return t(n[s[o]], s, o + 1);
    }
    r.zoom = t;
})(Wd || (Wd = {}));
var jd = class {
}, Ph = class extends jd {
    constructor(t){
        super();
        this.id = t;
    }
}, Lh = class extends jd {
    constructor(t){
        super();
        this.data = t;
    }
};
var Cy;
try {
    Cy = new TextDecoder;
} catch  {}
var Re, ro, $ = 0;
var dM = [], Dy = dM, Py = 0, Sn = {}, Ct, to, Yn = 0, Ii = 0, In, fs, fn = [], Bt, oM = {
    useRecords: !1,
    mapsAsObjects: !0
}, Ih = class {
}, Iy = new Ih;
Iy.name = "MessagePack 0xC1";
var Tl = !1, Ri = class {
    constructor(e){
        e && (e.useRecords === !1 && e.mapsAsObjects === void 0 && (e.mapsAsObjects = !0), e.structures ? e.structures.sharedLength = e.structures.length : e.getStructures && ((e.structures = []).uninitialized = !0, e.structures.sharedLength = 0)), Object.assign(this, e);
    }
    unpack(e, t) {
        if (Re) return vM(()=>(Yd(), this ? this.unpack(e, t) : Ri.prototype.unpack.call(oM, e, t))
        );
        ro = t > -1 ? t : e.length, $ = 0, Py = 0, Ii = 0, to = null, Dy = dM, In = null, Re = e;
        try {
            Bt = e.dataView || (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength));
        } catch (r) {
            throw Re = null, e instanceof Uint8Array ? r : new Error("Source must be a Uint8Array or Buffer but was a " + (e && typeof e == "object" ? e.constructor.name : typeof e));
        }
        if (this instanceof Ri) {
            if (Sn = this, this.structures) return Ct = this.structures, qd();
            (!Ct || Ct.length > 0) && (Ct = []);
        } else Sn = oM, (!Ct || Ct.length > 0) && (Ct = []);
        return qd();
    }
    unpackMultiple(e, t) {
        let r, n = 0;
        try {
            Tl = !0;
            let s = e.length, o = this ? this.unpack(e, s) : Jd.unpack(e, s);
            if (t) {
                for(t(o); $ < s;)if (n = $, t(qd()) === !1) return;
            } else {
                for(r = [
                    o
                ]; $ < s;)n = $, r.push(qd());
                return r;
            }
        } catch (s) {
            throw s.lastPosition = n, s.values = r, s;
        } finally{
            Tl = !1, Yd();
        }
    }
    _mergeStructures(e, t) {
        e = e || [];
        for(let r = 0, n = e.length; r < n; r++){
            let s = e[r];
            s && (s.isShared = !0, r >= 32 && (s.highByte = r - 32 >> 5));
        }
        e.sharedLength = e.length;
        for(let r5 in t || [])if (r5 >= 0) {
            let n = e[r5], s = t[r5];
            s && (n && ((e.restoreStructures || (e.restoreStructures = []))[r5] = n), e[r5] = s);
        }
        return this.structures = e;
    }
    decode(e, t) {
        return this.unpack(e, t);
    }
};
function qd() {
    try {
        if (!Sn.trusted && !Tl) {
            let e = Ct.sharedLength || 0;
            e < Ct.length && (Ct.length = e);
        }
        let i = lr();
        if ($ == ro) Ct.restoreStructures && aM(), Ct = null, Re = null, fs && (fs = null);
        else if ($ > ro) {
            let e = new Error("Unexpected end of MessagePack data");
            throw e.incomplete = !0, e;
        } else if (!Tl) throw new Error("Data read, but end of buffer not reached");
        return i;
    } catch (i) {
        throw Ct.restoreStructures && aM(), Yd(), (i instanceof RangeError || i.message.startsWith("Unexpected end of buffer")) && (i.incomplete = !0), i;
    }
}
function aM() {
    for(let i in Ct.restoreStructures)Ct[i] = Ct.restoreStructures[i];
    Ct.restoreStructures = null;
}
function lr() {
    let i = Re[$++];
    if (i < 160) {
        if (i < 128) {
            if (i < 64) return i;
            {
                let e = Ct[i & 63] || Sn.getStructures && pM()[i & 63];
                return e ? (e.read || (e.read = Ry(e, i & 63)), e.read()) : i;
            }
        } else if (i < 144) {
            if (i -= 128, Sn.mapsAsObjects) {
                let e = {};
                for(let t = 0; t < i; t++)e[gM()] = lr();
                return e;
            } else {
                let e = new Map;
                for(let t = 0; t < i; t++)e.set(lr(), lr());
                return e;
            }
        } else {
            i -= 144;
            let e = new Array(i);
            for(let t = 0; t < i; t++)e[t] = lr();
            return e;
        }
    } else if (i < 192) {
        let e = i - 160;
        if (Ii >= $) return to.slice($ - Yn, ($ += e) - Yn);
        if (Ii == 0 && ro < 140) {
            let t = e < 16 ? By(e) : mM(e);
            if (t != null) return t;
        }
        return Ly(e);
    } else {
        let e;
        switch(i){
            case 192:
                return null;
            case 193:
                return In ? (e = lr(), e > 0 ? In[1].slice(In.position1, In.position1 += e) : In[0].slice(In.position0, In.position0 -= e)) : Iy;
            case 194:
                return !1;
            case 195:
                return !0;
            case 196:
                return _y(Re[$++]);
            case 197:
                return e = Bt.getUint16($), $ += 2, _y(e);
            case 198:
                return e = Bt.getUint32($), $ += 4, _y(e);
            case 199:
                return jo(Re[$++]);
            case 200:
                return e = Bt.getUint16($), $ += 2, jo(e);
            case 201:
                return e = Bt.getUint32($), $ += 4, jo(e);
            case 202:
                if (e = Bt.getFloat32($), Sn.useFloat32 > 2) {
                    let t = Qd[(Re[$] & 127) << 1 | Re[$ + 1] >> 7];
                    return $ += 4, (t * e + (e > 0 ? .5 : -0.5) >> 0) / t;
                }
                return $ += 4, e;
            case 203:
                return e = Bt.getFloat64($), $ += 8, e;
            case 204:
                return Re[$++];
            case 205:
                return e = Bt.getUint16($), $ += 2, e;
            case 206:
                return e = Bt.getUint32($), $ += 4, e;
            case 207:
                return Sn.int64AsNumber ? (e = Bt.getUint32($) * 4294967296, e += Bt.getUint32($ + 4)) : e = Bt.getBigUint64($), $ += 8, e;
            case 208:
                return Bt.getInt8($++);
            case 209:
                return e = Bt.getInt16($), $ += 2, e;
            case 210:
                return e = Bt.getInt32($), $ += 4, e;
            case 211:
                return Sn.int64AsNumber ? (e = Bt.getInt32($) * 4294967296, e += Bt.getUint32($ + 4)) : e = Bt.getBigInt64($), $ += 8, e;
            case 212:
                if (e = Re[$++], e == 114) return fM(Re[$++] & 63);
                {
                    let t = fn[e];
                    if (t) return t.read ? ($++, t.read(lr())) : t.noBuffer ? ($++, t()) : t(Re.subarray($, ++$));
                    throw new Error("Unknown extension " + e);
                }
            case 213:
                return e = Re[$], e == 114 ? ($++, fM(Re[$++] & 63, Re[$++])) : jo(2);
            case 214:
                return jo(4);
            case 215:
                return jo(8);
            case 216:
                return jo(16);
            case 217:
                return e = Re[$++], Ii >= $ ? to.slice($ - Yn, ($ += e) - Yn) : dO(e);
            case 218:
                return e = Bt.getUint16($), $ += 2, Ii >= $ ? to.slice($ - Yn, ($ += e) - Yn) : pO(e);
            case 219:
                return e = Bt.getUint32($), $ += 4, Ii >= $ ? to.slice($ - Yn, ($ += e) - Yn) : mO(e);
            case 220:
                return e = Bt.getUint16($), $ += 2, cM(e);
            case 221:
                return e = Bt.getUint32($), $ += 4, cM(e);
            case 222:
                return e = Bt.getUint16($), $ += 2, hM(e);
            case 223:
                return e = Bt.getUint32($), $ += 4, hM(e);
            default:
                if (i >= 224) return i - 256;
                if (i === void 0) {
                    let t = new Error("Unexpected end of MessagePack data");
                    throw t.incomplete = !0, t;
                }
                throw new Error("Unknown MessagePack token " + i);
        }
    }
}
var fO = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function Ry(i, e) {
    function t() {
        if (t.count++ > 2) {
            let n = i.read = new Function("r", "return function(){return {" + i.map((s)=>fO.test(s) ? s + ":r()" : "[" + JSON.stringify(s) + "]:r()"
            ).join(",") + "}}")(lr);
            return i.highByte === 0 && (i.read = lM(e, i.read)), n();
        }
        let r = {};
        for(let n = 0, s6 = i.length; n < s6; n++){
            let o = i[n];
            r[o] = lr();
        }
        return r;
    }
    return t.count = 0, i.highByte === 0 ? lM(e, t) : t;
}
var lM = (i, e)=>function() {
        let t = Re[$++];
        if (t === 0) return e();
        let r = i < 32 ? -(i + (t << 5)) : i + (t << 5), n = Ct[r] || pM()[r];
        if (!n) throw new Error("Record id is not defined for " + r);
        return n.read || (n.read = Ry(n, i)), n.read();
    }
;
function pM() {
    let i = vM(()=>(Re = null, Sn.getStructures())
    );
    return Ct = Sn._mergeStructures(i, Ct);
}
var Ly = Xd, dO = Xd, pO = Xd, mO = Xd;
function Xd(i) {
    let e;
    if (i < 16 && (e = By(i))) return e;
    if (i > 64 && Cy) return Cy.decode(Re.subarray($, $ += i));
    let t = $ + i, r = [];
    for(e = ""; $ < t;){
        let n = Re[$++];
        if ((n & 128) === 0) r.push(n);
        else if ((n & 224) === 192) {
            let s = Re[$++] & 63;
            r.push((n & 31) << 6 | s);
        } else if ((n & 240) === 224) {
            let s = Re[$++] & 63, o = Re[$++] & 63;
            r.push((n & 31) << 12 | s << 6 | o);
        } else if ((n & 248) === 240) {
            let s = Re[$++] & 63, o = Re[$++] & 63, a = Re[$++] & 63, l = (n & 7) << 18 | s << 12 | o << 6 | a;
            l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | l & 1023), r.push(l);
        } else r.push(n);
        r.length >= 4096 && (e += Br.apply(String, r), r.length = 0);
    }
    return r.length > 0 && (e += Br.apply(String, r)), e;
}
function cM(i) {
    let e = new Array(i);
    for(let t = 0; t < i; t++)e[t] = lr();
    return e;
}
function hM(i) {
    if (Sn.mapsAsObjects) {
        let e = {};
        for(let t = 0; t < i; t++)e[gM()] = lr();
        return e;
    } else {
        let e = new Map;
        for(let t = 0; t < i; t++)e.set(lr(), lr());
        return e;
    }
}
var Br = String.fromCharCode;
function mM(i) {
    let e = $, t = new Array(i);
    for(let r = 0; r < i; r++){
        let n = Re[$++];
        if ((n & 128) > 0) {
            $ = e;
            return;
        }
        t[r] = n;
    }
    return Br.apply(String, t);
}
function By(i) {
    if (i < 4) {
        if (i < 2) {
            if (i === 0) return "";
            {
                let e = Re[$++];
                if ((e & 128) > 1) {
                    $ -= 1;
                    return;
                }
                return Br(e);
            }
        } else {
            let e = Re[$++], t = Re[$++];
            if ((e & 128) > 0 || (t & 128) > 0) {
                $ -= 2;
                return;
            }
            if (i < 3) return Br(e, t);
            let r = Re[$++];
            if ((r & 128) > 0) {
                $ -= 3;
                return;
            }
            return Br(e, t, r);
        }
    } else {
        let e = Re[$++], t = Re[$++], r = Re[$++], n = Re[$++];
        if ((e & 128) > 0 || (t & 128) > 0 || (r & 128) > 0 || (n & 128) > 0) {
            $ -= 4;
            return;
        }
        if (i < 6) {
            if (i === 4) return Br(e, t, r, n);
            {
                let s = Re[$++];
                if ((s & 128) > 0) {
                    $ -= 5;
                    return;
                }
                return Br(e, t, r, n, s);
            }
        } else if (i < 8) {
            let s = Re[$++], o = Re[$++];
            if ((s & 128) > 0 || (o & 128) > 0) {
                $ -= 6;
                return;
            }
            if (i < 7) return Br(e, t, r, n, s, o);
            let a = Re[$++];
            if ((a & 128) > 0) {
                $ -= 7;
                return;
            }
            return Br(e, t, r, n, s, o, a);
        } else {
            let s = Re[$++], o = Re[$++], a = Re[$++], l = Re[$++];
            if ((s & 128) > 0 || (o & 128) > 0 || (a & 128) > 0 || (l & 128) > 0) {
                $ -= 8;
                return;
            }
            if (i < 10) {
                if (i === 8) return Br(e, t, r, n, s, o, a, l);
                {
                    let c = Re[$++];
                    if ((c & 128) > 0) {
                        $ -= 9;
                        return;
                    }
                    return Br(e, t, r, n, s, o, a, l, c);
                }
            } else if (i < 12) {
                let c = Re[$++], h = Re[$++];
                if ((c & 128) > 0 || (h & 128) > 0) {
                    $ -= 10;
                    return;
                }
                if (i < 11) return Br(e, t, r, n, s, o, a, l, c, h);
                let u = Re[$++];
                if ((u & 128) > 0) {
                    $ -= 11;
                    return;
                }
                return Br(e, t, r, n, s, o, a, l, c, h, u);
            } else {
                let c = Re[$++], h = Re[$++], u = Re[$++], f = Re[$++];
                if ((c & 128) > 0 || (h & 128) > 0 || (u & 128) > 0 || (f & 128) > 0) {
                    $ -= 12;
                    return;
                }
                if (i < 14) {
                    if (i === 12) return Br(e, t, r, n, s, o, a, l, c, h, u, f);
                    {
                        let d = Re[$++];
                        if ((d & 128) > 0) {
                            $ -= 13;
                            return;
                        }
                        return Br(e, t, r, n, s, o, a, l, c, h, u, f, d);
                    }
                } else {
                    let d = Re[$++], p = Re[$++];
                    if ((d & 128) > 0 || (p & 128) > 0) {
                        $ -= 14;
                        return;
                    }
                    if (i < 15) return Br(e, t, r, n, s, o, a, l, c, h, u, f, d, p);
                    let m = Re[$++];
                    if ((m & 128) > 0) {
                        $ -= 15;
                        return;
                    }
                    return Br(e, t, r, n, s, o, a, l, c, h, u, f, d, p, m);
                }
            }
        }
    }
}
function _y(i) {
    return Sn.copyBuffers ? Uint8Array.prototype.slice.call(Re, $, $ += i) : Re.subarray($, $ += i);
}
function jo(i) {
    let e = Re[$++];
    if (fn[e]) return fn[e](Re.subarray($, $ += i));
    throw new Error("Unknown extension type " + e);
}
var uM = new Array(4096);
function gM() {
    let i = Re[$++];
    if (i >= 160 && i < 192) {
        if (i = i - 160, Ii >= $) return to.slice($ - Yn, ($ += i) - Yn);
        if (!(Ii == 0 && ro < 180)) return Ly(i);
    } else return $--, lr();
    let e = (i << 5 ^ (i > 1 ? Bt.getUint16($) : i > 0 ? Re[$] : 0)) & 4095, t = uM[e], r = $, n = $ + i - 3, s, o = 0;
    if (t && t.bytes == i) {
        for(; r < n;){
            if (s = Bt.getUint32(r), s != t[o++]) {
                r = 1879048192;
                break;
            }
            r += 4;
        }
        for(n += 3; r < n;)if (s = Re[r++], s != t[o++]) {
            r = 1879048192;
            break;
        }
        if (r === n) return $ = r, t.string;
        n -= 3, r = $;
    }
    for(t = [], uM[e] = t, t.bytes = i; r < n;)s = Bt.getUint32(r), t.push(s), r += 4;
    for(n += 3; r < n;)s = Re[r++], t.push(s);
    let a = i < 16 ? By(i) : mM(i);
    return a != null ? t.string = a : t.string = Ly(i);
}
var fM = (i, e)=>{
    var t = lr();
    let r = i;
    e !== void 0 && (i = i < 32 ? -((e << 5) + i) : (e << 5) + i, t.highByte = e);
    let n = Ct[i];
    return n && n.isShared && ((Ct.restoreStructures || (Ct.restoreStructures = []))[i] = n), Ct[i] = t, t.read = Ry(t, r), t.read();
}, yM = typeof self == "object" ? self : global;
fn[0] = ()=>{};
fn[0].noBuffer = !0;
fn[101] = ()=>{
    let i = lr();
    return (yM[i[0]] || Error)(i[1]);
};
fn[105] = (i)=>{
    let e = Bt.getUint32($ - 4);
    fs || (fs = new Map);
    let t = Re[$], r;
    t >= 144 && t < 160 || t == 220 || t == 221 ? r = [] : r = {};
    let n = {
        target: r
    };
    fs.set(e, n);
    let s = lr();
    return n.used ? Object.assign(r, s) : (n.target = s, s);
};
fn[112] = (i)=>{
    let e = Bt.getUint32($ - 4), t = fs.get(e);
    return t.used = !0, t.target;
};
fn[115] = ()=>new Set(lr())
;
var Ny = [
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64",
    "BigInt64",
    "BigUint64"
].map((i)=>i + "Array"
);
fn[116] = (i)=>{
    let e = i[0], t = Ny[e];
    if (!t) throw new Error("Could not find typed array for code " + e);
    return new yM[t](Uint8Array.prototype.slice.call(i, 1).buffer);
};
fn[120] = ()=>{
    let i = lr();
    return new RegExp(i[0], i[1]);
};
fn[98] = (i)=>{
    let e = (i[0] << 24) + (i[1] << 16) + (i[2] << 8) + i[3], t = $;
    $ += e - 4, In = [
        lr(),
        lr()
    ], In.position0 = 0, In.position1 = 0;
    let r = $;
    $ = t;
    try {
        return lr();
    } finally{
        $ = r;
    }
};
fn[255] = (i)=>i.length == 4 ? new Date((i[0] * 16777216 + (i[1] << 16) + (i[2] << 8) + i[3]) * 1e3) : i.length == 8 ? new Date(((i[0] << 22) + (i[1] << 14) + (i[2] << 6) + (i[3] >> 2)) / 1e6 + ((i[3] & 3) * 4294967296 + i[4] * 16777216 + (i[5] << 16) + (i[6] << 8) + i[7]) * 1e3) : i.length == 12 ? new Date(((i[0] << 24) + (i[1] << 16) + (i[2] << 8) + i[3]) / 1e6 + ((i[4] & 128 ? -281474976710656 : 0) + i[6] * 1099511627776 + i[7] * 4294967296 + i[8] * 16777216 + (i[9] << 16) + (i[10] << 8) + i[11]) * 1e3) : new Date("invalid")
;
function vM(i) {
    let e = ro, t = $, r = Py, n = Yn, s = Ii, o = to, a = Dy, l = fs, c = In, h = new Uint8Array(Re.slice(0, ro)), u = Ct, f = Ct.slice(0, Ct.length), d = Sn, p = Tl, m = i();
    return ro = e, $ = t, Py = r, Yn = n, Ii = s, to = o, Dy = a, fs = l, In = c, Re = h, Tl = p, Ct = u, Ct.splice(0, Ct.length, ...f), Sn = d, Bt = new DataView(Re.buffer, Re.byteOffset, Re.byteLength), m;
}
function Yd() {
    Re = null, fs = null, Ct = null;
}
function xM(i) {
    i.unpack ? fn[i.type] = i.unpack : fn[i.type] = i;
}
var Qd = new Array(147);
for(let i8 = 0; i8 < 256; i8++)Qd[i8] = +("1e" + Math.floor(45.15 - i8 * .30103));
var Jd = new Ri({
    useRecords: !1
}), gO = Jd.unpack, yO = Jd.unpackMultiple, vO = Jd.unpack, Kd = {
    NEVER: 0,
    ALWAYS: 1,
    DECIMAL_ROUND: 3,
    DECIMAL_FIT: 4
}, xO = new Float32Array(1), I9 = new Uint8Array(xO.buffer, 0, 4);
var Zd;
try {
    Zd = new TextEncoder;
} catch  {}
var $d, Fy, ep = typeof Buffer < "u", Oy = ep ? Buffer.allocUnsafeSlow : Uint8Array, MM = ep ? Buffer : Uint8Array, bM = ep ? 4294967296 : 2144337920, de, dr, ae = 0, Bi, Ni = null, bO = /[\u0080-\uFFFF]/, Rh = Symbol("record-id"), qo = class extends Ri {
    constructor(e){
        super(e), this.offset = 0;
        let t, r, n, s, o, a, l = 0, c = MM.prototype.utf8Write ? function(x, E, _) {
            return de.utf8Write(x, E, _);
        } : Zd && Zd.encodeInto ? function(x, E) {
            return Zd.encodeInto(x, de.subarray(E)).written;
        } : !1, h = this;
        e || (e = {});
        let u = e && e.sequential, f = e.structures || e.saveStructures, d = e.maxSharedStructures;
        if (d == null && (d = f ? 32 : 0), d > 8160) throw new Error("Maximum maxSharedStructure is 8160");
        let p = e.maxOwnStructures;
        p == null && (p = f ? 32 : 64), u && !e.saveStructures && (this.structures = []);
        let m = d > 32 || p + d > 64, g = d + 64, v = d + p + 64;
        if (v > 8256) throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
        let y = [], w = 0, b = 0;
        this.pack = this.encode = function(x, E) {
            if (de || (de = new Oy(8192), dr = new DataView(de.buffer, 0, 8192), ae = 0), Bi = de.length - 10, Bi - ae < 2048 ? (de = new Oy(de.length), dr = new DataView(de.buffer, 0, de.length), Bi = de.length - 10, ae = 0) : ae = ae + 7 & 2147483640, r = ae, a = h.structuredClone ? new Map : null, h.bundleStrings ? (Ni = [
                "",
                ""
            ], de[ae++] = 214, de[ae++] = 98, Ni.position = ae - r, ae += 4) : Ni = null, n = h.structures, n) {
                n.uninitialized && (n = h._mergeStructures(h.getStructures()));
                let _ = n.sharedLength || 0;
                if (_ > d) throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + n.sharedLength);
                if (!n.transitions) {
                    n.transitions = Object.create(null);
                    for(let C = 0; C < _; C++){
                        let I = n[C];
                        if (!I) continue;
                        let N, R = n.transitions;
                        for(let k = 0, G = I.length; k < G; k++){
                            let te = I[k];
                            N = R[te], N || (N = R[te] = Object.create(null)), R = N;
                        }
                        R[Rh] = C + 64;
                    }
                    l = _;
                }
                u || (n.nextId = _ + 64);
            }
            s && (s = !1), o = n || [];
            try {
                if (S(x), Ni) {
                    dr.setUint32(Ni.position + r, ae - Ni.position - r);
                    let _ = Ni;
                    Ni = null, S(_[0]), S(_[1]);
                }
                if (h.offset = ae, a && a.idsToInsert) {
                    ae += a.idsToInsert.length * 6, ae > Bi && A(ae), h.offset = ae;
                    let _ = SO(de.subarray(r, ae), a.idsToInsert);
                    return a = null, _;
                }
                return E & TM ? (de.start = r, de.end = ae, de) : de.subarray(r, ae);
            } finally{
                if (n) {
                    if (b < 10 && b++, w > 1e4) n.transitions = null, b = 0, w = 0, y.length > 0 && (y = []);
                    else if (y.length > 0 && !u) {
                        for(let _ = 0, C = y.length; _ < C; _++)y[_][Rh] = 0;
                        y = [];
                    }
                    if (s && h.saveStructures) {
                        let _ = n.sharedLength || d;
                        n.length > _ && (n = n.slice(0, _));
                        let C = de.subarray(r, ae);
                        return h.saveStructures(n, l) === !1 ? (h._mergeStructures(h.getStructures()), h.pack(x)) : (l = _, C);
                    }
                }
                E & DO && (ae = r);
            }
        };
        let S = (x)=>{
            ae > Bi && (de = A(ae));
            var E = typeof x, _;
            if (E === "string") {
                let C = x.length;
                if (Ni && C >= 8 && C < 4096) {
                    let R = bO.test(x);
                    Ni[R ? 0 : 1] += x, de[ae++] = 193, S(R ? -C : C);
                    return;
                }
                let I;
                C < 32 ? I = 1 : C < 256 ? I = 2 : C < 65536 ? I = 3 : I = 5;
                let N = C * 3;
                if (ae + N > Bi && (de = A(ae + N)), C < 64 || !c) {
                    let R, k, G, te = ae + I;
                    for(R = 0; R < C; R++)k = x.charCodeAt(R), k < 128 ? de[te++] = k : k < 2048 ? (de[te++] = k >> 6 | 192, de[te++] = k & 63 | 128) : (k & 64512) === 55296 && ((G = x.charCodeAt(R + 1)) & 64512) === 56320 ? (k = 65536 + ((k & 1023) << 10) + (G & 1023), R++, de[te++] = k >> 18 | 240, de[te++] = k >> 12 & 63 | 128, de[te++] = k >> 6 & 63 | 128, de[te++] = k & 63 | 128) : (de[te++] = k >> 12 | 224, de[te++] = k >> 6 & 63 | 128, de[te++] = k & 63 | 128);
                    _ = te - ae - I;
                } else _ = c(x, ae + I, N);
                _ < 32 ? de[ae++] = 160 | _ : _ < 256 ? (I < 2 && de.copyWithin(ae + 2, ae + 1, ae + 1 + _), de[ae++] = 217, de[ae++] = _) : _ < 65536 ? (I < 3 && de.copyWithin(ae + 3, ae + 2, ae + 2 + _), de[ae++] = 218, de[ae++] = _ >> 8, de[ae++] = _ & 255) : (I < 5 && de.copyWithin(ae + 5, ae + 3, ae + 3 + _), de[ae++] = 219, dr.setUint32(ae, _), ae += 4), ae += _;
            } else if (E === "number") {
                if (x >>> 0 === x) x < 64 ? de[ae++] = x : x < 256 ? (de[ae++] = 204, de[ae++] = x) : x < 65536 ? (de[ae++] = 205, de[ae++] = x >> 8, de[ae++] = x & 255) : (de[ae++] = 206, dr.setUint32(ae, x), ae += 4);
                else if (x >> 0 === x) x >= -32 ? de[ae++] = 256 + x : x >= -128 ? (de[ae++] = 208, de[ae++] = x + 256) : x >= -32768 ? (de[ae++] = 209, dr.setInt16(ae, x), ae += 2) : (de[ae++] = 210, dr.setInt32(ae, x), ae += 4);
                else {
                    let C;
                    if ((C = this.useFloat32) > 0 && x < 4294967296 && x >= -2147483648) {
                        de[ae++] = 202, dr.setFloat32(ae, x);
                        let I;
                        if (C < 4 || (I = x * Qd[(de[ae] & 127) << 1 | de[ae + 1] >> 7]) >> 0 === I) {
                            ae += 4;
                            return;
                        } else ae--;
                    }
                    de[ae++] = 203, dr.setFloat64(ae, x), ae += 8;
                }
            } else if (E === "object") {
                if (!x) de[ae++] = 192;
                else {
                    if (a) {
                        let I = a.get(x);
                        if (I) {
                            if (!I.id) {
                                let N = a.idsToInsert || (a.idsToInsert = []);
                                I.id = N.push(I);
                            }
                            de[ae++] = 214, de[ae++] = 112, dr.setUint32(ae, I.id), ae += 4;
                            return;
                        } else a.set(x, {
                            offset: ae - r
                        });
                    }
                    let C = x.constructor;
                    if (C === Object) T(x, !0);
                    else if (C === Array) {
                        _ = x.length, _ < 16 ? de[ae++] = 144 | _ : _ < 65536 ? (de[ae++] = 220, de[ae++] = _ >> 8, de[ae++] = _ & 255) : (de[ae++] = 221, dr.setUint32(ae, _), ae += 4);
                        for(let I = 0; I < _; I++)S(x[I]);
                    } else if (C === Map) {
                        _ = x.size, _ < 16 ? de[ae++] = 128 | _ : _ < 65536 ? (de[ae++] = 222, de[ae++] = _ >> 8, de[ae++] = _ & 255) : (de[ae++] = 223, dr.setUint32(ae, _), ae += 4);
                        for (let [I, N] of x)S(I), S(N);
                    } else {
                        for(let I = 0, N = $d.length; I < N; I++){
                            let R = Fy[I];
                            if (x instanceof R) {
                                let k = $d[I];
                                if (k.write) {
                                    k.type && (de[ae++] = 212, de[ae++] = k.type, de[ae++] = 0), S(k.write.call(this, x));
                                    return;
                                }
                                let G = de, te = dr, Q = ae;
                                de = null;
                                let Y;
                                try {
                                    Y = k.pack.call(this, x, (F)=>(de = G, G = null, ae += F, ae > Bi && A(ae), {
                                            target: de,
                                            targetView: dr,
                                            position: ae - F
                                        })
                                    , S);
                                } finally{
                                    G && (de = G, dr = te, ae = Q, Bi = de.length - 10);
                                }
                                Y && (Y.length + ae > Bi && A(Y.length + ae), ae = wO(Y, de, ae, k.type));
                                return;
                            }
                        }
                        T(x, !x.hasOwnProperty);
                    }
                }
            } else if (E === "boolean") de[ae++] = x ? 195 : 194;
            else if (E === "bigint") {
                if (x < BigInt(1) << BigInt(63) && x >= -(BigInt(1) << BigInt(63))) de[ae++] = 211, dr.setBigInt64(ae, x);
                else if (x < BigInt(1) << BigInt(64) && x > 0) de[ae++] = 207, dr.setBigUint64(ae, x);
                else if (this.largeBigIntToFloat) de[ae++] = 203, dr.setFloat64(ae, Number(x));
                else throw new RangeError(x + " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");
                ae += 8;
            } else if (E === "undefined") this.encodeUndefinedAsNil ? de[ae++] = 192 : (de[ae++] = 212, de[ae++] = 0, de[ae++] = 0);
            else if (E === "function") S(this.writeFunction && this.writeFunction());
            else throw new Error("Unknown type: " + E);
        }, T = this.useRecords === !1 ? this.variableMapSize ? (x)=>{
            let E = Object.keys(x), _ = E.length;
            _ < 16 ? de[ae++] = 128 | _ : _ < 65536 ? (de[ae++] = 222, de[ae++] = _ >> 8, de[ae++] = _ & 255) : (de[ae++] = 223, dr.setUint32(ae, _), ae += 4);
            let C;
            for(let I = 0; I < _; I++)S(C = E[I]), S(x[C]);
        } : (x, E)=>{
            de[ae++] = 222;
            let _ = ae - r;
            ae += 2;
            let C = 0;
            for(let I in x)(E || x.hasOwnProperty(I)) && (S(I), S(x[I]), C++);
            de[(_++) + r] = C >> 8, de[_ + r] = C & 255;
        } : (x)=>{
            let E = Object.keys(x), _, C = o.transitions || (o.transitions = Object.create(null)), I = 0;
            for(let R = 0, k = E.length; R < k; R++){
                let G = E[R];
                _ = C[G], _ || (_ = C[G] = Object.create(null), I++), C = _;
            }
            let N = C[Rh];
            if (N) N >= 96 && m ? (de[ae++] = ((N -= 96) & 31) + 96, de[ae++] = N >> 5) : de[ae++] = N;
            else {
                N = o.nextId, N || (N = 64), N < g && this.shouldShareStructure && !this.shouldShareStructure(E) ? (N = o.nextOwnId, N < v || (N = g), o.nextOwnId = N + 1) : (N >= v && (N = g), o.nextId = N + 1);
                let R = E.highByte = N >= 96 && m ? N - 96 >> 5 : -1;
                C[Rh] = N, o[N - 64] = E, N < g ? (E.isShared = !0, o.sharedLength = N - 63, s = !0, R >= 0 ? (de[ae++] = (N & 31) + 96, de[ae++] = R) : de[ae++] = N) : (R >= 0 ? (de[ae++] = 213, de[ae++] = 114, de[ae++] = (N & 31) + 96, de[ae++] = R) : (de[ae++] = 212, de[ae++] = 114, de[ae++] = N), I && (w += b * I), y.length >= p && (y.shift()[Rh] = 0), y.push(C), S(E));
            }
            for(let R4 = 0, k4 = E.length; R4 < k4; R4++)S(x[E[R4]]);
        }, A = (x)=>{
            let E;
            if (x > 16777216) {
                if (x - r > bM) throw new Error("Packed buffer would be larger than maximum buffer size");
                E = Math.min(bM, Math.round(Math.max((x - r) * (x > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
            } else E = (Math.max(x - r << 2, de.length - 1) >> 12) + 1 << 12;
            let _ = new Oy(E);
            return dr = new DataView(_.buffer, 0, E), de.copy ? de.copy(_, 0, r, x) : _.set(de.slice(r, x)), ae -= r, r = 0, Bi = _.length - 10, de = _;
        };
    }
    useBuffer(e) {
        de = e, dr = new DataView(de.buffer, de.byteOffset, de.byteLength), ae = 0;
    }
};
Fy = [
    Date,
    Set,
    Error,
    RegExp,
    ArrayBuffer,
    Object.getPrototypeOf(Uint8Array.prototype).constructor,
    Ih
];
$d = [
    {
        pack (i, e, t) {
            let r = i.getTime() / 1e3;
            if ((this.useTimestamp32 || i.getMilliseconds() === 0) && r >= 0 && r < 4294967296) {
                let { target: n , targetView: s , position: o  } = e(6);
                n[o++] = 214, n[o++] = 255, s.setUint32(o, r);
            } else if (r > 0 && r < 17179869184) {
                let { target: n , targetView: s , position: o  } = e(10);
                n[o++] = 215, n[o++] = 255, s.setUint32(o, i.getMilliseconds() * 4e6 + (r / 1e3 / 4294967296 >> 0)), s.setUint32(o + 4, r);
            } else if (isNaN(r)) {
                if (this.onInvalidDate) return e(0), t(this.onInvalidDate());
                let { target: n , targetView: s , position: o  } = e(3);
                n[o++] = 212, n[o++] = 255, n[o++] = 255;
            } else {
                let { target: n , targetView: s , position: o  } = e(15);
                n[o++] = 199, n[o++] = 12, n[o++] = 255, s.setUint32(o, i.getMilliseconds() * 1e6), s.setBigInt64(o + 4, BigInt(Math.floor(r)));
            }
        }
    },
    {
        pack (i, e, t) {
            let r = Array.from(i), { target: n , position: s  } = e(this.structuredClone ? 3 : 0);
            this.structuredClone && (n[s++] = 212, n[s++] = 115, n[s++] = 0), t(r);
        }
    },
    {
        pack (i, e, t) {
            let { target: r , position: n  } = e(this.structuredClone ? 3 : 0);
            this.structuredClone && (r[n++] = 212, r[n++] = 101, r[n++] = 0), t([
                i.name,
                i.message
            ]);
        }
    },
    {
        pack (i, e, t) {
            let { target: r , position: n  } = e(this.structuredClone ? 3 : 0);
            this.structuredClone && (r[n++] = 212, r[n++] = 120, r[n++] = 0), t([
                i.source,
                i.flags
            ]);
        }
    },
    {
        pack (i, e) {
            this.structuredClone ? wM(i, 16, e) : SM(ep ? Buffer.from(i) : new Uint8Array(i), e);
        }
    },
    {
        pack (i, e) {
            let t = i.constructor;
            t !== MM && this.structuredClone ? wM(i, Ny.indexOf(t.name), e) : SM(i, e);
        }
    },
    {
        pack (i, e) {
            let { target: t , position: r  } = e(1);
            t[r] = 193;
        }
    }
];
function wM(i, e, t, r) {
    let n = i.byteLength;
    if (n + 1 < 256) {
        var { target: s , position: o  } = t(4 + n);
        s[o++] = 199, s[o++] = n + 1;
    } else if (n + 1 < 65536) {
        var { target: s , position: o  } = t(5 + n);
        s[o++] = 200, s[o++] = n + 1 >> 8, s[o++] = n + 1 & 255;
    } else {
        var { target: s , position: o , targetView: a  } = t(7 + n);
        s[o++] = 201, a.setUint32(o, n + 1), o += 4;
    }
    s[o++] = 116, s[o++] = e, s.set(new Uint8Array(i.buffer, i.byteOffset, i.byteLength), o);
}
function SM(i, e) {
    let t = i.byteLength;
    var r, n;
    if (t < 256) {
        var { target: r , position: n  } = e(t + 2);
        r[n++] = 196, r[n++] = t;
    } else if (t < 65536) {
        var { target: r , position: n  } = e(t + 3);
        r[n++] = 197, r[n++] = t >> 8, r[n++] = t & 255;
    } else {
        var { target: r , position: n , targetView: s  } = e(t + 5);
        r[n++] = 198, s.setUint32(n, t), n += 4;
    }
    r.set(i, n);
}
function wO(i, e, t, r) {
    let n = i.length;
    switch(n){
        case 1:
            e[t++] = 212;
            break;
        case 2:
            e[t++] = 213;
            break;
        case 4:
            e[t++] = 214;
            break;
        case 8:
            e[t++] = 215;
            break;
        case 16:
            e[t++] = 216;
            break;
        default:
            n < 256 ? (e[t++] = 199, e[t++] = n) : n < 65536 ? (e[t++] = 200, e[t++] = n >> 8, e[t++] = n & 255) : (e[t++] = 201, e[t++] = n >> 24, e[t++] = n >> 16 & 255, e[t++] = n >> 8 & 255, e[t++] = n & 255);
    }
    return e[t++] = r, e.set(i, t), t += n, t;
}
function SO(i, e) {
    let t, r = e.length * 6, n = i.length - r;
    for(e.sort((s, o)=>s.offset > o.offset ? 1 : -1
    ); t = e.pop();){
        let s = t.offset, o = t.id;
        i.copyWithin(s + r, s, n), r -= 6;
        let a = s + r;
        i[a++] = 214, i[a++] = 105, i[a++] = o >> 24, i[a++] = o >> 16 & 255, i[a++] = o >> 8 & 255, i[a++] = o & 255, n = s;
    }
    return i;
}
function Yo(i) {
    if (i.Class) {
        if (!i.pack && !i.write) throw new Error("Extension has no pack or write function");
        if (i.pack && !i.type) throw new Error("Extension has no type (numeric code to identify the extension)");
        Fy.unshift(i.Class), $d.unshift(i);
    }
    xM(i);
}
var AM = new qo({
    useRecords: !1
}), MO = AM.pack, AO = AM.pack;
var { NEVER: TO , ALWAYS: EO , DECIMAL_ROUND: _O , DECIMAL_FIT: CO  } = Kd, TM = 512, DO = 1024;
var EM = new qo({
    structuredClone: !0
});
Yo({
    Class: jn.prototype.constructor,
    type: 1,
    write (i) {
        return ie({}, i);
    },
    read (i) {
        return Object.setPrototypeOf(i, jn.prototype), i;
    }
});
Yo({
    Class: rr.prototype.constructor,
    type: 2,
    write (i) {
        return [
            ...i
        ];
    },
    read (i) {
        return Object.setPrototypeOf(i, rr.prototype), i;
    }
});
Yo({
    Class: qn.prototype.constructor,
    type: 3,
    write (i) {
        return [
            ...i
        ];
    },
    read (i) {
        return Object.setPrototypeOf(i, qn.prototype), i;
    }
});
Yo({
    Class: Ph.prototype.constructor,
    type: 4,
    write (i) {
        return i.id;
    },
    read (i) {
        return new Ph(i);
    }
});
Yo({
    Class: Lh.prototype.constructor,
    type: 5,
    write (i) {
        return i.data;
    },
    read (i) {
        return new Lh(i);
    }
});
function PO(i) {
    var e = 0;
    if (i.length === 0) return e;
    for(let t = 0; t < i.length; t++){
        let r = i[t];
        e = (e << 5) - e + r, e = e & e;
    }
    return e;
}
var tp;
((r)=>{
    function i(n) {
        return EM.pack(n);
    }
    r.serialize = i;
    function e(n) {
        return EM.unpack(n);
    }
    r.deserialize = e;
    function t(n) {
        return PO(i(n)).toString();
    }
    r.checksum = t;
})(tp || (tp = {}));
var rp;
((t)=>{
    t.all = [
        "PointLight",
        "SpotLight",
        "DirectionalLight",
        "HemisphereLight"
    ];
    function e(r) {
        return t.all.includes(r);
    }
    t.is = e;
})(rp || (rp = {}));
var np;
((t)=>{
    function i(r) {
        return e(r);
    }
    t.defaultData = i;
    function e(r) {
        if (r === "PointLight") return {
            type: r,
            color: Ln.white,
            intensity: 1,
            distance: 2e3,
            decay: 1,
            shadows: !0,
            shadowResolution: 1024,
            shadowRadius: 1,
            depth: 2500,
            helper: !0
        };
        if (r === "SpotLight") return {
            type: r,
            color: Ln.white,
            intensity: 1,
            distance: 2e3,
            decay: 1,
            shadows: !0,
            penumbra: 0,
            angle: 30 / 180 * Math.PI,
            depth: 2500,
            helper: !0
        };
        if (r === "DirectionalLight") return {
            type: r,
            color: Ln.white,
            intensity: 1,
            shadows: !0,
            size: 2500,
            depth: 2500,
            helper: !0
        };
        throw new Error("not implemented");
    }
})(np || (np = {}));
var Uy;
((t)=>{
    t.defaultData = {
        castShadow: !0,
        receiveShadow: !0
    };
    function e(r, n) {
        return r.castShadow === n.castShadow && r.receiveShadow === n.receiveShadow;
    }
    t.equals = e;
})(Uy || (Uy = {}));
var zy;
((t)=>{
    t.defaultData = {
        flatShading: !1,
        wireframe: !1,
        side: 0
    };
    function e(r, n) {
        return r.flatShading === n.flatShading && r.side === n.side && r.wireframe === n.wireframe;
    }
    t.equals = e;
})(zy || (zy = {}));
var ip;
((e)=>e.defaultData = xe(ie(ie({}, zy.defaultData), Uy.defaultData), {
        cloner: null,
        booleanExclude: null
    })
)(ip || (ip = {}));
var Gy = ((n)=>(n[n.Left = 1] = "Left", n[n.Right = 2] = "Right", n[n.Center = 3] = "Center", n[n.Justify = 4] = "Justify", n)
)(Gy || {}), ky = ((r)=>(r[r.Top = 1] = "Top", r[r.Center = 2] = "Center", r[r.Bottom = 3] = "Bottom", r)
)(ky || {}), Vy = ((r)=>(r[r.None = 1] = "None", r[r.Upper = 2] = "Upper", r[r.Lower = 3] = "Lower", r)
)(Vy || {}), sp;
((e)=>e.defaultData = {
        width: 100,
        height: 100,
        horizontalAlign: 1,
        verticalAlign: 1,
        fontSize: 16,
        lineHeight: 1.5,
        letterSpacing: 1,
        text: "",
        textTransform: 1,
        color: Ln.fromHexAndA(6974058, 1),
        alpha: 1,
        font: "roboto_regular"
    }
)(sp || (sp = {}));
var _M = [
    "mode",
    "gradientType",
    "noiseType",
    "displacementType",
    "projection",
    "cnormal",
    "crop",
    "axis",
    "side"
];
var El;
((r)=>{
    function i(n, s) {
        return n === "light" && s ? e(s) : t(n);
    }
    r.defaultData = i;
    function e(n) {
        switch(n){
            case "basic":
                return {
                    type: "light",
                    category: "basic",
                    alpha: 1,
                    visible: !0,
                    mode: 0
                };
            case "phong":
                return {
                    category: "phong",
                    specular: {
                        r: .2,
                        g: .2,
                        b: .2
                    },
                    shininess: 10,
                    type: "light",
                    alpha: 1,
                    visible: !0,
                    mode: 0
                };
            case "toon":
                return {
                    category: "toon",
                    specular: {
                        r: .2,
                        g: .2,
                        b: .2
                    },
                    shininess: 10,
                    type: "light",
                    alpha: 1,
                    visible: !0,
                    mode: 0
                };
            case "lambert":
                return {
                    category: "lambert",
                    emissive: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 1
                    },
                    type: "light",
                    alpha: 1,
                    visible: !0,
                    mode: 0
                };
            case "physical":
                return {
                    category: "physical",
                    roughness: .2,
                    metalness: .2,
                    reflectivity: .2,
                    type: "light",
                    alpha: 1,
                    visible: !0,
                    mode: 0
                };
        }
    }
    function t(n) {
        switch(n){
            case "texture":
                return {
                    alpha: 1,
                    visible: !0,
                    size: [
                        128,
                        128
                    ],
                    mode: 0,
                    axis: "x",
                    side: 2,
                    type: "texture",
                    projection: 0,
                    texture: {
                        image: "image_0",
                        wrapping: 1001,
                        repeat: [
                            1,
                            1
                        ],
                        offset: [
                            0,
                            0
                        ]
                    },
                    crop: !0
                };
            case "color":
                return {
                    type: "color",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    color: Ar.fromHex(4737101)
                };
            case "depth":
                return {
                    type: "depth",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    gradientType: 1,
                    smooth: !1,
                    isVector: !0,
                    isWorldSpace: !1,
                    origin: [
                        0,
                        0,
                        0
                    ],
                    direction: [
                        1,
                        0,
                        0
                    ],
                    colors: [
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            0,
                            0,
                            0,
                            1
                        ]
                    ],
                    steps: [
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    num: 2,
                    near: 50,
                    far: 200
                };
            case "normal":
                return {
                    type: "normal",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    cnormal: [
                        1,
                        1,
                        1
                    ]
                };
            case "gradient":
                return {
                    type: "gradient",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    gradientType: 0,
                    smooth: !1,
                    colors: [
                        [
                            0,
                            0,
                            0,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ],
                        [
                            1,
                            1,
                            1,
                            1
                        ]
                    ],
                    steps: [
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ],
                    num: 2,
                    angle: 0,
                    offset: [
                        0,
                        0
                    ],
                    morph: [
                        0,
                        0
                    ]
                };
            case "noise":
                return {
                    type: "noise",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    size: [
                        100,
                        100,
                        100
                    ],
                    noiseType: 0,
                    scale: 1,
                    move: 1,
                    colorA: xe(ie({}, Ar.fromHex(6710886)), {
                        a: 1
                    }),
                    colorB: xe(ie({}, Ar.fromHex(6710886)), {
                        a: 1
                    }),
                    colorC: xe(ie({}, Ar.fromHex(16777215)), {
                        a: 1
                    }),
                    colorD: xe(ie({}, Ar.fromHex(16777215)), {
                        a: 1
                    }),
                    distortion: [
                        1,
                        1
                    ],
                    fA: [
                        1.7,
                        9.2
                    ],
                    fB: [
                        8.3,
                        2.8
                    ]
                };
            case "fresnel":
                return {
                    type: "fresnel",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    color: Ln.fromHexAndA(16777215, 1),
                    bias: .1,
                    scale: 1,
                    intensity: 2,
                    factor: 1
                };
            case "rainbow":
                return {
                    type: "rainbow",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    filmThickness: 30,
                    movement: 0,
                    wavelengths: [
                        0,
                        0,
                        0
                    ],
                    noiseStrength: 0,
                    noiseScale: 1,
                    offset: [
                        0,
                        0,
                        0
                    ]
                };
            case "matcap":
                return {
                    type: "matcap",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    texture: {
                        image: "matcap_0",
                        wrapping: 1001,
                        repeat: [
                            1,
                            1
                        ],
                        offset: [
                            0,
                            0
                        ]
                    }
                };
            case "transmission":
                return {
                    type: "transmission",
                    alpha: 1,
                    visible: !0,
                    mode: 0,
                    thickness: 10,
                    ior: 1.5,
                    roughness: 1
                };
            case "displace":
                return {
                    type: "displace",
                    displacementType: "noise",
                    noiseType: 0,
                    scale: 10,
                    movement: 1,
                    offset: [
                        0,
                        0,
                        0
                    ],
                    intensity: 8,
                    visible: !0
                };
        }
    }
})(El || (El = {}));
var hi;
((a)=>{
    function i(l) {
        return !l.layers.some((h)=>{
            if (h.data.type === "texture" && h.data.projection !== 0 || h.data.type === "depth" && !h.data.isWorldSpace || h.data.type === "noise" || h.data.type === "displace") return !0;
        }) && !t(l);
    }
    a.isMergable = i;
    function e(l) {
        let c = "";
        return l.layers.forEach((h)=>{
            Object.entries(h.data).forEach(([u, f])=>{
                c += `${u}${f}`, Array.isArray(f) ? f.forEach((d)=>c += `${d}`
                ) : typeof f == "object" ? Object.values(f).forEach((d)=>{
                    typeof d == "number" ? c += `${d.toFixed(4)}` : c += `${d}`;
                }) : c += `${f}`;
            });
        }), c;
    }
    a.getHash = e;
    function t(l) {
        let c = 0;
        for (let h of l.layers)"alpha" in h.data && h.data.type !== "light" && h.data.type !== "fresnel" && (c += (1 - c) * h.data.alpha);
        return c < 1;
    }
    a.isTransparent = t;
    function r() {
        return {
            layers: new rr
        };
    }
    a.defaultEmptyData = r;
    function n(l = "layer1", c = "layer2") {
        return s("phong", l, c);
    }
    a.defaultData = n;
    function s(l, c = "layer1", h = "layer2") {
        let u = new rr;
        return u.push({
            fi: 0,
            data: El.defaultData("light", l),
            id: c
        }), u.push({
            fi: 1,
            data: El.defaultData("color"),
            id: h
        }), {
            layers: u
        };
    }
    a.defaultTwoLayerData = s;
    function o(l, c = "basic", h = "layer1", u = "layer2") {
        let f = El.defaultData("texture");
        Object.assign(f.texture, {
            image: l
        });
        let d = new rr;
        return d.push({
            fi: 0,
            data: f,
            id: h
        }), d.push({
            fi: 1,
            data: El.defaultData("light", c),
            id: u
        }), {
            layers: d
        };
    }
    a.defaultTwoLayerTextureData = o;
})(hi || (hi = {}));
var _l;
((e)=>{
    function i() {
        return {
            points: new rr,
            roundness: 0,
            shapeHoles: [],
            isClosed: !1
        };
    }
    e.defaultData = i;
})(_l || (_l = {}));
var op;
((e)=>{
    function i(t) {
        return t === "PolygonGeometry" || t === "RectangleGeometry" || t === "StarGeometry" || t === "TriangleGeometry" || t === "EllipseGeometry";
    }
    e.is2DParametricMesh = i;
})(op || (op = {}));
var Bh;
((e)=>{
    function i(t) {
        if (t === "RectangleGeometry") return {
            width: 320,
            height: 320,
            type: t,
            cornerRadius: [
                0,
                0,
                0,
                0
            ],
            cornerType: 0,
            depth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1
        };
        if (t === "VectorGeometry") return {
            width: 1,
            height: 1,
            type: t,
            subdivisions: 12,
            shape: _l.defaultData(),
            depth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1
        };
        if (t === "BooleanGeometry") return {
            type: t,
            operation: 2,
            width: 0,
            height: 0,
            depth: 0
        };
        throw new Error("not implemented");
    }
    e.defaultData = i;
})(Bh || (Bh = {}));
var Nh;
((n)=>{
    n.identity = xe(ie({}, Nd.identity), {
        hiddenMatrix: Pi.identity
    });
    function e(s) {
        return {
            position: s.position,
            rotation: s.rotation,
            scale: s.scale,
            hiddenMatrix: s.hiddenMatrix
        };
    }
    n.fromObject = e;
    function t(s, o) {
        return {
            position: (o == null ? void 0 : o.position) || s.position,
            rotation: (o == null ? void 0 : o.rotation) || s.rotation,
            scale: (o == null ? void 0 : o.scale) || s.scale,
            hiddenMatrix: (o == null ? void 0 : o.hiddenMatrix) || s.hiddenMatrix
        };
    }
    n.merge = t;
    function r(s, o) {
        return {
            position: br.isEqual(s.position, o.position) ? null : o.position,
            rotation: br.isEqual(s.rotation, o.rotation) ? null : o.rotation,
            scale: br.isEqual(s.scale, o.scale) ? null : o.scale,
            hiddenMatrix: Pi.isEqual(s.hiddenMatrix, o.hiddenMatrix) ? null : o.hiddenMatrix
        };
    }
    n.diff = r;
})(Nh || (Nh = {}));
var ds;
((e)=>e.defaultData = ie({
        states: new rr,
        events: new rr,
        visible: !0,
        raycastLock: !1
    }, Nh.identity)
)(ds || (ds = {}));
var CM;
((e)=>e.defaultData = ie({
        type: "Empty"
    }, ds.defaultData)
)(CM || (CM = {}));
var ap;
((e)=>e.defaultData = ie(ie({
        type: "Mesh"
    }, ds.defaultData), ip.defaultData)
)(ap || (ap = {}));
var DM;
((e)=>e.defaultData = ie(ie({
        type: "TextFrame"
    }, ds.defaultData), sp.defaultData)
)(DM || (DM = {}));
var lp;
((e)=>e.defaultData = ie(ie(ie({}, ds.defaultData), Nh.identity), Wo.defaultData)
)(lp || (lp = {}));
var PM;
((e)=>{
    function i(t) {
        return ie(ie({}, ds.defaultData), np.defaultData(t));
    }
    e.defaultData = i;
})(PM || (PM = {}));
var LM;
((r)=>(r.defaultCamera = ie({
        position: [
            0,
            0,
            1e3
        ],
        scale: [
            1,
            1,
            1
        ],
        rotation: [
            0,
            0,
            0
        ],
        hiddenMatrix: Pi.identity,
        name: "Play Camera",
        visible: !0,
        raycastLock: !1,
        states: new rr,
        events: new rr
    }, Wo.defaultData), r.defaultMeshObject = xe(ie(ie({
        name: "Rectangle"
    }, ds.defaultData), ap.defaultData), {
        geometry: Bh.defaultData("RectangleGeometry"),
        material: hi.defaultTwoLayerData("basic", "layer1", "layer2")
    }), r.defaultBooleanObject = xe(ie(ie({
        name: "Boolean"
    }, ds.defaultData), ap.defaultData), {
        geometry: Bh.defaultData("BooleanGeometry"),
        material: hi.defaultTwoLayerData("phong", "layer1", "layer2")
    }))
)(LM || (LM = {}));
var Oh;
((t)=>{
    function i(r, n) {
        if (n === void 0) return r;
        let s = ie({}, r);
        return "material" in s && "material" in n && n.material && (s.material = Ty(s.material, (o)=>{
            if (typeof o != "string") for (let [a, l] of Object.entries(n.material.layers)){
                let c = o.layers.data(a);
                c && Vo(c, l);
            }
        }).data), s.materials && n.materials && (s.materials = Ty(s.materials, (o)=>{
            var a, l;
            for(let c = 0; c < s.materials.length; c++){
                let h = n.materials[c];
                if (typeof h != "string") for (let [u, f] of Object.entries(h.layers)){
                    let d = (l = (a = o[c]) == null ? void 0 : a.layers) == null ? void 0 : l.data(u);
                    d && Vo(d, f);
                }
            }
        }).data), s;
    }
    t.patchMaterialState = i;
    function e(r, n) {
        var o, a;
        if (n === void 0) return r;
        let s = ie({}, r);
        if (Object.assign(s, Nh.merge(s, n)), eo.is(r.type)) {
            s.orthographic = ie({}, s.orthographic), s.perspective = ie({}, s.perspective);
            let l = n;
            ((o = l.orthographic) == null ? void 0 : o.zoom) !== void 0 && (s.orthographic.zoom = l.orthographic.zoom), ((a = l.perspective) == null ? void 0 : a.zoom) !== void 0 && (s.perspective.zoom = l.perspective.zoom);
        } else if (r.type === "Mesh") s.geometry = ie({}, s.geometry), Object.assign(s.geometry, n.geometry), s = i(s, n);
        else if (rp.is(r.type)) {
            let l = n;
            s.intensity !== void 0 && (s.intensity = l.intensity), l.color !== void 0 && (typeof l.color == "string" ? s.color = l.color : s.color = Ar.clone(l.color));
        }
        return s;
    }
    t.patch = e;
})(Oh || (Oh = {}));
function RM(i, e = !1) {
    let t = i[0].index !== null, r = new Set(Object.keys(i[0].attributes)), n = new Set(Object.keys(i[0].morphAttributes)), s = {}, o = {}, a = i[0].morphTargetsRelative, l = new Le, c = 0;
    for(let h = 0; h < i.length; ++h){
        let u = i[h], f = 0;
        if (t !== (u.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
        for(let d in u.attributes){
            if (!r.has(d)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + d + '" attribute exists among all geometries, or in none of them.'), null;
            s[d] === void 0 && (s[d] = []), s[d].push(u.attributes[d]), f++;
        }
        if (f !== r.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null;
        if (a !== u.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
        for(let d10 in u.morphAttributes){
            if (!n.has(d10)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null;
            o[d10] === void 0 && (o[d10] = []), o[d10].push(u.morphAttributes[d10]);
        }
        if (l.userData.mergedUserData = l.userData.mergedUserData || [], l.userData.mergedUserData.push(u.userData), e) {
            let d;
            if (t) d = u.index.count;
            else if (u.attributes.position !== void 0) d = u.attributes.position.count;
            else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null;
            l.addGroup(c, d, h), c += d;
        }
    }
    if (t) {
        let h = 0, u = [];
        for(let f = 0; f < i.length; ++f){
            let d = i[f].index;
            for(let p = 0; p < d.count; ++p)u.push(d.getX(p) + h);
            h += i[f].attributes.position.count;
        }
        l.setIndex(u);
    }
    for(let h7 in s){
        let u = IM(s[h7]);
        if (!u) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + h7 + " attribute."), null;
        l.setAttribute(h7, u);
    }
    for(let h8 in o){
        let u = o[h8][0].length;
        if (u === 0) break;
        l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[h8] = [];
        for(let f = 0; f < u; ++f){
            let d = [];
            for(let m = 0; m < o[h8].length; ++m)d.push(o[h8][m][f]);
            let p = IM(d);
            if (!p) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + h8 + " morphAttribute."), null;
            l.morphAttributes[h8].push(p);
        }
    }
    return l;
}
function IM(i) {
    let e, t, r, n = 0;
    for(let a = 0; a < i.length; ++a){
        let l = i[a];
        if (l.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null;
        if (e === void 0 && (e = l.array.constructor), e !== l.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
        if (t === void 0 && (t = l.itemSize), t !== l.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
        if (r === void 0 && (r = l.normalized), r !== l.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
        n += l.array.length;
    }
    let s = new e(n), o = 0;
    for(let a10 = 0; a10 < i.length; ++a10)s.set(i[a10].array, o), o += i[a10].array.length;
    return new Ve(s, t, r);
}
var Hy = {
    type: "change"
}, BM = {
    type: "changeZoom"
}, LO = {
    type: "changePan"
}, Cl = {
    type: "start"
}, Fh = {
    type: "end"
}, Wy = new zt, IO = new B, RO = 2 * Math.PI, BO = 1e-8, NO = .01, NM = 2, jy = .125, OM = 2, qy = 1, Yy = 1, Xy = .1;
var cp = class extends Yt {
    constructor(t7, r6){
        super();
        this.object = t7;
        this.domElement = r6;
        this.enabled = !0;
        this.useKeyEvents = !0;
        this.enableDamping = !1;
        this.enableZoom = !0;
        this.enableRotate = !0;
        this.enablePan = !0;
        this.autoRotate = !1;
        this.rotationLimitsMode = 0;
        this.panLimitsMode = 0;
        this.rotationSoftLimit = 2;
        this.panSoftLimit = 2;
        this.hoverRotatePanMode = 0;
        this.zoomLimitsEnabled = !1;
        this.preventScroll = !0;
        this.mouseButtons = [
            0,
            5
        ];
        this.mouseButtonsPlay = [
            3,
            4,
            5
        ];
        this.touches = [
            null,
            Cn.DOLLY_ROTATE,
            Cn.PAN
        ];
        this.offset = new M;
        this.eye = new M;
        this.lastPosition = new M;
        this.lastQuaternion = new zt;
        this.current = new B;
        this.overShoot = new B;
        this.overRatio = new B;
        this.spherical = new uh;
        this.sphericalDelta = new uh;
        this.panOffset = new M;
        this.panLeftV = new M;
        this.panUpV = new M;
        this.panV = new M;
        this.rotateStart = new B;
        this.rotateEnd = new B;
        this.rotateDelta = new B;
        this.panStart = new B;
        this.panEnd = new B;
        this.panDelta = new B;
        this.dollyStart = new B;
        this.dollyEnd = new B;
        this.dollyDelta = new B;
        this.rotationRangeFactor = new B;
        this.panRangeFactor = new B;
        this.state = -1;
        this.zoomChanged = !1;
        this.isPointerDown = !1;
        this.isFirstHover = !0;
        this.isThetaFlipped = !1;
        this.prevScale = 0;
        this.scale = 1;
        this.gesture = !1;
        this.timer = -1;
        this.timerHover = -1;
        this.minDistance = 0;
        this.maxDistance = 1 / 0;
        this.minZoom = 0;
        this.maxZoom = 1 / 0;
        this.minPhi = 0;
        this.maxPhi = Math.PI;
        this.minTheta = -1 / 0;
        this.maxTheta = 1 / 0;
        this.minH = 0;
        this.maxH = Math.PI;
        this.minV = -1 / 0;
        this.maxV = 1 / 0;
        this.autoRotateClockwise = !0;
        this.isPanOverShoot = !1;
        this.isRotateOverShoot = !1;
        this.update = ()=>{
            let t = this.object.position;
            this.offset.copy(t).sub(this.target), this.spherical.setFromVector3(this.offset), this.object.isUpVectorFlipped && (this.spherical.phi *= -1, this.spherical.theta -= Math.PI), this.autoRotate && this.state === -1 && this.rotateLeft((this.autoRotateClockwise === !0 ? 1 : -1) * this.getAutoRotationAngle()), this.rotationLimitsMode !== 0 && this.applyLimits(this.sphericalDelta, this.rotationLimitsMode, this.rotationSoftLimit, this.maxTheta, this.minTheta, this.maxPhi, this.minPhi, this.rotationRangeFactor), this.rotationLimitsMode !== 2 && (this.spherical.phi += this.sphericalDelta.phi), (this.rotationLimitsMode !== 1 || this.autoRotate === !0) && (this.spherical.theta += this.sphericalDelta.theta), this.spherical.radius *= this.scale, this.zoomLimitsEnabled && (this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius))), this.panLimitsMode !== 0 && (this.target.applyQuaternion(Wy.copy(this.object.quaternion).invert()), this.panOffset.applyQuaternion(Wy), this.applyLimits(this.panOffset, this.panLimitsMode, this.panSoftLimit, this.maxH, this.minH, this.maxV, this.minV, this.panRangeFactor), this.target.applyQuaternion(this.object.quaternion), this.panOffset.applyQuaternion(this.object.quaternion)), this.panLimitsMode === 2 && (this.panOffset.y = 0), this.panLimitsMode === 1 && (this.panOffset.x = 0), this.state === -1 && !this.gesture ? (this.panOffset.multiplyScalar(1 - jy), this.target.add(this.panOffset)) : (this.target.add(this.panOffset), this.panOffset.set(0, 0, 0)), this.offset.setFromSpherical(this.spherical), t.copy(this.target).add(this.offset);
            let r = this.spherical.phi % RO;
            return this.eye.copy(this.offset).normalize(), this.object.up.copy(ot.DefaultUp).applyAxisAngle(this.eye, this.object.angleOffsetFromUp), r > 0 && r > Math.PI || r < 0 && r > -Math.PI ? (this.object.up.negate(), this.object.lookAt(this.target), this.object.isUpVectorFlipped = !0) : (this.object.lookAt(this.target), this.object.isUpVectorFlipped = !1), this.state === -1 || this.enableDamping === !0 ? (this.sphericalDelta.theta *= 1 - jy, this.sphericalDelta.phi *= 1 - jy) : this.sphericalDelta.set(0, 0, 0), this.scale = 1, this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > NO || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > BO ? (this.dispatchEvent(Hy), this.lastPosition.copy(this.object.position), this.lastQuaternion.copy(this.object.quaternion), this.zoomChanged = !1, !0) : (this.isPanOverShoot = !1, this.isRotateOverShoot = !1, this.sphericalDelta.set(0, 0, 0), this.panOffset.set(0, 0, 0), !1);
        };
        this.onPointerDown = (t)=>{
            this.enabled !== !1 && (this.isPointerDown = !0, At.length === 0 && (this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp)), FO(t), t.pointerType === "touch" ? this.onPointerDownTouch(t) : this.onPointerDownMouse(t));
        };
        this.onPointerMove = (t)=>{
            this.enabled !== !1 && (t.pointerType === "touch" ? this.onPointerMoveTouch(t) : this.onPointerMoveMouse(t));
        };
        this.onPointerUp = (t)=>{
            UM(t), this.isPointerDown = !1, At.length === 0 && (this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this.onPointerUp)), this.dispatchEvent(Fh), this.state = -1;
        };
        this.onPointerCancel = (t)=>{
            UM(t);
        };
        this.onPointerDownMouse = (t)=>{
            let r;
            switch(this.useKeyEvents ? r = this.mouseButtons[t.button] : r = this.mouseButtonsPlay[t.button], r){
                case 0:
                    if (t.altKey === !0 && !t.shiftKey && !_h(t)) {
                        if (this.enableRotate === !1) return;
                        this.handleMouseDownRotate(t), this.state = 0;
                    } else if (this.key === " ") {
                        if (this.enablePan === !1) return;
                        this.handleMouseDownPan(t), this.state = 2;
                    }
                    break;
                case 4:
                    if (this.enablePan === !1) return;
                    this.handleMouseDownPan(t), this.state = 2;
                    break;
                case 3:
                    if (_h(t) || t.shiftKey) {
                        if (this.enablePan === !1) return;
                        this.handleMouseDownPan(t), this.state = 2;
                    } else {
                        if (this.enableRotate === !1) return;
                        this.handleMouseDownRotate(t), this.state = 0;
                    }
                    break;
                case 5:
                    if (_h(t) || t.shiftKey) {
                        if (this.enableRotate === !1) return;
                        this.handleMouseDownRotate(t), this.state = 0;
                    } else {
                        if (this.enablePan === !1) return;
                        this.handleMouseDownPan(t), this.state = 2;
                    }
                    break;
                default:
                    this.state = -1;
            }
            this.state !== -1 && this.dispatchEvent(Cl);
        };
        this.onPointerMoveMouse = (t)=>{
            switch(this.state){
                case 0:
                    if (this.enableRotate === !1) return;
                    this.handleMouseMoveRotate(t);
                    break;
                case 1:
                    if (this.enableZoom === !1) return;
                    this.handleMouseMoveDolly(t);
                    break;
                case 2:
                    if (this.enablePan === !1) return;
                    this.handleMouseMovePan(t);
                    break;
            }
        };
        this.onPointerDownTouch = (t)=>{
            switch(zM(t), this.touches[At.length - 1]){
                case Cn.ROTATE:
                    if (this.enableRotate === !1) {
                        this.state = -1;
                        return;
                    }
                    this.handleTouchStartRotate(), this.state = 3;
                    break;
                case Cn.PAN:
                    if (this.enablePan === !1) {
                        this.state = -1;
                        return;
                    }
                    this.handleTouchStartPan(), this.state = 4;
                    break;
                case Cn.DOLLY_PAN:
                    if (this.enableZoom === !1 && this.enablePan === !1) return;
                    this.handleTouchStartDollyPan(), this.state = 5;
                    break;
                case Cn.DOLLY_ROTATE:
                    if (this.enableZoom === !1 && this.enableRotate === !1) return;
                    this.handleTouchStartDollyRotate(), this.state = 6;
                    break;
                default:
                    this.state = -1;
            }
            this.state !== -1 && this.dispatchEvent(Cl);
        };
        this.onPointerMoveTouch = (t)=>{
            switch(zM(t), this.state){
                case 3:
                    if (this.enableRotate === !1) return;
                    this.handleTouchMoveRotate(t), this.update();
                    break;
                case 4:
                    if (this.enablePan === !1) return;
                    this.handleTouchMovePan(t), this.update();
                    break;
                case 5:
                    if (this.enableZoom === !1 && this.enablePan === !1) return;
                    this.handleTouchMoveDollyPan(t), this.update();
                    break;
                case 6:
                    if (this.enableZoom === !1 && this.enableRotate === !1) return;
                    this.handleTouchMoveDollyRotate(t), this.update();
                    break;
                default:
                    this.state = -1;
            }
        };
        this.dispatchEndDebounced = Mh(()=>this.dispatchEvent(Fh)
        , 33);
        this.onMouseWheel = (t)=>{
            this.enabled === !1 || this.enableZoom === !1 && this.enablePan === !1 || ((this.domElement.clientHeight === document.body.clientHeight && this.domElement.clientWidth === document.body.clientWidth || this.preventScroll) && t.preventDefault(), this.dispatchEvent(Cl), this.handleMouseWheel(t), this.dispatchEndDebounced());
        };
        this.onGesture = (t)=>{
            if (this.enabled !== !1) {
                if (t.preventDefault(), t.type === "gesturechange") {
                    if (this.enableZoom === !1) return;
                    this.dispatchEvent(Cl), t.scale > this.prevScale ? this.dollyIn(this.getZoomScale()) : t.scale < this.prevScale && this.dollyOut(this.getZoomScale()), this.prevScale = t.scale, this.update();
                } else this.dispatchEvent(Fh);
            }
        };
        this.onContextMenu = (t)=>{
            this.enabled !== !1 && t.preventDefault();
        };
        this.onTouchMove = (t)=>{
            (t.touches.length > 1 || this.preventScroll) && t.preventDefault();
        };
        this.onTouchEnd = (t)=>{
            t.preventDefault();
        };
        this.onKeyDown = (t)=>{
            this.enabled !== !1 && (this.key = t.key);
        };
        this.onKeyUp = ()=>{
            this.enabled !== !1 && (this.key = void 0, this.state !== -1 && this.onPointerUp(At[0]));
        };
        this.onPointerHover = (t)=>{
            if (!(Bd || this.enabled === !1 || this.state !== -1 || this.hoverRotatePanMode === 2 && this.isPanOverShoot || this.hoverRotatePanMode === 1 && this.isRotateOverShoot)) {
                if (window.clearTimeout(this.timerHover), this.isPointerDown = !0, this.isFirstHover) {
                    let r = {
                        clientX: window.innerWidth / 2,
                        clientY: window.innerHeight / 2
                    };
                    this.hoverRotatePanMode === 2 ? this.handleMouseDownPan(r) : this.hoverRotatePanMode === 1 && this.handleMouseDownRotate(r), this.isFirstHover = !1;
                }
                this.hoverRotatePanMode === 2 ? this.handleMouseMovePan(t, Xy) : this.hoverRotatePanMode === 1 && this.handleMouseMoveRotate(t, Xy), this.timerHover = window.setTimeout(()=>{
                    this.isPointerDown = !1;
                }, 30);
            }
        };
        this.object = t7, this.domElement = r6, this.target = this.object.getTarget(), this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.connect(), this.update();
    }
    reset() {
        this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(Hy), this.isFirstHover = !0, this.update(), this.state = -1;
    }
    resetTo(t, r, n) {
        this.target.copy(t), this.object.position.copy(r), this.object.zoom = n, this.object.updateProjectionMatrix(), this.dispatchEvent(Hy), this.update(), this.state = -1;
    }
    fromJSON(t) {
        this.setEnableDampingSpeed(t.enableDamping), this.enablePan = t.enablePan, this.enableZoom = t.enableZoom, this.enableRotate = t.enableRotate, this.rotationLimitsMode = t.rotationLimitsMode, this.panLimitsMode = t.panLimitsMode, this.panSoftLimit = t.panSoftLimit, this.rotationSoftLimit = t.rotationSoftLimit, this.hoverRotatePanMode = t.hoverRotatePanMode, this.isFirstHover = !0, this.hoverRotatePanMode !== 0 && this.domElement.addEventListener("pointermove", this.onPointerHover), Xy = (t.hoverRotatePanStrength / 100) ** 2, this.zoomLimitsEnabled = t.zoomLimitsEnabled, this.minZoom = t.zoomLimits.min, this.maxZoom = Math.max(t.zoomLimits.min, t.zoomLimits.max), this.minDistance = 1e3 / t.zoomLimits.max, this.maxDistance = Math.max(this.minDistance, 1e3 / t.zoomLimits.min), this.autoRotate = t.autoRotate, NM = t.autoRotateSpeed, this.autoRotateClockwise = t.autoRotateClockwise;
        let n = this.object.getTarget().applyQuaternion(Wy.copy(this.object.quaternion).invert());
        this.minV = -t.panVerticalOffset.min + n.y, this.maxV = t.panVerticalOffset.max + n.y, this.minH = -t.panHorizontalOffset.min + n.x, this.maxH = t.panHorizontalOffset.max + n.x, this.panRangeFactor.set(this.maxH - this.minH, this.maxV - this.minV).divideScalar(2), this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4), this.minPhi = no(this.spherical.phi - t.rotationVerticalOffset.min), this.maxPhi = no(this.spherical.phi + t.rotationVerticalOffset.max), this.minTheta = no(this.spherical.theta - t.rotationHorizontalOffset.min), this.maxTheta = no(this.spherical.theta + t.rotationHorizontalOffset.max), this.isThetaFlipped = this.minTheta > this.maxTheta, this.preventScroll = t.preventScroll, t.orbitTouches === 1 && (this.touches[0] = Cn.ROTATE), t.panTouches === 1 && (this.touches[0] = Cn.PAN), t.orbitTouches === 2 && (this.touches[1] = Cn.DOLLY_ROTATE), t.panTouches === 2 && (this.touches[1] = Cn.DOLLY_PAN), t.orbitTouches === 3 && (this.touches[2] = Cn.ROTATE), t.panTouches === 3 && (this.touches[2] = Cn.PAN);
    }
    connect() {
        this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointercancel", this.onPointerCancel), this.domElement.addEventListener("wheel", this.onMouseWheel), window.addEventListener("keydown", this.onKeyDown, !1), window.addEventListener("keyup", this.onKeyUp, !1), Ho || (this.domElement.addEventListener("gesturestart", this.onGesture), this.domElement.addEventListener("gesturechange", this.onGesture), this.domElement.addEventListener("gestureend", this.onGesture)), this.domElement.addEventListener("touchmove", this.onTouchMove), this.domElement.addEventListener("touchend", this.onTouchEnd);
    }
    dispose() {
        this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("pointerdown", this.onPointerDown), this.domElement.removeEventListener("pointercancel", this.onPointerCancel), this.domElement.removeEventListener("wheel", this.onMouseWheel), window.removeEventListener("keydown", this.onKeyDown, !1), window.removeEventListener("keyup", this.onKeyUp, !1), this.domElement.removeEventListener("pointermove", this.onPointerHover), Ho || (this.domElement.removeEventListener("gesturestart", this.onGesture), this.domElement.removeEventListener("gesturechange", this.onGesture), this.domElement.removeEventListener("gestureend", this.onGesture)), this.domElement.removeEventListener("touchmove", this.onTouchMove), this.domElement.removeEventListener("touchend", this.onTouchEnd), this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this.onPointerUp);
    }
    applyLimits(t, r, n, s, o, a, l, c) {
        this.overShoot.set(0, 0);
        let h, u, f;
        t instanceof M ? (h = t.x, u = t.y, this.current.set(this.target.x, this.target.y), f = !0) : (h = t.theta, u = t.phi, this.current.set(no(this.spherical.theta), no(this.spherical.phi)), f = !1), n === 0 && (this.current.x += h, this.current.y += u), (r === 3 || r === 2) && (!f && this.isThetaFlipped ? this.current.x > s && this.current.x < 0 ? this.overShoot.x = s - this.current.x : this.current.x < o && this.current.x > 0 && (this.overShoot.x = o - this.current.x) : this.current.x > s ? this.overShoot.x = s - this.current.x : this.current.x < o && (this.overShoot.x = o - this.current.x), s === o && (h = 0)), (r === 3 || r === 1) && (this.current.y > a ? this.overShoot.y = a - this.current.y : this.current.y < l && (this.overShoot.y = l - this.current.y), a === l && (u = 0)), f || (this.overShoot.x = no(this.overShoot.x), this.overShoot.y = no(this.overShoot.y)), n !== 0 ? (this.overRatio.copy(this.overShoot).divide(c), this.overRatio.x = Math.min(Math.abs(this.overRatio.x), 1), this.overRatio.y = Math.min(Math.abs(this.overRatio.y), 1), n === 1 && (this.overRatio.x = FM(Math.abs(this.overRatio.x)), this.overRatio.y = FM(Math.abs(this.overRatio.y))), this.isPointerDown || n === 1 ? n === 2 && (this.overRatio.x > .9 || this.overRatio.y > .9) ? this.isPointerDown = !1 : (h * this.overShoot.x < 0 && (h *= 1 - this.overRatio.x), u * this.overShoot.y < 0 && (u *= 1 - this.overRatio.y)) : n === 2 && (!f && (this.overRatio.x > .002 || this.overRatio.y > .002) || f && (Math.abs(this.overShoot.x) > 2 || Math.abs(this.overShoot.y) > 2) ? (h = this.overShoot.x * .05, u = this.overShoot.y * .05, f ? this.isPanOverShoot = !0 : this.isRotateOverShoot = !0) : f ? this.isPanOverShoot = !1 : this.isRotateOverShoot = !1)) : (h += this.overShoot.x, u += this.overShoot.y), t instanceof M ? (t.x = h, t.y = u) : (t.theta = h, t.phi = u);
    }
    setEnableDampingSpeed(t) {
        this.enableDamping = t, qy = t === !0 ? .2 : 1;
    }
    stopDamping() {
        this.sphericalDelta.theta = 0, this.sphericalDelta.phi = 0;
    }
    getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * NM;
    }
    getZoomScale() {
        return Math.pow(.95, OM);
    }
    rotateLeft(t) {
        this.sphericalDelta.theta -= t;
    }
    rotateUp(t) {
        this.sphericalDelta.phi -= t;
    }
    panLeft(t, r) {
        this.panLeftV.setFromMatrixColumn(r, 0), this.panLeftV.multiplyScalar(-t), this.panOffset.add(this.panLeftV);
    }
    panUp(t, r) {
        this.panUpV.setFromMatrixColumn(r, 1), this.panUpV.multiplyScalar(t), this.panOffset.add(this.panUpV);
    }
    pan(t, r) {
        let n = this.domElement;
        if (n && this.object.isPerspectiveCamera) {
            let s = this.object.position;
            this.panV.copy(s).sub(this.target);
            let o = this.panV.length();
            o *= Math.tan(this.object.fov / 2 * Math.PI / 180), this.panLeft(2 * t * o / n.clientHeight, this.object.matrix), this.panUp(2 * r * o / n.clientHeight, this.object.matrix);
        } else n && this.object.isOrthographicCamera && (this.panLeft(t * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this.panUp(r * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix));
        this.dispatchEvent(LO);
    }
    dollyOut(t) {
        this.object.isPerspectiveCamera ? this.scale /= t : this.object.isOrthographicCamera && (this.object.zoom *= t, this.zoomLimitsEnabled && (this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom))), this.object.updateProjectionMatrix(), this.zoomChanged = !0), this.dispatchEvent(BM);
    }
    dollyIn(t) {
        this.object.isPerspectiveCamera ? this.scale *= t : this.object.isOrthographicCamera && (this.object.zoom /= t, this.zoomLimitsEnabled && (this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom))), this.object.updateProjectionMatrix(), this.zoomChanged = !0), this.dispatchEvent(BM);
    }
    zoomOut(t = this.getZoomScale()) {
        this.dispatchEvent(Cl), this.dollyOut(t), this.dispatchEvent(Fh);
    }
    zoomIn(t = this.getZoomScale()) {
        this.dispatchEvent(Cl), this.dollyIn(t), this.dispatchEvent(Fh);
    }
    handleMouseDownRotate(t) {
        this.rotateStart.set(t.clientX, t.clientY);
    }
    handleMouseDownDolly(t) {
        this.dollyStart.set(t.clientX, t.clientY);
    }
    handleMouseDownPan(t) {
        this.panStart.set(t.clientX, t.clientY);
    }
    handleMouseMoveRotate(t, r = 1) {
        this.rotateEnd.set(t.clientX, t.clientY), this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(qy * r).rotateAround(IO, -this.object.angleOffsetFromUp);
        let n = this.domElement;
        this.rotateLeft(2 * Math.PI * this.rotateDelta.x / n.clientHeight), this.rotateUp(2 * Math.PI * this.rotateDelta.y / n.clientHeight), this.rotateStart.copy(this.rotateEnd), this.update();
    }
    handleMouseMoveDolly(t) {
        this.dollyEnd.set(t.clientX, t.clientY), this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart), this.dollyDelta.y > 0 ? this.dollyOut(this.getZoomScale()) : this.dollyDelta.y < 0 && this.dollyIn(this.getZoomScale()), this.dollyStart.copy(this.dollyEnd), this.update();
    }
    handleMouseMovePan(t, r = 1) {
        this.panEnd.set(t.clientX, t.clientY), this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(Yy * r), this.pan(this.panDelta.x, this.panDelta.y), this.panStart.copy(this.panEnd), this.update();
    }
    handleMouseWheel(t) {
        if (JS === !1 && _h(t) === !1 && OO(t) === !0) {
            if (this.enablePan === !1) return;
            this.gesture ? (this.panDelta.set(-t.deltaX, -t.deltaY).multiplyScalar(Yy), this.panDelta.x = Math.min(Math.abs(this.panDelta.x), 100) * (this.panDelta.x < 0 ? -1 : 1), this.panDelta.y = Math.min(Math.abs(this.panDelta.y), 100) * (this.panDelta.y < 0 ? -1 : 1), t.altKey ? this.pan(0, this.panDelta.y) : t.shiftKey ? this.pan(this.panDelta.x, 0) : this.pan(this.panDelta.x, this.panDelta.y), this.update()) : (this.gesture = !0, this.isPointerDown = !0), window.clearTimeout(this.timer), this.timer = window.setTimeout(()=>{
                this.gesture = !1, this.isPointerDown = !1;
            }, 30);
        } else {
            if (this.enableZoom === !1) return;
            t.deltaY === 0 ? t.deltaX < 0 ? this.dollyIn(this.getZoomScale()) : t.deltaX > 0 && this.dollyOut(this.getZoomScale()) : t.deltaY < 0 ? this.dollyIn(this.getZoomScale()) : t.deltaY > 0 && this.dollyOut(this.getZoomScale()), this.update(), this.gesture = !1, this.isPointerDown = !1;
        }
    }
    handleTouchStartRotate() {
        if (At.length === 2) {
            let t = .5 * (At[0].pageX + At[1].pageX), r = .5 * (At[0].pageY + At[1].pageY);
            this.rotateStart.set(t, r);
        } else this.rotateStart.set(At[0].pageX, At[0].pageY);
    }
    handleTouchStartPan() {
        if (At.length === 2) {
            let t = .5 * (At[0].pageX + At[1].pageX), r = .5 * (At[0].pageY + At[1].pageY);
            this.panStart.set(t, r);
        } else this.panStart.set(At[0].pageX, At[0].pageY);
    }
    handleTouchStartDolly() {
        let t = At[0].pageX - At[1].pageX, r = At[0].pageY - At[1].pageY, n = Math.sqrt(t * t + r * r);
        this.dollyStart.set(0, n);
    }
    handleTouchStartDollyPan() {
        this.enableZoom && this.handleTouchStartDolly(), this.enablePan && this.handleTouchStartPan();
    }
    handleTouchStartDollyRotate() {
        this.enableZoom && this.handleTouchStartDolly(), this.enableRotate && this.handleTouchStartRotate();
    }
    handleTouchMoveRotate(t) {
        if (At.length === 2) {
            let n = Qy(t), s = .5 * (t.pageX + n.x), o = .5 * (t.pageY + n.y);
            this.rotateEnd.set(s, o);
        } else {
            if (t.pointerId !== At[0].pointerId) return;
            this.rotateEnd.set(t.pageX, t.pageY);
        }
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(qy);
        let r = this.domElement;
        r && (this.rotateLeft(2 * Math.PI * this.rotateDelta.x / r.clientHeight), this.rotateUp(2 * Math.PI * this.rotateDelta.y / r.clientHeight)), this.rotateStart.copy(this.rotateEnd);
    }
    handleTouchMovePan(t) {
        if (At.length === 2) {
            let r = Qy(t), n = .5 * (t.pageX + r.x), s = .5 * (t.pageY + r.y);
            this.panEnd.set(n, s);
        } else {
            if (t.pointerId !== At[0].pointerId) return;
            this.panEnd.set(t.pageX, t.pageY);
        }
        this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(Yy), this.pan(this.panDelta.x, this.panDelta.y), this.panStart.copy(this.panEnd);
    }
    handleTouchMoveDolly(t) {
        let r = Qy(t), n = t.pageX - r.x, s = t.pageY - r.y, o = Math.sqrt(n * n + s * s);
        this.dollyEnd.set(0, o), this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, OM)), this.dollyOut(this.dollyDelta.y), this.dollyStart.copy(this.dollyEnd);
    }
    handleTouchMoveDollyPan(t) {
        this.enableZoom && this.handleTouchMoveDolly(t), this.enablePan && this.handleTouchMovePan(t);
    }
    handleTouchMoveDollyRotate(t) {
        this.enableZoom && this.handleTouchMoveDolly(t), this.enableRotate && this.handleTouchMoveRotate(t);
    }
};
function no(i) {
    let e = Math.PI * 2;
    for(; i <= -Math.PI;)i += e;
    for(; i > Math.PI;)i -= e;
    return i;
}
function FM(i) {
    return 1 - Math.pow(1 - i, 4);
}
function OO(i) {
    return i.wheelDeltaY === 0 || i.deltaY === 0 ? Eh && i.shiftKey && Math.abs(i.wheelDeltaX) >= 120 ? !1 : i.wheelDeltaX ? i.wheelDeltaX === -3 * i.deltaX : i.deltaMode === 0 : i.wheelDeltaY ? i.wheelDeltaY === -3 * i.deltaY : i.deltaMode === 0;
}
var At = [], hp = {};
function FO(i) {
    At.push(i);
}
function UM(i) {
    delete hp[i.pointerId];
    for(let e = 0; e < At.length; e++)if (At[e].pointerId === i.pointerId) {
        At.splice(e, 1);
        return;
    }
}
function zM(i) {
    let e = hp[i.pointerId];
    e === void 0 && (e = new B, hp[i.pointerId] = e), e.set(i.pageX, i.pageY);
}
function Qy(i) {
    let e = i.pointerId === At[0].pointerId ? At[1] : At[0];
    return hp[e.pointerId];
}
var io = class extends qf {
    constructor(){
        super(), this.layers.enable(3);
    }
    setFromCamera(e, t) {
        t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, -1).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : t.isPerspectiveCamera ? (this.ray.origin.set(e.x, e.y, -1).unproject(t), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : console.error("Raycaster: Unsupported camera type.");
    }
    intersectVisibleObjects(e, t = !0, r = []) {
        return e.forEach((n)=>{
            n.visible && this.intersectObject(n, t, r);
        }), r;
    }
    createRaycastLineHelper() {
        let e = new kr({
            color: 65280,
            linewidth: 10
        }), t = new M(this.ray.origin.x, this.ray.origin.y, this.ray.origin.z), r = new M(this.ray.direction.x, this.ray.direction.y, this.ray.direction.z), n = this.camera.far - this.camera.near, s = new M().addVectors(t, r.multiplyScalar(n)), o = new Le;
        return o.setFromPoints([
            t,
            s
        ]), new os(o, e);
    }
};
var kM = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var o, a, l, c, h;
        let t = Object.assign({}, (o = e == null ? void 0 : e.parameters) != null ? o : {
            width: 100,
            radialSegments: 64,
            heightSegments: 1,
            openEnded: !1,
            thetaStart: 0,
            thetaLength: 360,
            cornerRadius: 0,
            cornerSegments: 8,
            hollow: 0
        }, i.parameters), r = t.width / 2, n = (a = t.radiusTop) != null ? a : r, s = (l = t.radiusBottom) != null ? l : r;
        return n === s ? (n = r, s = r) : n > s ? (n = r, s = s * r / n) : (n = n * r / s, s = r), {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((c = t.height) != null ? c : t.width),
                depth: Math.abs((h = t.depth) != null ? h : t.width),
                radiusTop: n,
                radiusBottom: s
            })
        };
    }
    static build(i) {
        let { width: e , depth: t , height: r , radialSegments: n , heightSegments: s , openEnded: o , thetaStart: a , thetaLength: l , radiusTop: c , radiusBottom: h , cornerRadius: u , cornerSegments: f , hollow: d  } = i.parameters, p;
        return u || d ? p = new Uh(c, h, r, n, s, o, a, l * Math.PI / 180, u, u, f, d) : p = new Lo(c, h, r, n, s, o, a, l * Math.PI / 180), p.scale(1, 1, t / e), Object.assign(p, {
            userData: xe(ie({}, i), {
                type: "CylinderGeometry"
            })
        });
    }
};
function so(i, e, t) {
    t.x = i.x * e.x, t.y = i.y, t.z = i.x * e.y;
}
function GM(i) {
    return new B(i.y, -i.x);
}
var Uh = class extends Le {
    constructor(e, t, r, n, s, o, a, l, c, h, u, f, d = !1){
        super(), this.type = "RoundedCylinderBufferGeometry", e = e !== void 0 ? e : 1, t = t !== void 0 ? t : 1, r = r || 1, n = Math.floor(n) || 8, s = Math.floor(s) || 1, o = o !== void 0 ? o : !1, a = a !== void 0 ? a : 0, l = l !== void 0 ? l : Math.PI * 2, o && (c = 0, h = 0);
        let p = [], m = [], g = [], v = [], y = 0, w = r / 2, b = new M, S = new M;
        d && e == 0 && (e = c), d && t == 0 && (t = h);
        let T = new B(e, w), A = new B(t, -w), x = null, E = null, _ = null, C = null, I = T.clone().sub(A), N = 0, R = 0, k = 0;
        f > 0 && (N = Math.min(e, t) * (1 - f), R = e - N, k = t - N);
        let G = T.clone();
        G.x -= N;
        let te = Math.PI - I.angle(), Q = I.angle(), Y = Math.tan(Q / 2), F = Math.tan(te / 2), z = Y + F, O = f ? z : F, j = f ? z : Y;
        if (c = Math.min(c, (e - R) / O, I.length() / z), h = Math.min(h, (t - k) / j, I.length() / z), c > 0) {
            let le = c / Y;
            x = T.clone().sub(new B(le, c)), f && (_ = x.clone(), _.x -= N - z * c), T.sub(I.clone().setLength(le));
        }
        if (h > 0) {
            let le = h / F;
            E = A.clone().sub(new B(le, -h)), A.add(I.clone().setLength(le)), f && (C = E.clone(), C.x -= N - z * h, G.sub(I.clone().setLength(le)));
        }
        I = T.clone().sub(A);
        let q = I.length() < .5, J = [];
        for(let le2 = 0; le2 <= n; le2++){
            let H = [], he = le2 / n, K = he * l + a, V = new B(Math.sin(K), Math.cos(K));
            C && E ? (W(H, he, V, te, h, C, -1, !0), W(H, he, V, Q, h, E, -1, !1)) : E ? (ge(H, V, E.x, 0, -1), W(H, he, V, Q, h, E, -1, !1)) : o || ge(H, V, t, k, -1);
            let Z = GM(I).normalize();
            if (so(Z, V, b), !q) for(let ce = 0; ce <= s; ce++){
                let se = ce / s, pe = I.clone().multiplyScalar(se).add(A);
                so(pe, V, S), m.push(S.x, S.y, S.z), g.push(b.x, b.y, b.z), v.push(he, .5 + S.y / r), H.push(y++);
            }
            if (_ && x ? (W(H, he, V, te, c, x, 1, !1), W(H, he, V, Q, c, _, 1, !0)) : x ? (W(H, he, V, te, c, x, 1, !1), ge(H, V, x.x, 0, 1)) : o || ge(H, V, e, R, 1), f && !q) {
                let ce = GM(I).multiplyScalar(-1).normalize();
                so(ce, V, b);
                for(let se = 0; se <= s; se++){
                    let pe = se / s, ve = I.clone().multiplyScalar(-pe).add(G);
                    so(ve, V, S), m.push(S.x, S.y, S.z), g.push(b.x, b.y, b.z), v.push(he, .5 + S.y / r), H.push(y++);
                }
            }
            f && !o && H.push(H[0]), J.push(H);
        }
        for(let le1 = 0; le1 < J.length - 1; le1++)for(let H5 = 0; H5 < J[0].length - 1; H5++){
            if (o && f && H5 == s) continue;
            let he = J[le1][H5], K = J[le1 + 1][H5], V = J[le1 + 1][H5 + 1], Z = J[le1][H5 + 1], ce = m[V * 3 + 0], se = m[V * 3 + 2];
            p.push(he, K, Z), (ce != 0 || se != 0) && p.push(K, V, Z);
        }
        l < Math.PI * 2 && (oe(-1, J[0], a), oe(1, J[J.length - 1], a + l)), this.setIndex(p), this.setAttribute("position", new Ce(m, 3)), this.setAttribute("normal", new Ce(g, 3)), this.setAttribute("uv", new Ce(v, 2));
        function W(le, H, he, K, V, Z, ce, se) {
            for(let pe = 0; pe < u + 1; pe++){
                let ve = pe / u, me = ce < 0 ? ve : 1 - ve;
                se && (me -= 1), me *= K;
                let Pe = new B(Math.sin(me), Math.cos(me) * ce), ke = Pe.clone().multiplyScalar(V).add(Z);
                so(ke, he, S), m.push(S.x, S.y, S.z), so(Pe, he, b), g.push(b.x, b.y, b.z), v.push(H, .5 + S.y / r), le.push(y++);
            }
        }
        function ge(le, H, he, K, V) {
            let Z = new M, ce = new B, se = [
                he,
                K
            ];
            V < 0 && se.reverse();
            for (let pe of se)ce.set(pe, w * V), so(ce, H, Z), m.push(Z.x, Z.y, Z.z), g.push(0, V, 0), v.push(.5, .5), le.push(y++);
        }
        function oe(le, H, he) {
            let K = new B(Math.sin(he), Math.cos(he)), V = new B(-Math.cos(he), Math.sin(he)), Z = new M, ce = le < 0 ? (ve, me, Pe)=>p.push(ve, me, Pe)
             : (ve, me, Pe)=>p.push(ve, Pe, me)
            , se = new B((e + t + R + k) / 4, 0);
            so(se, K, Z), m.push(Z.x, Z.y, Z.z), g.push(V.x, 0, V.y), v.push(.5, .5);
            let pe = y++;
            for (let ve2 of H){
                let me = m.slice(ve2 * 3, ve2 * 3 + 3);
                m.push(...me), g.push(V.x, 0, V.y);
                let Pe = v.slice(ve2 * 2, ve2 * 2 + 2);
                v.push(...Pe), y++;
            }
            for(let ve1 = pe + 1; ve1 < y - 1; ve1++)ce(pe, ve1, ve1 + 1);
            ce(pe, y - 1, pe + 1);
        }
    }
};
var VM = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            radialSegments: 32,
            heightSegments: 8,
            openEnded: !1,
            thetaStart: 0,
            thetaLength: 360,
            cornerRadiusTop: 0,
            cornerRadiusBottom: 0,
            cornerSegments: 8
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width)
            })
        };
    }
    static build(i) {
        let { width: e , depth: t , height: r , radialSegments: n , heightSegments: s , openEnded: o , thetaStart: a , thetaLength: l , cornerRadiusTop: c , cornerRadiusBottom: h , cornerSegments: u  } = i.parameters, f;
        return c > 0 || h > 0 || l < 360 ? f = new Uh(0, e / 2, r, n, s, o, a, l * Math.PI / 180, c, h, u, 0, !0) : f = new za(e / 2, r, n, s, o), f.scale(1, 1, t / e), Object.assign(f, {
            userData: xe(ie({}, i), {
                type: "ConeGeometry"
            })
        });
    }
};
var HM = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            widthSegments: 1,
            heightSegments: 1,
            depthSegments: 1,
            cornerRadius: 0,
            cornerSegments: 8
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , depth: r , widthSegments: n , heightSegments: s , depthSegments: o , cornerRadius: a , cornerSegments: l  } = i.parameters, c;
        return a == 0 ? c = new vn(e, t, r, n, s, o) : c = new Ky(e, t, r, n, s, o, a, l), Object.assign(c, {
            userData: xe(ie({}, i), {
                type: "CubeGeometry"
            })
        });
    }
}, Jy = Math.PI / 2, Ky = class extends Le {
    constructor(e = 1, t = 1, r = 1, n = 1, s = 1, o = 1, a = 0, l = 4){
        super(), this.type = "BoxBufferGeometry";
        let c = this;
        n = Math.floor(n), s = Math.floor(s), o = Math.floor(o), l = Math.floor(l), a = Math.min(a, e / 2, t / 2, r / 2);
        let h = [], u = [], f = [], d = [], p = 0, m = 0;
        g("z", "y", "x", -1, -1, r, t, e, o, s, 0), g("z", "y", "x", 1, -1, r, t, -e, o, s, 1), g("x", "z", "y", 1, 1, e, r, t, n, o, 2), g("x", "z", "y", 1, -1, e, r, -t, n, o, 3), g("x", "y", "z", 1, -1, e, t, r, n, s, 4), g("x", "y", "z", -1, -1, e, t, -r, n, s, 5), a > 0 && (v("z", "y", "x", -1, -1, 1, r, t, e, o, 0), v("z", "y", "x", 1, -1, -1, r, t, e, o, 1), v("z", "y", "x", -1, 1, -1, r, t, e, o, 1), v("z", "y", "x", 1, 1, 1, r, t, e, o, 0), v("x", "y", "z", -1, -1, -1, e, t, r, n, 0), v("x", "y", "z", 1, -1, 1, e, t, r, n, 1), v("x", "y", "z", -1, 1, 1, e, t, r, n, 0), v("x", "y", "z", 1, 1, -1, e, t, r, n, 1), v("y", "x", "z", -1, -1, 1, t, e, r, s, 0), v("y", "x", "z", 1, -1, -1, t, e, r, s, 1), v("y", "x", "z", 1, 1, 1, t, e, r, s, 1), v("y", "x", "z", -1, 1, -1, t, e, r, s, 0), y(1, 1, 1), y(-1, 1, 1), y(1, -1, 1), y(-1, -1, 1), y(1, 1, -1), y(-1, 1, -1), y(1, -1, -1), y(-1, -1, -1)), this.setIndex(h), this.setAttribute("position", new Ce(u, 3)), this.setAttribute("normal", new Ce(f, 3)), this.setAttribute("uv", new Ce(d, 2));
        function g(w, b, S, T, A, x, E, _, C, I, N) {
            let R = (x - 2 * a) / C, k = (E - 2 * a) / I, G = x / 2 - a, te = E / 2 - a, Q = _ / 2, Y = C + 1, F = I + 1, z = 0, O = 0, j = new M;
            for(let q = 0; q < F; q++){
                let J = q * k - te;
                for(let W = 0; W < Y; W++){
                    let ge = W * R - G;
                    j[w] = ge * T, j[b] = J * A, j[S] = Q, u.push(j.x, j.y, j.z), j[w] = 0, j[b] = 0, j[S] = _ > 0 ? 1 : -1, f.push(j.x, j.y, j.z), d.push(W / C), d.push(1 - q / I), z += 1;
                }
            }
            for(let q4 = 0; q4 < I; q4++)for(let J = 0; J < C; J++){
                let W = p + J + Y * q4, ge = p + J + Y * (q4 + 1), oe = p + (J + 1) + Y * (q4 + 1), le = p + (J + 1) + Y * q4;
                h.push(W, ge, le), h.push(ge, oe, le), O += 6;
            }
            c.addGroup(m, O, N), m += O, p += z;
        }
        function v(w, b, S, T, A, x, E, _, C, I, N) {
            let R = (E - 2 * a) / I, k = E / 2 - a, G = _ / 2 - a, te = C / 2, Q = I + 1, Y = 0, F = 0, z = new M, O = new M;
            for(let j = 0; j < l + 1; j++){
                let q = j / l * Jy, J = Math.sin(q) * a, W = (1 - Math.cos(q)) * a, ge = Math.sin(q), oe = Math.cos(q);
                z[b] = (G + J) * A, z[S] = (te - W) * x, O[w] = 0, O[b] = ge * Math.sign(z[b]), O[S] = oe * Math.sign(z[S]);
                for(let le = 0; le < Q; le++){
                    let H = le * R - k;
                    z[w] = H * T, u.push(z.x, z.y, z.z), f.push(O.x, O.y, O.z), d.push(le / I), d.push(0), Y += 1;
                }
            }
            for(let j5 = 0; j5 < l; j5++)for(let q = 0; q < I; q++){
                let J = p + q + Q * j5, W = p + q + Q * (j5 + 1), ge = p + (q + 1) + Q * (j5 + 1), oe = p + (q + 1) + Q * j5;
                h.push(J, W, oe), h.push(W, ge, oe), F += 6;
            }
            c.addGroup(m, F, N), m += F, p += Y;
        }
        function y(w, b, S) {
            let T = new M, A = new M(e / 2, t / 2, r / 2);
            A.subScalar(a);
            let x = [], E = w * b * S > 0 ? (C, I, N)=>h.push(C, I, N)
             : (C, I, N)=>h.push(C, N, I)
            ;
            for(let C7 = 0; C7 <= l; C7++){
                let I = [], N = Jy * (1 - C7 / l), R = Math.cos(N), k = Math.sin(N), G = 0;
                for(let te = 0; te <= C7; te++){
                    let Q = Math.cos(G), Y = Math.sin(G);
                    T.x = R * Q, T.y = k, T.z = R * Y;
                    let F = A.clone().addScaledVector(T, a);
                    u.push(w * F.x, b * F.y, S * F.z), f.push(w * T.x, b * T.y, S * T.z), d.push(0, 0), I.push(p++), G += Jy / C7;
                }
                x.push(I);
            }
            let _ = x.length - 1;
            for(let C6 = 0; C6 < _; C6++){
                let I = x[C6], N = x[C6 + 1], R = I.length - 1;
                E(I[0], N[1], N[0]);
                for(let k = 1; k <= R; k++)E(I[k - 1], I[k], N[k]), E(I[k], N[k + 1], N[k]);
            }
        }
    }
};
var oo = class extends Le {
    constructor(e = [], t = [], r = "", n = 1, s = .2, o = 4){
        super(), this.type = "PolyhedronGeometryRound";
        let a = [], l = [], c = [];
        h(), u(), this.setAttribute("position", new Ce(a, 3)), this.setAttribute("normal", new Ce(c, 3)), this.setAttribute("uv", new Ce(l, 2));
        return;
        function h() {
            var Y;
            s = Math.min(1 - 1e-5, s), s == 0 && (o = 0);
            let d = {
                IcosahedronGeometry: 5,
                DodecahedronGeometry: 3,
                HexahedronGeometry: 3,
                OctahedronGeometry: 4,
                TetrahedronGeometry: 3
            }[r], p = new M, m = p.clone(), g = new Jt, v = s * n, y = n - v, w = o + 1, b = new M, S = (F, z)=>b.subVectors(F, z).normalize()
            , T = (F, z)=>Array(F).fill(void 0).map(z)
            , A = T(e.length / 3, (F, z)=>new M().fromArray(e, z * 3).setLength(n)
            ), x = [], E = 1e6;
            for(let F8 = 0; F8 < A.length; F8++){
                let z = A[F8], O = [], j, q, J, W = 1e10, ge = -1;
                for(; (ge = t.indexOf(F8, ge + 1)) != -1;){
                    let he = ge - ge % 3;
                    j = t[he + (ge + 1) % 3], q = t[he + (ge + 2) % 3], J = z.distanceToSquared(A[j]), W = Math.min(W, J), O.push([
                        j,
                        q,
                        J
                    ]);
                }
                W += 1e-6;
                let oe = [], le = 0, H = O.length;
                for(let he = 0; he < H; he++){
                    [j, q, J] = O[le];
                    let K = ((Y = x[j]) == null ? void 0 : Y.includes(F8)) == !0;
                    J <= W && oe.push(j + +K * E), le = O.findIndex((V)=>V[0] == q
                    );
                }
                x.push(oe);
            }
            let _ = [];
            {
                let F = 0, z = 0, O, j, q = d == 3;
                for(let J = 0; J <= o; J++){
                    O = J * (J + 1) / 2, j = (J + 1) * (J + 2) / 2;
                    for(let W = 0; W < o - J; W++)[F, z] = [
                        O + W + J + 2,
                        j + W + J + 3
                    ], _.push(O, j, ...q ? [
                        z,
                        O
                    ] : [
                        F,
                        j
                    ], z, F), [O, j] = [
                        F,
                        z
                    ];
                    _.push(O, j, O + o + 2);
                }
            }
            let C = p.clone(), I = p.clone(), N = p.clone(), R = p.clone(), k = p.clone(), G = [], te = T(A.length, ()=>T(d, ()=>p.clone()
                )
            );
            for(let F5 = 0; F5 < A.length; F5++){
                p.copy(A[F5]).normalize(), C.copy(p).multiplyScalar(y);
                let z = x[F5];
                for(let oe3 = 0; oe3 < z.length; oe3++){
                    let le = z[oe3], H = z[(oe3 + 1) % d];
                    g.setFromPointsAndIndices(A, F5, le % E, H % E), g.b.sub(g.a).setLength(1e10).add(g.a), g.c.sub(g.a).setLength(1e10).add(g.a), g.closestPointToPoint(C, te[F5][oe3]);
                }
                let O = [], j = [], q = [], J = new M;
                o == 0 && [
                    ...te[F5]
                ].reduce((oe, le)=>oe.add(le)
                , J).multiplyScalar(1 / d);
                for(let oe1 = 0; oe1 < d; oe1++){
                    let le = [], H = (oe1 - 1 + d) % d, he = te[F5][H], K = te[F5][oe1];
                    p.copy(he).sub(C), m.copy(K).sub(C);
                    let V = C.angleTo(p), Z = p.angleTo(m), ce = Math.cos(V) * v;
                    o == 0 ? I.copy(J) : I.copy(C).setLength(y + ce), j.push(ce);
                    let se = [
                        I,
                        he,
                        K
                    ];
                    for(let pe = 0; pe < 2; pe++){
                        let ve = se[pe], me = se[pe + 1];
                        R.subVectors(ve, C), k.subVectors(me, C), N.crossVectors(R, k).normalize();
                        for(let Pe = 0; Pe < w; Pe++){
                            let ke = [
                                V,
                                Z
                            ][pe] * Pe / w;
                            p.copy(R).applyAxisAngle(N, ke).add(C), O.push(p.clone()), pe && (S(p, C), le.push([
                                Pe == 0 ? ve : p.clone(),
                                b.clone()
                            ]));
                        }
                        pe && (S(me, C), le.push([
                            me,
                            b.clone()
                        ]));
                    }
                    q.push(le);
                }
                G.push(q);
                let W = 2 * w, ge = 2;
                for(let oe2 = 0; oe2 < d; oe2++){
                    let le = W * oe2, H = W * ((oe2 + 1) % d), he = [
                        O[le]
                    ];
                    for(let V11 = 1; V11 < w; V11++){
                        R = O[le + V11], k = O[H + V11], he.push(R);
                        for(let Z = 1, ce = V11 - ge + 1; Z <= ce; Z++)p.lerpVectors(R, k, Z / (ce + 1)), p.sub(C).setLength(j[oe2]).add(C), he.push(p.clone());
                        he.push(k);
                    }
                    for(let V10 = 0; V10 < w; V10++)he.push(O[V10 + w + le]);
                    he.push(O[H + w]);
                    let K = _.map((V)=>he[V]
                    );
                    a.push(...K.map((V)=>[
                            V.x,
                            V.y,
                            V.z
                        ]
                    ).flat()), c.push(...K.map((V)=>(S(V, C), [
                            b.x,
                            b.y,
                            b.z
                        ])
                    ).flat());
                }
            }
            let Q = [];
            for(let F6 = 0; F6 < x.length; F6++)for(let z6 = 0; z6 < d; z6++){
                let O = x[F6][z6];
                if (O < E) {
                    let j = x[O].findIndex((W)=>W % E == F6
                    ), q = G[F6][z6], J = G[O][j];
                    for(let W4 = 0; W4 < w; W4++){
                        let ge = q[W4], oe = J[w - W4], le = q[W4 + 1], H = J[w - (W4 + 1)];
                        [
                            ge,
                            oe,
                            le,
                            le,
                            oe,
                            H
                        ].forEach((he)=>{
                            a.push(he[0].x, he[0].y, he[0].z), c.push(he[1].x, he[1].y, he[1].z);
                        });
                    }
                    Q.push(q[0][0], J[w][0], q[w][0], J[0][0]);
                }
            }
            for(; Q.length;){
                let F, z, O, j;
                [F, z] = Q.splice(0, 2);
                let q = [
                    F
                ];
                for(; F != z;)q.push(z), O = Q.indexOf(z), j = O % 2, z = Q.splice(O - j, 2)[1 - j];
                b.subVectors(q[0], q[1]).cross(p.subVectors(q[0], q[2])).normalize();
                let J = b.dot(q[0]) < 0;
                J && b.negate();
                for(let W = 1; W <= q.length - 2; W++)[
                    q[W + +J],
                    q[W + 1 - +J],
                    q[0]
                ].forEach((ge)=>{
                    a.push(ge.x, ge.y, ge.z), c.push(b.x, b.y, b.z);
                });
            }
        }
        function u() {
            let f = new M;
            for(let A7 = 0; A7 < a.length; A7 += 3){
                f.x = a[A7 + 0], f.y = a[A7 + 1], f.z = a[A7 + 2];
                let x = S(f) / 2 / Math.PI + .5, E = T(f) / Math.PI + .5;
                l.push(x, 1 - E);
            }
            let d = new M, p = new M, m = new M, g = new M, v = new B, y = new B, w = new B, b = (A, x, E, _)=>{
                _ < 0 && A.x === 1 && (l[x] = A.x - 1), E.x === 0 && E.z === 0 && (l[x] = _ / 2 / Math.PI + .5);
            };
            for(let A5 = 0, x6 = 0; A5 < a.length; A5 += 9, x6 += 6){
                d.set(a[A5 + 0], a[A5 + 1], a[A5 + 2]), p.set(a[A5 + 3], a[A5 + 4], a[A5 + 5]), m.set(a[A5 + 6], a[A5 + 7], a[A5 + 8]), v.set(l[x6 + 0], l[x6 + 1]), y.set(l[x6 + 2], l[x6 + 3]), w.set(l[x6 + 4], l[x6 + 5]), g.copy(d).add(p).add(m).divideScalar(3);
                let E = S(g);
                b(v, x6 + 0, d, E), b(y, x6 + 2, p, E), b(w, x6 + 4, m, E);
            }
            for(let A6 = 0; A6 < l.length; A6 += 6){
                let x = l[A6 + 0], E = l[A6 + 2], _ = l[A6 + 4], C = Math.max(x, E, _), I = Math.min(x, E, _);
                C > .9 && I < .1 && (x < .2 && (l[A6 + 0] += 1), E < .2 && (l[A6 + 2] += 1), _ < .2 && (l[A6 + 4] += 1));
            }
            function S(A) {
                return Math.atan2(A.z, -A.x);
            }
            function T(A) {
                return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z));
            }
        }
    }
    static fromJSON(e) {
        return new oo(e.vertices, e.indices, e.radius, e.corner, e.cornerSides);
    }
};
var WM = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            detail: 0,
            corner: 0,
            cornerSides: 4
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , depth: r , detail: n , corner: s , cornerSides: o  } = i.parameters, a = n === 0 && s !== 0 ? new zh(e * .5, s, o) : new ka(e * .5, n);
        return a.scale(1, t / e, r / e), Object.assign(a, {
            userData: xe(ie({}, i), {
                type: "DodecahedronGeometry"
            })
        });
    }
}, zh = class extends oo {
    constructor(e = 1, t = .2, r = 4){
        let n = (1 + Math.sqrt(5)) / 2, s = 1 / n, o = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -s,
            -n,
            0,
            -s,
            n,
            0,
            s,
            -n,
            0,
            s,
            n,
            -s,
            -n,
            0,
            -s,
            n,
            0,
            s,
            -n,
            0,
            s,
            n,
            0,
            -n,
            0,
            -s,
            n,
            0,
            -s,
            -n,
            0,
            s,
            n,
            0,
            s
        ], a = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
        ], l = "DodecahedronGeometry";
        super(o, a, l, e, t, r), this.type = l;
    }
    static fromJSON(e) {
        return new zh(e.radius, e.corner, e.cornerSides);
    }
};
var Gh = 1e-12, Dl = class {
    constructor(e){
        this.position = new B;
        this.startPosition = new B;
        this.uuid = et.generateUUID();
        this.position = e.clone();
    }
    start() {
        this.reset();
    }
    reset() {
        this.startPosition.copy(this.position);
    }
    applyOffset(e) {
        this.position.copy(this.startPosition).add(e);
    }
    copy(e) {
        return this.position.copy(e.position), this.startPosition.copy(e.startPosition), this;
    }
    clone() {
        return new Dl(this.position).copy(this);
    }
    toJSON() {
        return [
            this.position.x,
            this.position.y
        ];
    }
}, Pl = class extends Dl {
    constructor(t){
        super(t.position);
        this.parent = t;
    }
    copy(t) {
        return super.copy(t), this;
    }
    clone() {
        return new Pl(this.parent).copy(this);
    }
}, ui = class extends Dl {
    constructor(t, r){
        super(r);
        this.controls = [];
        this.roundness = 0;
        this.areControlsDirectionsMirrored = !0;
        this.uuid = t, this.controls.push(new Pl(this), new Pl(this));
    }
    static create(t, r) {
        let n = new ui(t, new B(...r.position));
        return n.controls[0].position.set(...r.controlPrevious.position), n.controls[1].position.set(...r.controlNext.position), n.roundness = r.roundness, n.areControlsDirectionsMirrored = r.areControlsDirectionsMirrored, n;
    }
    getOppositeControl(t) {
        let r = this.controls.indexOf(t);
        return r === 0 ? this.controls[1] : r === 1 ? this.controls[0] : null;
    }
    applyOffsetToControls(t, r = 1) {
        for(let n = 0, s = this.controls.length; n < s; n++){
            let o = this.controls[n];
            this.position.distanceTo(o.position) <= r ? o.position.copy(this.position) : o.applyOffset(t);
        }
    }
    controlsMoved() {
        return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position));
    }
    copy(t) {
        return super.copy(t), this.controls[0].copy(t.controls[0]), this.controls[1].copy(t.controls[1]), this.roundness = t.roundness, this.uuid = t.uuid, this;
    }
    clone() {
        return new ui(this.uuid, this.position).copy(this);
    }
    toJSON() {
        return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [
            this.roundness
        ]);
    }
}, Zy = (i)=>i
, Vh = new B, $y = new B, UO = new B, zO = new B, GO = new B, kO = new B, jM = new M, qM = new M;
function YM(i) {
    let e = new B;
    e.addVectors(i.v0, Vh.subVectors(i.v1, i.v0).multiplyScalar(2 / 3));
    let t = new B;
    return t.addVectors(i.v2, $y.subVectors(i.v1, i.v2).multiplyScalar(2 / 3)), new an(i.v0, e, t, i.v2);
}
function kh(i, e, t = Number.EPSILON) {
    return Math.abs(i - e) < t;
}
function VO(i, e, t = Number.EPSILON) {
    return i.distanceTo(e) < t;
}
function HO(i, e, t = Number.EPSILON) {
    return i.distanceTo(e) < t;
}
function ev(i, e, t) {
    let r = Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2)), n = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)), s = Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));
    return Math.acos((n * n + r * r - s * s) / (2 * n * r));
}
function XM(i, e, t, r, n) {
    let s = Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2)), o = (i.y + e.y) / 2, a = (i.x + e.x) / 2, l = Math.sqrt(Math.pow(t, 2) - Math.pow(s / 2, 2)) * (i.y - e.y) / s, c = Math.sqrt(Math.pow(t, 2) - Math.pow(s / 2, 2)) * (e.x - i.x) / s;
    return r.set(a + l, o + c), n.set(a - l, o - c), [
        r,
        n
    ];
}
function QM(i, e, t) {
    let r = i.distanceTo(t), n = e.distanceTo(t);
    return r < n ? e : i;
}
function JM(i, e, t, r, n, s) {
    let o = e.x - i.x, a = e.y - i.y, l = t.x - i.x, c = t.y - i.y, h = Math.sqrt((o + l) * (o + l) + (a + c) * (a + c)), u;
    return ev(e, i, t) > Math.PI && (h *= -1), kh(c, a) ? u = (a + c) * (r / h - .5) * 8 / 3 / (o - l) : u = (o + l) * (r / h - .5) * 8 / 3 / (c - a), n.set(e.x - u * a, e.y + u * o), s.set(t.x + u * c, t.y - u * l), [
        n,
        s
    ];
}
function tv(i, e) {
    return i.position.equals(i.controls[1].position) && e.position.equals(e.controls[0].position);
}
function KM(i, e, t, r, n = .5) {
    let s = Vh.subVectors(e, i).multiplyScalar(n).add(i), o = $y.subVectors(t, e).multiplyScalar(n).add(e), a = UO.subVectors(r, t).multiplyScalar(n).add(t), l = s, c = zO.subVectors(o, s).multiplyScalar(n).add(s), h = GO.subVectors(a, o).multiplyScalar(n).add(o), u = a, f = kO.subVectors(h, c).multiplyScalar(n).add(c);
    return [
        i.x,
        i.y,
        l.x,
        l.y,
        c.x,
        c.y,
        f.x,
        f.y,
        h.x,
        h.y,
        u.x,
        u.y,
        r.x,
        r.y
    ];
}
function ZM(i, e, t = 12, r = !0) {
    let n = qM.set(0, 0, 0), s, o = 0, a = [];
    for(let l = 0; l < e.length; l++){
        let c = Zy(e[l]), h = Vh, u = ao(c, t);
        a.push(u);
        for(let f = 0; f <= u; f++)if (c instanceof an || c instanceof kn || c instanceof ln) {
            if (c.getPoint(f / u, h), n.set(h.x, h.y, 0), s !== void 0 && HO(s, n)) continue;
            s === void 0 && (s = jM), s.copy(n), i.setXYZ(o, n.x, n.y, n.z), o++;
        }
    }
    return r && o > 1 && !(i.getX(o - 1) === i.getX(0) && i.getY(o - 1) === i.getY(0) && i.getZ(o - 1) === i.getZ(0)) && (i.setXYZ(o, i.getX(0), i.getY(0), i.getZ(0)), o++), i;
}
function $M(i, e, t, r = 12, n = !0) {
    let s = qM.set(0, 0, 0), o = 0, a = [];
    for(let l = 0; l < e.length; l++){
        if (t[l] === !1) continue;
        let c, h = Zy(e[l]), u = Vh, f = ao(h, r);
        a.push(f);
        for(let d = 0; d <= f; d++)if (h instanceof an || h instanceof kn || h instanceof ln) {
            if (h.getPoint(d / f, u), s.set(u.x, u.y, 0), c != null && c.equals(s)) continue;
            c === void 0 ? c = jM : (i.setXYZ(o, c.x, c.y, c.z), o++, i.setXYZ(o, s.x, s.y, s.z), o++), c.copy(s);
        }
    }
    return n && o > 1 && !(i.getX(o - 1) === i.getX(0) && i.getY(o - 1) === i.getY(0) && i.getZ(o - 1) === i.getZ(0)) && (i.setXYZ(o, i.getX(0), i.getY(0), i.getZ(0)), o++), a;
}
function rv(i, e = 12, t = !1) {
    let r = [];
    for(let n = 0, s = i.length; n < s; n++){
        let o = i[n], a = 0;
        if (t && o.roundedCurveCorner !== void 0) {
            let l = ao(o.roundedCurveCorner, e) * .5;
            n > 0 && (r[n - 1] += l), a += l;
        }
        o.curveAfter !== void 0 && (a += ao(o.curveAfter, e)), r.push(a);
    }
    return i.length > 0 && t && i[0].roundedCurveCorner !== void 0 && (r[i.length - 1] += ao(i[0].roundedCurveCorner, e) * .5), r;
}
function ao(i, e = 12) {
    return i && i instanceof Us ? e * 2 : i && (i instanceof ln || i instanceof th) ? 1 : i && i instanceof Po ? e * i.points.length : e;
}
function e1(i, e, t = 12, r = !0) {
    let n, s = 0;
    for(let o = 0; o < e.length; o++){
        let a = Zy(e[o]), l = ao(a, t), c = Vh;
        for(let h = 0; h <= l; h++)if (a instanceof an || a instanceof kn || a instanceof ln) {
            if (a.getPoint(h / l, c), n !== void 0 && VO(n, c, Gh)) continue;
            n === void 0 && (n = $y), n.copy(c), i.push(c.x, c.y), s++;
        }
    }
    return kh(i[0], i[i.length - 2], Gh) && kh(i[1], i[i.length - 1], Gh) && (i.pop(), i.pop()), r && s > 1 && !(kh(i[s - 1], i[1], Gh) && kh(i[s - 2], i[0], Gh)) && (i.push(i[0], i[1]), s++), i;
}
var nv = new B, WO = new B, jO = new B, qO = new B, YO = new B, XO = new B, Tt = class extends rn {
    constructor(t = 100, r = 100){
        super();
        this.points = [];
        this.shapeHoles = [];
        this.eventDispatcher = new Yt;
        this.plane = new Gr(new M(0, 0, -1));
        this.subdivision = 0;
        this.controlSnapDistance = 4;
        this.pointIDs = 0;
        this.isMesh2D = !1;
        this._roundness = 0;
        this.isClosed = !1;
        this.useCubicForRoundedCorners = !0;
        this.uuid = et.generateUUID();
        this.needsUpdate = !1;
        this.roundedCurves = [];
        this._width = t, this._height = r;
    }
    static createFromState(t, r, n) {
        let s = new Tt;
        return s.isClosed = t.isClosed, s.points = t.points.map((o)=>ui.create(o.id, o.data)
        ), typeof t.roundness == "number" && (s.roundness = t.roundness), s.shapeHoles = t.shapeHoles.map((o)=>Tt.createFromState(o)
        ), r !== void 0 && n !== void 0 && s.applySize(r, n), s.update(), s;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get roundness() {
        return this._roundness;
    }
    set roundness(t) {
        if (this._roundness !== t) {
            this._roundness = t;
            for(let r = 0, n = this.points.length; r < n; r++)this.points[r].roundness = t;
            this.needsUpdate = !0;
        }
    }
    getPointsIndexesByIds(t) {
        return t.map((r)=>this.getPointIndexById(r)
        ).filter((r)=>r >= 0
        );
    }
    getPointIndexById(t) {
        let r = this.points.length, n = this.points.findIndex((s)=>s.uuid === t
        );
        if (n < 0) {
            let s = r;
            for(let o = 0, a = this.shapeHoles.length; o < a; o++){
                let l = this.shapeHoles[o], c = l.points.length - 1, h = l.getPointIndexById(t);
                if (h < 0) s += c;
                else return h + s;
            }
        }
        return n;
    }
    getLineIndexById(t) {
        return this.getPointIndexById(t);
    }
    getBezierPoint(t) {
        if (t <= this.points.length - 1) return this.points[t];
        if (this.shapeHoles.length > 0) for(let r = 0, n = this.shapeHoles.length; r < n; r++){
            let s = this.shapeHoles[r], o = t - this.points.length;
            if (o <= s.points.length - 1) return s.points[o];
        }
        throw new Error("This shape does not have a point for this index: " + t);
    }
    getBezierPointIndex(t) {
        let r = this.points.indexOf(t);
        if (r >= 0) return r;
        if (r = this.points.length, this.shapeHoles.length > 0) for(let n = 0, s = this.shapeHoles.length; n < s; n++){
            let o = this.shapeHoles[n], a = o.points.indexOf(t);
            if (a >= 0) return r + a;
            r += o.points.length;
        }
        return -1;
    }
    getAllPoints() {
        let t = [].concat(...this.shapeHoles.map((r)=>r.points
        ));
        return [
            ...this.points,
            ...t
        ];
    }
    applySize(t, r) {
        t === 0 && (t = .001), r === 0 && (r = .001), this._width = t, this._height = r;
    }
    applyScale(t, r) {
        let n = nv.set(t, r);
        for(let s = 0, o = this.points.length; s < o; s++){
            let a = this.points[s];
            a.position.multiply(n), a.controls[0].position.multiply(n), a.controls[1].position.multiply(n);
        }
        for(let s7 = 0, o7 = this.shapeHoles.length; s7 < o7; s7++)this.shapeHoles[s7].applyScale(t, r);
        this._update(!1);
    }
    createPoint(t, r = 0, n = et.generateUUID()) {
        let s;
        t instanceof B ? s = t : s = new B(t, r);
        let o = new ui(n, s);
        return o.roundness = this.roundness, o;
    }
    addPoint(t) {
        this.points.push(t), this.needsUpdate = !0;
    }
    addPointAt(t, r) {
        this.points.splice(r, 0, t), this.needsUpdate = !0;
    }
    getPointByUuid(t) {
        for(let r = 0, n = this.points.length; r < n; r++){
            let s = this.points[r];
            if (s.uuid === t) return s;
        }
        for(let r7 = 0, n8 = this.shapeHoles.length; r7 < n8; r7++){
            let o = this.shapeHoles[r7].getPointByUuid(t);
            if (o) return o;
        }
    }
    getFirstPoint() {
        return this.points[0];
    }
    getLastPoint() {
        return this.points[this.points.length - 1];
    }
    removePoint(t) {
        let r = this.points.indexOf(t);
        r >= 0 && this.points.splice(r, 1), this.needsUpdate = !0;
    }
    removePointById(t) {
        let r = this.points.find((n)=>n.uuid === t
        );
        r && this.removePoint(r);
    }
    update(t = !0) {
        for(let r = 0, n = this.shapeHoles.length; r < n; r++)this.shapeHoles[r].update(!1);
        this._update(t);
    }
    extractShapePointsToBuffer(t, r = 12, n = !1) {
        this.subdivision = r, this.curveDivisions === void 0 && this.computeCurveDivisions(r);
        let s = n ? this.roundedCurveDivisions : this.curveDivisions;
        return ZM(t, n ? this.roundedCurves : this.curves, r, this.autoClose), s.reduce((o, a)=>o + a
        , 0) + 1;
    }
    computeCurveDivisions(t = 12) {
        return this.curveDivisions = rv(this.points, t, !1), this.roundedCurveDivisions = rv(this.points, t, !0), this.curveDivisions;
    }
    extractFilteredShapePointsToBuffer(t, r, n = 12) {
        return $M(t, this.curves, r, n, this.autoClose).reduce((o, a)=>o + a
        , 0) * 2;
    }
    extractShapePointsToFlatArray(t, r = 12) {
        return this.subdivision = r, this.curveDivisions === void 0 && this.computeCurveDivisions(r), e1(t, this.roundedCurves, r, this.autoClose);
    }
    getCurveIndexFromVertexId(t, r = !1) {
        let n = 0;
        this.curveDivisions === void 0 && this.computeCurveDivisions(this.subdivision);
        let s = r ? this.roundedCurveDivisions : this.curveDivisions, o = 0;
        r && this.points[0].roundedCurveCorner !== void 0 && (o = ao(this.points[0].roundedCurveCorner, this.subdivision) * .5);
        let a = t - o;
        a < 0 && (a += s.reduce((l, c)=>l + c
        , 0));
        for(let l10 = 0, c9 = s.length; l10 < c9; l10++){
            let h = s[l10];
            if (a < n + h) return [
                l10,
                (a - n + 1) / h
            ];
            n += h;
        }
        return [
            0,
            1
        ];
    }
    getCurveT(t, r, n) {
        let s = this.points[t], o = this.points[t >= this.points.length - 1 ? 0 : t + 1], a = this.curveDivisions, l = a[t];
        if (tv(s, o)) {
            let u = s.position.distanceTo(o.position);
            return s.position.distanceTo(nv.set(n.x, n.y)) / u;
        }
        let c = 0;
        for(let u = 0; u < t; u++)c += a[u];
        return (r - c) / l;
    }
    dispose() {
        this.eventDispatcher = null;
    }
    _applyCurveForPoint(t, r) {
        tv(r, t) ? this.lineTo(t.position.x, t.position.y) : this.bezierCurveTo(r.controls[1].position.x, r.controls[1].position.y, t.controls[0].position.x, t.controls[0].position.y, t.position.x, t.position.y);
        let n = this.curves[this.curves.length - 1];
        t.curveBefore = n, r.curveAfter = n;
        let s = n.clone();
        t.roundedCurveBefore = s, r.roundedCurveAfter = s, t.roundedCurveCorner = void 0, this.roundedCurves.push(s);
    }
    _update(t = !0) {
        var n;
        if (this.curves = [], this.roundedCurves = [], !this.points.length) return;
        for(let s = 0, o = this.points.length; s < o; s++){
            let a = this.points[s];
            if (s === 0) this.moveTo(a.position.x, a.position.y);
            else {
                let l = this.points[s - 1];
                this._applyCurveForPoint(a, l);
            }
        }
        let r = this.getLastPoint();
        if (r != null && r.curveAfter && (r.curveAfter = void 0), this.isClosed) {
            let s = this.points[0], o = this.points[this.points.length - 1];
            this._applyCurveForPoint(s, o);
        }
        if (this.points.length > 2) {
            let s = 0;
            for(let o = 0, a = this.points.length; o < a; o++){
                let l = this.points[o], c = l.roundness;
                if (!l.controlsMoved() && c > 0) {
                    let h = l.curveBefore, u = l.curveAfter;
                    if (h === void 0 || u === void 0) continue;
                    let f = l.roundedCurveBefore, d = l.roundedCurveAfter, p = h.getLength(), m = u.getLength(), g = Math.min(c, p * .499), v = Math.min(c, m * .499), y = Math.min(g, v), w = 1 - y / p, b = y / m, S = h.getPointAt(w, nv), T = u.getPointAt(b, WO);
                    this._subSplitCurve(h, f, w, S, void 0), this._subSplitCurve(u, d, b, void 0, T);
                    let A;
                    if (this.useCubicForRoundedCorners) {
                        let x = ev(S, l.position, T) / 2, E = Math.tan(x) * S.distanceTo(l.position), [_, C] = XM(S, T, E, jO, qO), I = QM(_, C, l.position), [N, R] = JM(I, S, T, E, YO, XO);
                        A = new an(S.clone(), N.clone(), R.clone(), T.clone());
                    } else A = new kn(S.clone(), l.position.clone(), T.clone());
                    l.roundedCurveCorner = A, this.roundedCurves.splice(o + s, 0, A), s++;
                }
            }
        }
        t && ((n = this.eventDispatcher) == null || n.dispatchEvent({
            type: "update"
        }));
    }
    _subSplitCurve(t, r, n, s, o) {
        if (t instanceof ln) s !== void 0 && r.v2.copy(s), o !== void 0 && r.v1.copy(o);
        else {
            let a = t, l = r, c = a.getUtoTmapping(n, 0), h = KM(a.v0, a.v1, a.v2, a.v3, c);
            return s !== void 0 && (l.v0.set(h[0], h[1]), l.v1.set(h[2], h[3]), l.v2.set(h[4], h[5]), l.v3.set(h[6], h[7])), o !== void 0 && (l.v0.set(h[6], h[7]), l.v1.set(h[8], h[9]), l.v2.set(h[10], h[11]), l.v3.set(h[12], h[13])), l;
        }
        return r;
    }
    clone() {
        let t = new Tt(this._width, this._height);
        return t.points = this.points.map((r)=>r.clone()
        ), t.isClosed = this.isClosed, t.roundness = this.roundness, t.isMesh2D = this.isMesh2D, t.shapeHoles = this.shapeHoles.map((r)=>r.clone()
        ), t;
    }
    toJSON() {
        return {
            points: this.points.reduce((t, r)=>t.concat(r.toJSON())
            , []),
            shapeHoles: this.shapeHoles.map((t)=>t.toJSON()
            ),
            isClosed: this.isClosed,
            roundness: this.roundness
        };
    }
    fromJSON(t) {
        var n;
        this.points = [], this.pointIDs = 0;
        let r = t.points.length / 7;
        for(let s8 = 0; s8 < r; s8++){
            let o = s8 * 7, a = t.points[o + 0], l = t.points[o + 1], c = t.points[o + 2], h = t.points[o + 3], u = t.points[o + 4], f = t.points[o + 5], d = t.points[o + 6], p = new ui(et.generateUUID(), new B(a, l));
            p.controls[0].position.set(c, h), p.controls[1].position.set(u, f), p.roundness = d, this.points.push(p);
        }
        return this.shapeHoles = (n = t.shapeHoles) != null && n.length ? t.shapeHoles.map((s)=>{
            let o = new Tt;
            return o.fromJSON(s), o;
        }) : [], this.isClosed = t.isClosed, this._roundness = t.roundness, this._update(), this;
    }
    fromShape(t) {
        let r = (s, o)=>{
            o instanceof an && o.v3.equals(s.position) && s.controls[0].position.copy(o.v2);
        }, n = (s)=>{
            let o = [], a, l;
            for(a = 0, l = s.length; a < l; a++)s[a] instanceof kn && (s[a] = YM(s[a]));
            for(a = 0, l = s.length; a < l; a++){
                let u = s[a], f = a > 0 ? s[a - 1] : null, d;
                u instanceof an ? (d = this.createPoint(u.v0), d.controls[1].position.copy(u.v1)) : u instanceof ln && (d = this.createPoint(u.v1)), d !== void 0 && (f !== null && r(d, f), o.push(d));
            }
            let c = s[s.length - 1], h = !1;
            return c instanceof an ? c.v3.equals(o[0].position) && (o[0].controls[0].position.copy(c.v2), h = !0) : c instanceof ln && c.v2.equals(o[0].position) && (h = !0), this.isClosed = h, o;
        };
        return this.points = n(t.curves), t instanceof rn && (this.shapeHoles = t.holes.map((s)=>{
            let o = new Tt;
            return o.fromShape(s), o;
        })), this.update(), this;
    }
};
var sv = Math.PI * 2;
function iv({ x: i , y: e  }, t, r, n, s) {
    return {
        x: i * t + n,
        y: e * r + s
    };
}
function QO(i, e) {
    let t = e === 1.5707963267948966 ? .551915024494 : e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4), r = Math.cos(i), n = Math.sin(i), s = Math.cos(i + e), o = Math.sin(i + e);
    return [
        {
            x: r - n * t,
            y: n + r * t
        },
        {
            x: s + o * t,
            y: o - s * t
        },
        {
            x: s,
            y: o
        }
    ];
}
function t1(i, e, t, r) {
    let n = i * r - e * t < 0 ? -1 : 1, s = Math.min(1, Math.max(-1, i * t + e * r));
    return n * Math.acos(s);
}
function JO(i, e, t, r, n, s, o, a, l, c) {
    let h = Math.pow(n, 2), u = Math.pow(s, 2), f = Math.pow(o, 2), d = Math.pow(a, 2), p = h * u - h * d - u * f;
    p < 0 && (p = 0), p /= h * d + u * f, p = Math.sqrt(p) * (l === c ? -1 : 1);
    let m = p * n / s * a, g = p * -s / n * o, v = m + (i + t) / 2, y = g + (e + r) / 2, w = (o - m) / n, b = (a - g) / s, S = (-o - m) / n, T = (-a - g) / s, A = t1(1, 0, w, b), x = t1(w, b, S, T);
    return !c && x > 0 && (x -= sv), c && x < 0 && (x += sv), {
        centerx: v,
        centery: y,
        ang1: A,
        ang2: x
    };
}
function r1({ px: i , py: e , cx: t , cy: r , rx: n , ry: s , largeArcFlag: o , sweepFlag: a  }) {
    let l = [];
    if (n === 0 || s === 0) return [];
    let c = (i - t) / 2, h = (e - r) / 2;
    if (c === 0 && h === 0) return [];
    n = Math.abs(n), s = Math.abs(s);
    let u = Math.pow(c, 2) / Math.pow(n, 2) + Math.pow(h, 2) / Math.pow(s, 2);
    u > 1 && (n *= Math.sqrt(u), s *= Math.sqrt(u));
    let f = JO(i, e, t, r, n, s, c, h, o, a), { ang1: d , ang2: p  } = f, { centerx: m , centery: g  } = f, v = Math.abs(p) / (sv / 4);
    Math.abs(1 - v) < 1e-7 && (v = 1);
    let y = Math.max(Math.ceil(v), 1);
    p /= y;
    for(let w8 = 0; w8 < y; w8++)l.push(QO(d, p)), d += p;
    return l.map((w)=>{
        let { x: b , y: S  } = iv(w[0], n, s, m, g), { x: T , y: A  } = iv(w[1], n, s, m, g), { x , y: E  } = iv(w[2], n, s, m, g);
        return {
            x1: b,
            y1: S,
            x2: T,
            y2: A,
            x,
            y: E
        };
    });
}
var Zt;
(function(i) {
    i[i.ODD = 0] = "ODD", i[i.NONZERO = 1] = "NONZERO", i[i.POSITIVE = 2] = "POSITIVE", i[i.NEGATIVE = 3] = "NEGATIVE", i[i.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO";
})(Zt || (Zt = {}));
var Tr;
(function(i) {
    i[i.POLYGONS = 0] = "POLYGONS", i[i.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", i[i.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS";
})(Tr || (Tr = {}));
function qe(i, e) {
    if (!i) throw e || "Assertion Failed!";
}
var ze = function() {
    function i() {}
    return i.vertEq = function(e, t) {
        return e.s === t.s && e.t === t.t;
    }, i.vertLeq = function(e, t) {
        return e.s < t.s || e.s === t.s && e.t <= t.t;
    }, i.transLeq = function(e, t) {
        return e.t < t.t || e.t === t.t && e.s <= t.s;
    }, i.edgeGoesLeft = function(e) {
        return i.vertLeq(e.Dst, e.Org);
    }, i.edgeGoesRight = function(e) {
        return i.vertLeq(e.Org, e.Dst);
    }, i.vertL1dist = function(e, t) {
        return Math.abs(e.s - t.s) + Math.abs(e.t - t.t);
    }, i.edgeEval = function(e, t, r) {
        qe(i.vertLeq(e, t) && i.vertLeq(t, r));
        var n = t.s - e.s, s = r.s - t.s;
        return n + s > 0 ? n < s ? t.t - e.t + (e.t - r.t) * (n / (n + s)) : t.t - r.t + (r.t - e.t) * (s / (n + s)) : 0;
    }, i.edgeSign = function(e, t, r) {
        qe(i.vertLeq(e, t) && i.vertLeq(t, r));
        var n = t.s - e.s, s = r.s - t.s;
        return n + s > 0 ? (t.t - r.t) * n + (t.t - e.t) * s : 0;
    }, i.transEval = function(e, t, r) {
        qe(i.transLeq(e, t) && i.transLeq(t, r));
        var n = t.t - e.t, s = r.t - t.t;
        return n + s > 0 ? n < s ? t.s - e.s + (e.s - r.s) * (n / (n + s)) : t.s - r.s + (r.s - e.s) * (s / (n + s)) : 0;
    }, i.transSign = function(e, t, r) {
        qe(i.transLeq(e, t) && i.transLeq(t, r));
        var n = t.t - e.t, s = r.t - t.t;
        return n + s > 0 ? (t.s - r.s) * n + (t.s - e.s) * s : 0;
    }, i.vertCCW = function(e, t, r) {
        return e.s * (t.t - r.t) + t.s * (r.t - e.t) + r.s * (e.t - t.t) >= 0;
    }, i.interpolate = function(e, t, r, n) {
        return e = e < 0 ? 0 : e, r = r < 0 ? 0 : r, e <= r ? r === 0 ? (t + n) / 2 : t + (n - t) * (e / (e + r)) : n + (t - n) * (r / (e + r));
    }, i.intersect = function(e, t, r, n, s) {
        var o, a, l;
        i.vertLeq(e, t) || (l = e, e = t, t = l), i.vertLeq(r, n) || (l = r, r = n, n = l), i.vertLeq(e, r) || (l = e, e = r, r = l, l = t, t = n, n = l), i.vertLeq(r, t) ? i.vertLeq(t, n) ? (o = i.edgeEval(e, r, t), a = i.edgeEval(r, t, n), o + a < 0 && (o = -o, a = -a), s.s = i.interpolate(o, r.s, a, t.s)) : (o = i.edgeSign(e, r, t), a = -i.edgeSign(e, n, t), o + a < 0 && (o = -o, a = -a), s.s = i.interpolate(o, r.s, a, n.s)) : s.s = (r.s + t.s) / 2, i.transLeq(e, t) || (l = e, e = t, t = l), i.transLeq(r, n) || (l = r, r = n, n = l), i.transLeq(e, r) || (l = e, e = r, r = l, l = t, t = n, n = l), i.transLeq(r, t) ? i.transLeq(t, n) ? (o = i.transEval(e, r, t), a = i.transEval(r, t, n), o + a < 0 && (o = -o, a = -a), s.t = i.interpolate(o, r.t, a, t.t)) : (o = i.transSign(e, r, t), a = -i.transSign(e, n, t), o + a < 0 && (o = -o, a = -a), s.t = i.interpolate(o, r.t, a, n.t)) : s.t = (r.t + t.t) / 2;
    }, i;
}(), Hh = function() {
    function i() {
        this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1;
    }
    return i;
}(), up = function() {
    function i(e) {
        this.side = e, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0;
    }
    return Object.defineProperty(i.prototype, "Rface", {
        get: function() {
            return this.Sym.Lface;
        },
        set: function(e) {
            this.Sym.Lface = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Dst", {
        get: function() {
            return this.Sym.Org;
        },
        set: function(e) {
            this.Sym.Org = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Oprev", {
        get: function() {
            return this.Sym.Lnext;
        },
        set: function(e) {
            this.Sym.Lnext = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Lprev", {
        get: function() {
            return this.Onext.Sym;
        },
        set: function(e) {
            this.Onext.Sym = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Dprev", {
        get: function() {
            return this.Lnext.Sym;
        },
        set: function(e) {
            this.Lnext.Sym = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Rprev", {
        get: function() {
            return this.Sym.Onext;
        },
        set: function(e) {
            this.Sym.Onext = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Dnext", {
        get: function() {
            return this.Sym.Onext.Sym;
        },
        set: function(e) {
            this.Sym.Onext.Sym = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(i.prototype, "Rnext", {
        get: function() {
            return this.Sym.Lnext.Sym;
        },
        set: function(e) {
            this.Sym.Lnext.Sym = e;
        },
        enumerable: !0,
        configurable: !0
    }), i;
}(), Ll = function() {
    function i() {
        this.next = null, this.prev = null, this.anEdge = null, this.coords = [
            0,
            0,
            0
        ], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
    }
    return i;
}(), n1 = function() {
    function i() {
        var e = new Ll, t = new Hh, r = new up(0), n = new up(1);
        e.next = e.prev = e, e.anEdge = null, t.next = t.prev = t, r.next = r, r.Sym = n, n.next = n, n.Sym = r, this.vHead = e, this.fHead = t, this.eHead = r, this.eHeadSym = n;
    }
    return i.prototype.makeEdge_ = function(e) {
        var t = new up(0), r = new up(1);
        e.Sym.side < e.side && (e = e.Sym);
        var n = e.Sym.next;
        return r.next = n, n.Sym.next = t, t.next = e, e.Sym.next = r, t.Sym = r, t.Onext = t, t.Lnext = r, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, r.Sym = t, r.Onext = r, r.Lnext = t, r.Org = null, r.Lface = null, r.winding = 0, r.activeRegion = null, t;
    }, i.prototype.splice_ = function(e, t) {
        var r = e.Onext, n = t.Onext;
        r.Sym.Lnext = t, n.Sym.Lnext = e, e.Onext = n, t.Onext = r;
    }, i.prototype.makeVertex_ = function(e, t, r) {
        var n = e;
        qe(n, "Vertex can't be null!");
        var s = r.prev;
        n.prev = s, s.next = n, n.next = r, r.prev = n, n.anEdge = t;
        var o = t;
        do o.Org = n, o = o.Onext;
        while (o !== t)
    }, i.prototype.makeFace_ = function(e, t, r) {
        var n = e;
        qe(n, "Face can't be null");
        var s = r.prev;
        n.prev = s, s.next = n, n.next = r, r.prev = n, n.anEdge = t, n.trail = null, n.marked = !1, n.inside = r.inside;
        var o = t;
        do o.Lface = n, o = o.Lnext;
        while (o !== t)
    }, i.prototype.killEdge_ = function(e) {
        e.Sym.side < e.side && (e = e.Sym);
        var t = e.next, r = e.Sym.next;
        t.Sym.next = r, r.Sym.next = t;
    }, i.prototype.killVertex_ = function(e, t) {
        var r = e.anEdge, n = r;
        do n.Org = t, n = n.Onext;
        while (n !== r)
        var s = e.prev, o = e.next;
        o.prev = s, s.next = o;
    }, i.prototype.killFace_ = function(e, t) {
        var r = e.anEdge, n = r;
        do n.Lface = t, n = n.Lnext;
        while (n !== r)
        var s = e.prev, o = e.next;
        o.prev = s, s.next = o;
    }, i.prototype.makeEdge = function() {
        var e = new Ll, t = new Ll, r = new Hh, n = this.makeEdge_(this.eHead);
        return this.makeVertex_(e, n, this.vHead), this.makeVertex_(t, n.Sym, this.vHead), this.makeFace_(r, n, this.fHead), n;
    }, i.prototype.splice = function(e, t) {
        var r = !1, n = !1;
        if (e !== t) {
            if (t.Org !== e.Org && (n = !0, this.killVertex_(t.Org, e.Org)), t.Lface !== e.Lface && (r = !0, this.killFace_(t.Lface, e.Lface)), this.splice_(t, e), !n) {
                var s = new Ll;
                this.makeVertex_(s, t, e.Org), e.Org.anEdge = e;
            }
            if (!r) {
                var o = new Hh;
                this.makeFace_(o, t, e.Lface), e.Lface.anEdge = e;
            }
        }
    }, i.prototype.delete = function(e) {
        var t = e.Sym, r = !1;
        if (e.Lface !== e.Rface && (r = !0, this.killFace_(e.Lface, e.Rface)), e.Onext === e) this.killVertex_(e.Org, null);
        else if (e.Rface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev), !r) {
            var n = new Hh;
            this.makeFace_(n, e, e.Lface);
        }
        t.Onext === t ? (this.killVertex_(t.Org, null), this.killFace_(t.Lface, null)) : (e.Lface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), this.killEdge_(e);
    }, i.prototype.addEdgeVertex = function(e) {
        var t = this.makeEdge_(e), r = t.Sym;
        this.splice_(t, e.Lnext), t.Org = e.Dst;
        var n = new Ll;
        return this.makeVertex_(n, r, t.Org), t.Lface = r.Lface = e.Lface, t;
    }, i.prototype.splitEdge = function(e) {
        var t = this.addEdgeVertex(e), r = t.Sym;
        return this.splice_(e.Sym, e.Sym.Oprev), this.splice_(e.Sym, r), e.Dst = r.Org, r.Dst.anEdge = r.Sym, r.Rface = e.Rface, r.winding = e.winding, r.Sym.winding = e.Sym.winding, r.idx = e.idx, r.Sym.idx = e.Sym.idx, r;
    }, i.prototype.connect = function(e, t) {
        var r = !1, n = this.makeEdge_(e), s = n.Sym;
        if (t.Lface !== e.Lface && (r = !0, this.killFace_(t.Lface, e.Lface)), this.splice_(n, e.Lnext), this.splice_(s, t), n.Org = e.Dst, s.Org = t.Org, n.Lface = s.Lface = e.Lface, e.Lface.anEdge = s, !r) {
            var o = new Hh;
            this.makeFace_(o, n, e.Lface);
        }
        return n;
    }, i.prototype.zapFace = function(e) {
        var t = e.anEdge, r, n, s, o, a;
        n = t.Lnext;
        do r = n, n = r.Lnext, r.Lface = null, r.Rface === null && (r.Onext === r ? this.killVertex_(r.Org, null) : (r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev)), s = r.Sym, s.Onext === s ? this.killVertex_(s.Org, null) : (s.Org.anEdge = s.Onext, this.splice_(s, s.Oprev)), this.killEdge_(r));
        while (r != t)
        o = e.prev, a = e.next, a.prev = o, o.next = a;
    }, i.prototype.countFaceVerts_ = function(e) {
        var t = e.anEdge, r = 0;
        do r++, t = t.Lnext;
        while (t !== e.anEdge)
        return r;
    }, i.prototype.mergeConvexFaces = function(e) {
        var t, r, n, s, o, a, l;
        for(t = this.fHead.next; t !== this.fHead; t = t.next)if (!!t.inside) for(r = t.anEdge, o = r.Org; n = r.Lnext, s = r.Sym, s && s.Lface && s.Lface.inside && (a = this.countFaceVerts_(t), l = this.countFaceVerts_(s.Lface), a + l - 2 <= e && ze.vertCCW(r.Lprev.Org, r.Org, s.Lnext.Lnext.Org) && ze.vertCCW(s.Lprev.Org, s.Org, r.Lnext.Lnext.Org) && (n = s.Lnext, this.delete(s), r = null, s = null)), !(r && r.Lnext.Org === o);)r = n;
        return !0;
    }, i.prototype.check = function() {
        var e = this.fHead, t = this.vHead, r = this.eHead, n, s, o, a, l, c;
        for(s = e, s = e; (n = s.next) !== e; s = n){
            qe(n.prev === s), l = n.anEdge;
            do qe(l.Sym !== l), qe(l.Sym.Sym === l), qe(l.Lnext.Onext.Sym === l), qe(l.Onext.Sym.Lnext === l), qe(l.Lface === n), l = l.Lnext;
            while (l !== n.anEdge)
        }
        for(qe(n.prev === s && n.anEdge === null), a = t, a = t; (o = a.next) !== t; a = o){
            qe(o.prev === a), l = o.anEdge;
            do qe(l.Sym !== l), qe(l.Sym.Sym === l), qe(l.Lnext.Onext.Sym === l), qe(l.Onext.Sym.Lnext === l), qe(l.Org === o), l = l.Onext;
            while (l !== o.anEdge)
        }
        for(qe(o.prev === a && o.anEdge === null), c = r, c = r; (l = c.next) !== r; c = l)qe(l.Sym.next === c.Sym), qe(l.Sym !== l), qe(l.Sym.Sym === l), qe(l.Org !== null), qe(l.Dst !== null), qe(l.Lnext.Onext.Sym === l), qe(l.Onext.Sym.Lnext === l);
        qe(l.Sym.next === c.Sym && l.Sym === this.eHeadSym && l.Sym.Sym === l && l.Org === null && l.Dst === null && l.Lface === null && l.Rface === null);
    }, i;
}(), i111 = function() {
    function i() {
        this.handle = null;
    }
    return i;
}(), s1 = function() {
    function i() {
        this.key = null, this.node = 0;
    }
    return i;
}(), KO = function() {
    function i(e, t) {
        this.leq = t, this.max = 0, this.nodes = [], this.handles = [], this.initialized = !1, this.freeList = 0, this.size = 0, this.max = e, this.nodes = [], this.handles = [];
        for(var r = 0; r < e + 1; r++)this.nodes[r] = new i111, this.handles[r] = new s1;
        this.initialized = !1, this.nodes[1].handle = 1, this.handles[1].key = null;
    }
    return i.prototype.floatDown_ = function(e) {
        var t = this.nodes, r = this.handles, n, s, o;
        for(n = t[e].handle;;){
            if (o = e << 1, o < this.size && this.leq(r[t[o + 1].handle].key, r[t[o].handle].key) && ++o, qe(o <= this.max), s = t[o].handle, o > this.size || this.leq(r[n].key, r[s].key)) {
                t[e].handle = n, r[n].node = e;
                break;
            }
            t[e].handle = s, r[s].node = e, e = o;
        }
    }, i.prototype.floatUp_ = function(e) {
        var t = this.nodes, r = this.handles, n, s, o;
        for(n = t[e].handle;;){
            if (o = e >> 1, s = t[o].handle, o === 0 || this.leq(r[s].key, r[n].key)) {
                t[e].handle = n, r[n].node = e;
                break;
            }
            t[e].handle = s, r[s].node = e, e = o;
        }
    }, i.prototype.init = function() {
        for(var e = this.size; e >= 1; --e)this.floatDown_(e);
        this.initialized = !0;
    }, i.prototype.min = function() {
        return this.handles[this.nodes[1].handle].key;
    }, i.prototype.insert = function(e) {
        var t, r;
        if (t = ++this.size, t * 2 > this.max) {
            this.max *= 2;
            var n, s;
            for(s = this.nodes.length, this.nodes.length = this.max + 1, n = s; n < this.nodes.length; n++)this.nodes[n] = new i111;
            for(s = this.handles.length, this.handles.length = this.max + 1, n = s; n < this.handles.length; n++)this.handles[n] = new s1;
        }
        return this.freeList === 0 ? r = t : (r = this.freeList, this.freeList = this.handles[r].node), this.nodes[t].handle = r, this.handles[r].node = t, this.handles[r].key = e, this.initialized && this.floatUp_(t), r;
    }, i.prototype.extractMin = function() {
        var e = this.nodes, t = this.handles, r = e[1].handle, n = t[r].key;
        return this.size > 0 && (e[1].handle = e[this.size].handle, t[e[1].handle].node = 1, t[r].key = null, t[r].node = this.freeList, this.freeList = r, --this.size, this.size > 0 && this.floatDown_(1)), n;
    }, i.prototype.delete = function(e) {
        var t = this.nodes, r = this.handles, n;
        qe(e >= 1 && e <= this.max && r[e].key !== null), n = r[e].node, t[n].handle = t[this.size].handle, r[t[n].handle].node = n, --this.size, n <= this.size && (n <= 1 || this.leq(r[t[n >> 1].handle].key, r[t[n].handle].key) ? this.floatDown_(n) : this.floatUp_(n)), r[e].key = null, r[e].node = this.freeList, this.freeList = e;
    }, i;
}(), ov = function() {
    function i() {
        this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1;
    }
    return i;
}(), o1 = function() {
    function i() {
        this.key = null, this.next = null, this.prev = null;
    }
    return i;
}(), ZO = function() {
    function i(e, t) {
        this.frame = e, this.leq = t, this.head = new o1, this.head.next = this.head, this.head.prev = this.head;
    }
    return i.prototype.min = function() {
        return this.head.next;
    }, i.prototype.max = function() {
        return this.head.prev;
    }, i.prototype.insert = function(e) {
        return this.insertBefore(this.head, e);
    }, i.prototype.search = function(e) {
        var t = this.head;
        do t = t.next;
        while (t.key !== null && !this.leq(this.frame, e, t.key))
        return t;
    }, i.prototype.insertBefore = function(e, t) {
        do e = e.prev;
        while (e.key !== null && !this.leq(this.frame, e.key, t))
        var r = new o1;
        return r.key = t, r.next = e.next, e.next.prev = r, r.prev = e, e.next = r, r;
    }, i.prototype.delete = function(e) {
        e.next.prev = e.prev, e.prev.next = e.next;
    }, i;
}(), $O = function() {
    function i() {}
    return i.regionBelow = function(e) {
        return e.nodeUp.prev.key;
    }, i.regionAbove = function(e) {
        return e.nodeUp.next.key;
    }, i.debugEvent = function(e) {}, i.addWinding = function(e, t) {
        e.winding += t.winding, e.Sym.winding += t.Sym.winding;
    }, i.edgeLeq = function(e, t, r) {
        var n = e.event, s = t.eUp, o = r.eUp;
        if (s.Dst === n) return o.Dst === n ? ze.vertLeq(s.Org, o.Org) ? ze.edgeSign(o.Dst, s.Org, o.Org) <= 0 : ze.edgeSign(s.Dst, o.Org, s.Org) >= 0 : ze.edgeSign(o.Dst, n, o.Org) <= 0;
        if (o.Dst === n) return ze.edgeSign(s.Dst, n, s.Org) >= 0;
        var a = ze.edgeEval(s.Dst, n, s.Org), l = ze.edgeEval(o.Dst, n, o.Org);
        return a >= l;
    }, i.deleteRegion = function(e, t) {
        t.fixUpperEdge && qe(t.eUp.winding === 0), t.eUp.activeRegion = null, e.dict.delete(t.nodeUp);
    }, i.fixUpperEdge = function(e, t, r) {
        qe(t.fixUpperEdge), e.mesh.delete(t.eUp), t.fixUpperEdge = !1, t.eUp = r, r.activeRegion = t;
    }, i.topLeftRegion = function(e, t) {
        var r = t.eUp.Org, n;
        do t = i.regionAbove(t);
        while (t.eUp.Org === r)
        if (t.fixUpperEdge) {
            if (n = e.mesh.connect(i.regionBelow(t).eUp.Sym, t.eUp.Lnext), n === null) return null;
            i.fixUpperEdge(e, t, n), t = i.regionAbove(t);
        }
        return t;
    }, i.topRightRegion = function(e) {
        var t = e.eUp.Dst;
        do e = i.regionAbove(e);
        while (e.eUp.Dst === t)
        return e;
    }, i.addRegionBelow = function(e, t, r) {
        var n = new ov;
        return n.eUp = r, n.nodeUp = e.dict.insertBefore(t.nodeUp, n), n.fixUpperEdge = !1, n.sentinel = !1, n.dirty = !1, r.activeRegion = n, n;
    }, i.isWindingInside = function(e, t) {
        switch(e.windingRule){
            case Zt.ODD:
                return (t & 1) !== 0;
            case Zt.NONZERO:
                return t !== 0;
            case Zt.POSITIVE:
                return t > 0;
            case Zt.NEGATIVE:
                return t < 0;
            case Zt.ABS_GEQ_TWO:
                return t >= 2 || t <= -2;
        }
        throw new Error("Invalid winding rulle");
    }, i.computeWinding = function(e, t) {
        t.windingNumber = i.regionAbove(t).windingNumber + t.eUp.winding, t.inside = i.isWindingInside(e, t.windingNumber);
    }, i.finishRegion = function(e, t) {
        var r = t.eUp, n = r.Lface;
        n.inside = t.inside, n.anEdge = r, i.deleteRegion(e, t);
    }, i.finishLeftRegions = function(e, t, r) {
        for(var n, s = null, o = t, a = t.eUp; o !== r;){
            if (o.fixUpperEdge = !1, s = i.regionBelow(o), n = s.eUp, n.Org != a.Org) {
                if (!s.fixUpperEdge) {
                    i.finishRegion(e, o);
                    break;
                }
                n = e.mesh.connect(a.Lprev, n.Sym), i.fixUpperEdge(e, s, n);
            }
            a.Onext !== n && (e.mesh.splice(n.Oprev, n), e.mesh.splice(a, n)), i.finishRegion(e, o), a = s.eUp, o = s;
        }
        return a;
    }, i.addRightEdges = function(e, t, r, n, s, o) {
        var a, l, c, h, u = !0;
        c = r;
        do qe(ze.vertLeq(c.Org, c.Dst)), i.addRegionBelow(e, t, c.Sym), c = c.Onext;
        while (c !== n)
        for(s === null && (s = i.regionBelow(t).eUp.Rprev), l = t, h = s; a = i.regionBelow(l), c = a.eUp.Sym, c.Org === h.Org;)c.Onext !== h && (e.mesh.splice(c.Oprev, c), e.mesh.splice(h.Oprev, c)), a.windingNumber = l.windingNumber - c.winding, a.inside = i.isWindingInside(e, a.windingNumber), l.dirty = !0, !u && i.checkForRightSplice(e, l) && (i.addWinding(c, h), i.deleteRegion(e, l), e.mesh.delete(h)), u = !1, l = a, h = c;
        l.dirty = !0, qe(l.windingNumber - c.winding === a.windingNumber), o && i.walkDirtyRegions(e, l);
    }, i.spliceMergeVertices = function(e, t, r) {
        e.mesh.splice(t, r);
    }, i.vertexWeights = function(e, t, r) {
        var n = ze.vertL1dist(t, e), s = ze.vertL1dist(r, e), o = .5 * s / (n + s), a = .5 * n / (n + s);
        e.coords[0] += o * t.coords[0] + a * r.coords[0], e.coords[1] += o * t.coords[1] + a * r.coords[1], e.coords[2] += o * t.coords[2] + a * r.coords[2];
    }, i.getIntersectData = function(e, t, r, n, s, o) {
        t.coords[0] = t.coords[1] = t.coords[2] = 0, t.idx = -1, i.vertexWeights(t, r, n), i.vertexWeights(t, s, o);
    }, i.checkForRightSplice = function(e, t) {
        var r = i.regionBelow(t), n = t.eUp, s = r.eUp;
        if (ze.vertLeq(n.Org, s.Org)) {
            if (ze.edgeSign(s.Dst, n.Org, s.Org) > 0) return !1;
            ze.vertEq(n.Org, s.Org) ? n.Org !== s.Org && (e.pq.delete(n.Org.pqHandle), i.spliceMergeVertices(e, s.Oprev, n)) : (e.mesh.splitEdge(s.Sym), e.mesh.splice(n, s.Oprev), t.dirty = r.dirty = !0);
        } else {
            if (ze.edgeSign(n.Dst, s.Org, n.Org) < 0) return !1;
            i.regionAbove(t).dirty = t.dirty = !0, e.mesh.splitEdge(n.Sym), e.mesh.splice(s.Oprev, n);
        }
        return !0;
    }, i.checkForLeftSplice = function(e, t) {
        var r = i.regionBelow(t), n = t.eUp, s = r.eUp, o;
        if (qe(!ze.vertEq(n.Dst, s.Dst)), ze.vertLeq(n.Dst, s.Dst)) {
            if (ze.edgeSign(n.Dst, s.Dst, n.Org) < 0) return !1;
            i.regionAbove(t).dirty = t.dirty = !0, o = e.mesh.splitEdge(n), e.mesh.splice(s.Sym, o), o.Lface.inside = t.inside;
        } else {
            if (ze.edgeSign(s.Dst, n.Dst, s.Org) > 0) return !1;
            t.dirty = r.dirty = !0, o = e.mesh.splitEdge(s), e.mesh.splice(n.Lnext, s.Sym), o.Rface.inside = t.inside;
        }
        return !0;
    }, i.checkForIntersect = function(e, t) {
        var r = i.regionBelow(t), n = t.eUp, s = r.eUp, o = n.Org, a = s.Org, l = n.Dst, c = s.Dst, h, u, f = new Ll, d, p;
        if (qe(!ze.vertEq(c, l)), qe(ze.edgeSign(l, e.event, o) <= 0), qe(ze.edgeSign(c, e.event, a) >= 0), qe(o !== e.event && a !== e.event), qe(!t.fixUpperEdge && !r.fixUpperEdge), o === a || (h = Math.min(o.t, l.t), u = Math.max(a.t, c.t), h > u)) return !1;
        if (ze.vertLeq(o, a)) {
            if (ze.edgeSign(c, o, a) > 0) return !1;
        } else if (ze.edgeSign(l, a, o) < 0) return !1;
        return i.debugEvent(e), ze.intersect(l, o, c, a, f), qe(Math.min(o.t, l.t) <= f.t), qe(f.t <= Math.max(a.t, c.t)), qe(Math.min(c.s, l.s) <= f.s), qe(f.s <= Math.max(a.s, o.s)), ze.vertLeq(f, e.event) && (f.s = e.event.s, f.t = e.event.t), d = ze.vertLeq(o, a) ? o : a, ze.vertLeq(d, f) && (f.s = d.s, f.t = d.t), ze.vertEq(f, o) || ze.vertEq(f, a) ? (i.checkForRightSplice(e, t), !1) : !ze.vertEq(l, e.event) && ze.edgeSign(l, e.event, f) >= 0 || !ze.vertEq(c, e.event) && ze.edgeSign(c, e.event, f) <= 0 ? c === e.event ? (e.mesh.splitEdge(n.Sym), e.mesh.splice(s.Sym, n), t = i.topLeftRegion(e, t), n = i.regionBelow(t).eUp, i.finishLeftRegions(e, i.regionBelow(t), r), i.addRightEdges(e, t, n.Oprev, n, n, !0), !0) : l === e.event ? (e.mesh.splitEdge(s.Sym), e.mesh.splice(n.Lnext, s.Oprev), r = t, t = i.topRightRegion(t), p = i.regionBelow(t).eUp.Rprev, r.eUp = s.Oprev, s = i.finishLeftRegions(e, r, null), i.addRightEdges(e, t, s.Onext, n.Rprev, p, !0), !0) : (ze.edgeSign(l, e.event, f) >= 0 && (i.regionAbove(t).dirty = t.dirty = !0, e.mesh.splitEdge(n.Sym), n.Org.s = e.event.s, n.Org.t = e.event.t), ze.edgeSign(c, e.event, f) <= 0 && (t.dirty = r.dirty = !0, e.mesh.splitEdge(s.Sym), s.Org.s = e.event.s, s.Org.t = e.event.t), !1) : (e.mesh.splitEdge(n.Sym), e.mesh.splitEdge(s.Sym), e.mesh.splice(s.Oprev, n), n.Org.s = f.s, n.Org.t = f.t, n.Org.pqHandle = e.pq.insert(n.Org), i.getIntersectData(e, n.Org, o, l, a, c), i.regionAbove(t).dirty = t.dirty = r.dirty = !0, !1);
    }, i.walkDirtyRegions = function(e, t) {
        for(var r = i.regionBelow(t), n, s;;){
            for(; r.dirty;)t = r, r = i.regionBelow(r);
            if (!t.dirty && (r = t, t = i.regionAbove(t), t === null || !t.dirty)) return;
            if (t.dirty = !1, n = t.eUp, s = r.eUp, n.Dst !== s.Dst && i.checkForLeftSplice(e, t) && (r.fixUpperEdge ? (i.deleteRegion(e, r), e.mesh.delete(s), r = i.regionBelow(t), s = r.eUp) : t.fixUpperEdge && (i.deleteRegion(e, t), e.mesh.delete(n), t = i.regionAbove(r), n = t.eUp)), n.Org !== s.Org) {
                if (n.Dst !== s.Dst && !t.fixUpperEdge && !r.fixUpperEdge && (n.Dst === e.event || s.Dst === e.event)) {
                    if (i.checkForIntersect(e, t)) return;
                } else i.checkForRightSplice(e, t);
            }
            n.Org === s.Org && n.Dst === s.Dst && (i.addWinding(s, n), i.deleteRegion(e, t), e.mesh.delete(n), t = i.regionAbove(r));
        }
    }, i.connectRightVertex = function(e, t, r) {
        var n, s = r.Onext, o = i.regionBelow(t), a = t.eUp, l = o.eUp, c = !1;
        if (a.Dst !== l.Dst && i.checkForIntersect(e, t), ze.vertEq(a.Org, e.event) && (e.mesh.splice(s.Oprev, a), t = i.topLeftRegion(e, t), s = i.regionBelow(t).eUp, i.finishLeftRegions(e, i.regionBelow(t), o), c = !0), ze.vertEq(l.Org, e.event) && (e.mesh.splice(r, l.Oprev), r = i.finishLeftRegions(e, o, null), c = !0), c) {
            i.addRightEdges(e, t, r.Onext, s, s, !0);
            return;
        }
        ze.vertLeq(l.Org, a.Org) ? n = l.Oprev : n = a, n = e.mesh.connect(r.Lprev, n), i.addRightEdges(e, t, n, n.Onext, n.Onext, !1), n.Sym.activeRegion.fixUpperEdge = !0, i.walkDirtyRegions(e, t);
    }, i.connectLeftDegenerate = function(e, t, r) {
        var n, s, o, a, l;
        if (n = t.eUp, ze.vertEq(n.Org, r)) {
            qe(!1), i.spliceMergeVertices(e, n, r.anEdge);
            return;
        }
        if (!ze.vertEq(n.Dst, r)) {
            e.mesh.splitEdge(n.Sym), t.fixUpperEdge && (e.mesh.delete(n.Onext), t.fixUpperEdge = !1), e.mesh.splice(r.anEdge, n), i.sweepEvent(e, r);
            return;
        }
        qe(!1), t = i.topRightRegion(t), l = i.regionBelow(t), o = l.eUp.Sym, s = a = o.Onext, l.fixUpperEdge && (qe(s !== o), i.deleteRegion(e, l), e.mesh.delete(o), o = s.Oprev), e.mesh.splice(r.anEdge, o), ze.edgeGoesLeft(s) || (s = null), i.addRightEdges(e, t, o.Onext, a, s, !0);
    }, i.connectLeftVertex = function(e, t) {
        var r, n, s, o, a, l, c = new ov;
        if (c.eUp = t.anEdge.Sym, r = e.dict.search(c).key, n = i.regionBelow(r), !!n) {
            if (o = r.eUp, a = n.eUp, ze.edgeSign(o.Dst, t, o.Org) === 0) {
                i.connectLeftDegenerate(e, r, t);
                return;
            }
            if (s = ze.vertLeq(a.Dst, o.Dst) ? r : n, r.inside || s.fixUpperEdge) {
                if (s === r) l = e.mesh.connect(t.anEdge.Sym, o.Lnext);
                else {
                    var h = e.mesh.connect(a.Dnext, t.anEdge);
                    l = h.Sym;
                }
                s.fixUpperEdge ? i.fixUpperEdge(e, s, l) : i.computeWinding(e, i.addRegionBelow(e, r, l)), i.sweepEvent(e, t);
            } else i.addRightEdges(e, r, t.anEdge, t.anEdge, null, !0);
        }
    }, i.sweepEvent = function(e, t) {
        e.event = t, i.debugEvent(e);
        for(var r = t.anEdge; r.activeRegion === null;)if (r = r.Onext, r === t.anEdge) {
            i.connectLeftVertex(e, t);
            return;
        }
        var n = i.topLeftRegion(e, r.activeRegion);
        qe(n !== null);
        var s = i.regionBelow(n), o = s.eUp, a = i.finishLeftRegions(e, s, null);
        a.Onext === o ? i.connectRightVertex(e, n, a) : i.addRightEdges(e, n, a.Onext, o, o, !0);
    }, i.addSentinel = function(e, t, r, n) {
        var s = new ov, o = e.mesh.makeEdge();
        o.Org.s = r, o.Org.t = n, o.Dst.s = t, o.Dst.t = n, e.event = o.Dst, s.eUp = o, s.windingNumber = 0, s.inside = !1, s.fixUpperEdge = !1, s.sentinel = !0, s.dirty = !1, s.nodeUp = e.dict.insert(s);
    }, i.initEdgeDict = function(e) {
        e.dict = new ZO(e, i.edgeLeq);
        var t = e.bmax[0] - e.bmin[0], r = e.bmax[1] - e.bmin[1], n = e.bmin[0] - t, s = e.bmax[0] + t, o = e.bmin[1] - r, a = e.bmax[1] + r;
        i.addSentinel(e, n, s, o), i.addSentinel(e, n, s, a);
    }, i.doneEdgeDict = function(e) {
        for(var t, r = 0; (t = e.dict.min().key) !== null;)t.sentinel || (qe(t.fixUpperEdge), qe(++r === 1)), qe(t.windingNumber === 0), i.deleteRegion(e, t);
    }, i.removeDegenerateEdges = function(e) {
        var t, r, n, s = e.mesh.eHead;
        for(t = s.next; t !== s; t = r)r = t.next, n = t.Lnext, ze.vertEq(t.Org, t.Dst) && t.Lnext.Lnext !== t && (i.spliceMergeVertices(e, n, t), e.mesh.delete(t), t = n, n = t.Lnext), n.Lnext === t && (n !== t && ((n === r || n === r.Sym) && (r = r.next), e.mesh.delete(n)), (t === r || t === r.Sym) && (r = r.next), e.mesh.delete(t));
    }, i.initPriorityQ = function(e) {
        var t, r, n, s = 0;
        for(n = e.mesh.vHead, r = n.next; r !== n; r = r.next)s++;
        for(s += 8, t = e.pq = new KO(s, ze.vertLeq), n = e.mesh.vHead, r = n.next; r !== n; r = r.next)r.pqHandle = t.insert(r);
        return r !== n ? !1 : (t.init(), !0);
    }, i.donePriorityQ = function(e) {
        e.pq = null;
    }, i.removeDegenerateFaces = function(e, t) {
        var r, n, s;
        for(r = t.fHead.next; r !== t.fHead; r = n)n = r.next, s = r.anEdge, qe(s.Lnext !== s), s.Lnext.Lnext === s && (i.addWinding(s.Onext, s), e.mesh.delete(s));
        return !0;
    }, i.computeInterior = function(e, t) {
        t === void 0 && (t = !0);
        var r, n;
        if (i.removeDegenerateEdges(e), !i.initPriorityQ(e)) return !1;
        for(i.initEdgeDict(e); (r = e.pq.extractMin()) !== null;){
            for(; n = e.pq.min(), !(n === null || !ze.vertEq(n, r));)n = e.pq.extractMin(), i.spliceMergeVertices(e, r.anEdge, n.anEdge);
            i.sweepEvent(e, r);
        }
        return e.event = e.dict.min().key.eUp.Org, i.debugEvent(e), i.doneEdgeDict(e), i.donePriorityQ(e), i.removeDegenerateFaces(e, e.mesh) ? (t && e.mesh.check(), !0) : !1;
    }, i;
}(), eF = function() {
    function i() {
        this.mesh = new n1, this.normal = [
            0,
            0,
            0
        ], this.sUnit = [
            0,
            0,
            0
        ], this.tUnit = [
            0,
            0,
            0
        ], this.bmin = [
            0,
            0
        ], this.bmax = [
            0,
            0
        ], this.windingRule = Zt.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
    }
    return i.prototype.dot_ = function(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
    }, i.prototype.normalize_ = function(e) {
        var t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
        if (!t) throw "Zero-size vector!";
        t = Math.sqrt(t), e[0] /= t, e[1] /= t, e[2] /= t;
    }, i.prototype.longAxis_ = function(e) {
        var t = 0;
        return Math.abs(e[1]) > Math.abs(e[0]) && (t = 1), Math.abs(e[2]) > Math.abs(e[t]) && (t = 2), t;
    }, i.prototype.computeNormal_ = function(e) {
        var t, r, n, s, o, a, l = [
            0,
            0,
            0
        ], c = [
            0,
            0,
            0
        ], h = [
            0,
            0,
            0
        ], u = [
            0,
            0,
            0
        ], f = [
            0,
            0,
            0
        ], d = [
            null,
            null,
            null
        ], p = [
            null,
            null,
            null
        ], m = this.mesh.vHead;
        t = m.next;
        for(var g = 0; g < 3; ++g)s = t.coords[g], c[g] = s, p[g] = t, l[g] = s, d[g] = t;
        for(t = m.next; t !== m; t = t.next)for(var v = 0; v < 3; ++v)s = t.coords[v], s < c[v] && (c[v] = s, p[v] = t), s > l[v] && (l[v] = s, d[v] = t);
        var y = 0;
        if (l[1] - c[1] > l[0] - c[0] && (y = 1), l[2] - c[2] > l[y] - c[y] && (y = 2), c[y] >= l[y]) {
            e[0] = 0, e[1] = 0, e[2] = 1;
            return;
        }
        for(a = 0, r = p[y], n = d[y], h[0] = r.coords[0] - n.coords[0], h[1] = r.coords[1] - n.coords[1], h[2] = r.coords[2] - n.coords[2], t = m.next; t !== m; t = t.next)u[0] = t.coords[0] - n.coords[0], u[1] = t.coords[1] - n.coords[1], u[2] = t.coords[2] - n.coords[2], f[0] = h[1] * u[2] - h[2] * u[1], f[1] = h[2] * u[0] - h[0] * u[2], f[2] = h[0] * u[1] - h[1] * u[0], o = f[0] * f[0] + f[1] * f[1] + f[2] * f[2], o > a && (a = o, e[0] = f[0], e[1] = f[1], e[2] = f[2]);
        a <= 0 && (e[0] = e[1] = e[2] = 0, e[this.longAxis_(h)] = 1);
    }, i.prototype.checkOrientation_ = function() {
        for(var e = this.mesh.fHead, t, r = this.mesh.vHead, n, s = 0, o = e.next; o !== e; o = o.next)if (n = o.anEdge, !(n.winding <= 0)) do s += (n.Org.s - n.Dst.s) * (n.Org.t + n.Dst.t), n = n.Lnext;
        while (n !== o.anEdge)
        if (s < 0) {
            for(t = r.next; t !== r; t = t.next)t.t = -t.t;
            this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
        }
    }, i.prototype.projectPolygon_ = function() {
        var e = this.mesh.vHead, t = [
            0,
            0,
            0
        ], r, n, s = !1;
        t[0] = this.normal[0], t[1] = this.normal[1], t[2] = this.normal[2], !t[0] && !t[1] && !t[2] && (this.computeNormal_(t), s = !0), r = this.sUnit, n = this.tUnit;
        var o = this.longAxis_(t);
        r[o] = 0, r[(o + 1) % 3] = 1, r[(o + 2) % 3] = 0, n[o] = 0, n[(o + 1) % 3] = 0, n[(o + 2) % 3] = t[o] > 0 ? 1 : -1;
        for(var a = e.next; a !== e; a = a.next)a.s = this.dot_(a.coords, r), a.t = this.dot_(a.coords, n);
        s && this.checkOrientation_();
        for(var l = !0, c = e.next; c !== e; c = c.next)l ? (this.bmin[0] = this.bmax[0] = c.s, this.bmin[1] = this.bmax[1] = c.t, l = !1) : (c.s < this.bmin[0] && (this.bmin[0] = c.s), c.s > this.bmax[0] && (this.bmax[0] = c.s), c.t < this.bmin[1] && (this.bmin[1] = c.t), c.t > this.bmax[1] && (this.bmax[1] = c.t));
    }, i.prototype.addWinding_ = function(e, t) {
        e.winding += t.winding, e.Sym.winding += t.Sym.winding;
    }, i.prototype.tessellateMonoRegion_ = function(e, t) {
        var r, n;
        if (r = t.anEdge, !(r.Lnext !== r && r.Lnext.Lnext !== r)) throw "Mono region invalid";
        for(; ze.vertLeq(r.Dst, r.Org); r = r.Lprev);
        for(; ze.vertLeq(r.Org, r.Dst); r = r.Lnext);
        n = r.Lprev;
        for(var s = void 0; r.Lnext !== n;)if (ze.vertLeq(r.Dst, n.Org)) {
            for(; n.Lnext !== r && (ze.edgeGoesLeft(n.Lnext) || ze.edgeSign(n.Org, n.Dst, n.Lnext.Dst) <= 0);)s = e.connect(n.Lnext, n), n = s.Sym;
            n = n.Lprev;
        } else {
            for(; n.Lnext !== r && (ze.edgeGoesRight(r.Lprev) || ze.edgeSign(r.Dst, r.Org, r.Lprev.Org) >= 0);)s = e.connect(r, r.Lprev), r = s.Sym;
            r = r.Lnext;
        }
        if (n.Lnext === r) throw "Mono region invalid";
        for(; n.Lnext.Lnext !== r;)s = e.connect(n.Lnext, n), n = s.Sym;
        return !0;
    }, i.prototype.tessellateInterior_ = function(e) {
        for(var t, r = e.fHead.next; r !== e.fHead; r = t)if (t = r.next, r.inside && !this.tessellateMonoRegion_(e, r)) return !1;
        return !0;
    }, i.prototype.discardExterior_ = function(e) {
        for(var t, r = e.fHead.next; r !== e.fHead; r = t)t = r.next, r.inside || e.zapFace(r);
    }, i.prototype.setWindingNumber_ = function(e, t, r) {
        for(var n, s = e.eHead.next; s !== e.eHead; s = n)n = s.next, s.Rface.inside !== s.Lface.inside ? s.winding = s.Lface.inside ? t : -t : r ? e.delete(s) : s.winding = 0;
    }, i.prototype.getNeighbourFace_ = function(e) {
        return !e.Rface || !e.Rface.inside ? -1 : e.Rface.n;
    }, i.prototype.outputPolymesh_ = function(e, t, r, n) {
        var s, o = 0, a = 0, l;
        r > 3 && e.mergeConvexFaces(r);
        for(var c = e.vHead.next; c !== e.vHead; c = c.next)c.n = -1;
        for(var h = e.fHead.next; h !== e.fHead; h = h.next)if (h.n = -1, !!h.inside) {
            s = h.anEdge, l = 0;
            do {
                var c = s.Org;
                c.n === -1 && (c.n = a, a++), l++, s = s.Lnext;
            }while (s !== h.anEdge)
            if (l > r) throw "Face vertex greater that support polygon";
            h.n = o, ++o;
        }
        this.elementCount = o, t === Tr.CONNECTED_POLYGONS && (o *= 2), this.elements = [], this.elements.length = o * r, this.vertexCount = a, this.vertices = [], this.vertices.length = a * n, this.vertexIndices = [], this.vertexIndices.length = a;
        for(var c = e.vHead.next; c !== e.vHead; c = c.next)if (c.n !== -1) {
            var u = c.n * n;
            this.vertices[u + 0] = c.coords[0], this.vertices[u + 1] = c.coords[1], n > 2 && (this.vertices[u + 2] = c.coords[2]), this.vertexIndices[c.n] = c.idx;
        }
        for(var f = 0, h = e.fHead.next; h !== e.fHead; h = h.next)if (!!h.inside) {
            s = h.anEdge, l = 0;
            do {
                var c = s.Org;
                this.elements[f++] = c.n, l++, s = s.Lnext;
            }while (s !== h.anEdge)
            for(var d = l; d < r; ++d)this.elements[f++] = -1;
            if (t === Tr.CONNECTED_POLYGONS) {
                s = h.anEdge;
                do this.elements[f++] = this.getNeighbourFace_(s), s = s.Lnext;
                while (s !== h.anEdge)
                for(var p = l; p < r; ++p)this.elements[f++] = -1;
            }
        }
    }, i.prototype.outputContours_ = function(e, t) {
        var r, n, s = 0, o = 0;
        this.vertexCount = 0, this.elementCount = 0;
        for(var a = e.fHead.next; a !== e.fHead; a = a.next)if (!!a.inside) {
            n = r = a.anEdge;
            do this.vertexCount++, r = r.Lnext;
            while (r !== n)
            this.elementCount++;
        }
        this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * t, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
        var l = 0, c = 0, h = 0;
        s = 0;
        for(var a = e.fHead.next; a !== e.fHead; a = a.next)if (!!a.inside) {
            o = 0, n = r = a.anEdge;
            do this.vertices[l++] = r.Org.coords[0], this.vertices[l++] = r.Org.coords[1], t > 2 && (this.vertices[l++] = r.Org.coords[2]), this.vertexIndices[c++] = this.vertexIdCallback ? this.vertexIdCallback(r) : r.Org.idx, o++, r = r.Lnext;
            while (r !== n)
            this.elements[h++] = s, this.elements[h++] = o, s += o;
        }
    }, i.prototype.addContour = function(e, t) {
        this.mesh === null && (this.mesh = new n1), e < 2 && (e = 2), e > 3 && (e = 3);
        for(var r = null, n = 0; n < t.length; n += e)r === null ? (r = this.mesh.makeEdge(), this.mesh.splice(r, r.Sym)) : (this.mesh.splitEdge(r), r = r.Lnext), r.Org.coords[0] = t[n + 0], r.Org.coords[1] = t[n + 1], e > 2 ? r.Org.coords[2] = t[n + 2] : r.Org.coords[2] = 0, r.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(r), r.winding = 1, r.Sym.winding = -1;
    }, i.prototype.tesselate = function(e, t, r, n, s, o) {
        if (e === void 0 && (e = Zt.ODD), t === void 0 && (t = Tr.POLYGONS), o === void 0 && (o = !0), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, s && (this.normal[0] = s[0], this.normal[1] = s[1], this.normal[2] = s[2]), this.windingRule = e, n < 2 && (n = 2), n > 3 && (n = 3), !this.mesh) return !1;
        this.projectPolygon_(), $O.computeInterior(this, o);
        var a = this.mesh;
        return t === Tr.BOUNDARY_CONTOURS ? this.setWindingNumber_(a, 1, !0) : this.tessellateInterior_(a), o && a.check(), t === Tr.BOUNDARY_CONTOURS ? this.outputContours_(a, n) : this.outputPolymesh_(a, t, r, n), !0;
    }, i;
}();
function Xo(i) {
    var e = i.windingRule, t = e === void 0 ? Zt.ODD : e, r = i.elementType, n = r === void 0 ? Tr.POLYGONS : r, s = i.polySize, o = s === void 0 ? 3 : s, a = i.vertexSize, l = a === void 0 ? 2 : a, c = i.normal, h = c === void 0 ? [
        0,
        0,
        1
    ] : c, u = i.contours, f = u === void 0 ? [] : u, d = i.strict, p = d === void 0 ? !0 : d, m = i.debug, g = m === void 0 ? !1 : m;
    if (!f && p) throw new Error("Contours can't be empty");
    if (!!f) {
        var v = new eF;
        i.edgeCreateCallback && (v.edgeCreateCallback = i.edgeCreateCallback), i.vertexIdCallback && (v.vertexIdCallback = i.vertexIdCallback);
        for(var y = 0; y < f.length; y++)v.addContour(l || 2, f[y]);
        return v.tesselate(t, n, o, l, h, p), {
            vertices: v.vertices,
            vertexIndices: v.vertexIndices,
            vertexCount: v.vertexCount,
            elements: v.elements,
            elementCount: v.elementCount,
            mesh: g ? v.mesh : void 0
        };
    }
}
var B7 = Zt.ODD, N7 = Zt.NONZERO, O7 = Zt.POSITIVE, F7 = Zt.NEGATIVE, U7 = Zt.ABS_GEQ_TWO, z7 = Tr.POLYGONS, G7 = Tr.CONNECTED_POLYGONS, k7 = Tr.BOUNDARY_CONTOURS;
var Il = class extends Le {
    constructor(t, r = 12, n = {}){
        var p, m, g;
        super();
        this.type = "ShapeGeometry";
        this.windingRule = Zt.ODD;
        this.elementType = Tr.POLYGONS;
        this.polySize = 3;
        this.vertexSize = 2;
        this.strict = !0;
        this._shape = t, this._curveSegments = r, this._triangulationOptions = Object.assign({
            windingRule: Zt.ODD,
            elementType: Tr.POLYGONS,
            polySize: 3,
            vertexSize: 2,
            strict: !0
        }, n);
        let s = this._shape.extractShapePointsToFlatArray([], this._curveSegments), o = this._shape.shapeHoles.map((v)=>v.extractShapePointsToFlatArray([], this._curveSegments)
        ), a, l = !0, c = !0, h, u;
        for(let v11 = 0, y = s.length / 2; v11 < y; v11++){
            let w = v11 * 2, b = s[w + 0], S = s[w + 1];
            if (h !== void 0 && b !== h && (l = !1), u !== void 0 && S !== u && (c = !1), h = b, u = S, !l && !c) break;
        }
        !l && !c && (a = Xo({
            contours: [
                s,
                ...o
            ],
            windingRule: this._triangulationOptions.windingRule,
            elementType: this._triangulationOptions.elementType,
            polySize: this._triangulationOptions.polySize,
            vertexSize: this._triangulationOptions.vertexSize,
            strict: this._triangulationOptions.strict
        }));
        let f = (p = a == null ? void 0 : a.vertexCount) != null ? p : 1, d = (m = a == null ? void 0 : a.elementCount) != null ? m : 1;
        if (this._positionAttribute = new Ve(new Float32Array(f * 3), 3), this._normalAttribute = new Ve(new Float32Array(f * 3), 3), this._uvAttribute = new Ve(new Float32Array(f * 2), 2), this._indexAttribute = new Ve(new Uint32Array(d * 3), 1), a) {
            let v = 1 / 0, y = -1 / 0, w = 1 / 0, b = -1 / 0;
            for(let A = 0, x = f; A < x; A++){
                let E = A * 2, _ = a.vertices[E + 0], C = a.vertices[E + 1];
                _ < v && (v = _), _ > y && (y = _), C < w && (w = C), C > b && (b = C);
            }
            let S = y - v, T = b - w;
            for(let A8 = 0, x7 = f; A8 < x7; A8++){
                let E = A8 * 2, _ = a.vertices[E + 0], C = a.vertices[E + 1], I = (_ - v) / S, N = (C - w) / T;
                this._positionAttribute.setXYZ(A8, _, C, 0), this._normalAttribute.setXYZ(A8, 0, 0, 1), this._uvAttribute.setXY(A8, I, N);
            }
            for(let A9 = 0, x8 = d; A9 < x8; A9++){
                let E = A9 * 3, _ = a.elements[E + 0], C = a.elements[E + 1], I = a.elements[E + 2];
                this._indexAttribute.setX(E + 0, _), this._indexAttribute.setX(E + 1, C), this._indexAttribute.setX(E + 2, I);
            }
        }
        this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.setDrawRange(0, ((g = a == null ? void 0 : a.elementCount) != null ? g : 1) * 3);
    }
    clone() {
        let t = new Il(this._shape, this._curveSegments);
        return t.userData = Sh(this.userData), t;
    }
};
var fp = class {
    constructor(e = 256, t = !1){
        this.capacity = e, this.size = 0, this.debug = t, this.debug && console.log(`allocating with cap ${e}`);
        let r = e * fp.eSize;
        this.buffer = new ArrayBuffer(r);
        let n = Float32Array.BYTES_PER_ELEMENT, s = 0;
        this.positions = new Float32Array(this.buffer, s * n, 3 * e), s += 3 * e, this.normals = new Float32Array(this.buffer, s * n, 3 * e), s += 3 * e, this.uvs = new Float32Array(this.buffer, s * n, 2 * e);
    }
    realloc(e, t = !1) {
        if (e < this.size) throw Error("cannot shrink buffer");
        if (e <= this.capacity && !t) return;
        this.debug && console.log(`resizing from ${this.capacity} \u2192 ${e}`);
        let r = e * fp.eSize, n = new ArrayBuffer(r), s = Float32Array.BYTES_PER_ELEMENT, o = 0, a = new Float32Array(n, o * s, 3 * e);
        o += 3 * e;
        let l = new Float32Array(n, o * s, 3 * e);
        o += 3 * e;
        let c = new Float32Array(n, o * s, 2 * e);
        a.set(this.positions.slice(0, this.size * 3)), l.set(this.normals.slice(0, this.size * 3)), c.set(this.uvs.slice(0, this.size * 2)), this.buffer = n, this.positions = a, this.normals = l, this.uvs = c, this.capacity = e;
    }
    get(e = 1) {
        let t = this.size + e;
        if (t > this.capacity) {
            let n = this.capacity;
            for(; t > n;)n *= 2;
            this.realloc(n);
        }
        let r = this.size;
        return this.size = t, r;
    }
    reserve(e) {
        let t = this.size + e;
        t > this.capacity && this.realloc(t);
    }
    shrink() {
        this.debug && console.log(`shrinking ${this.capacity} \u2192 ${this.size}`), this.realloc(this.size, !0);
    }
}, Wh = fp;
Wh.eSize = 8 * Float32Array.BYTES_PER_ELEMENT;
var av = (i, e)=>([t, r])=>(r < t && (r += e), (i >= t ? i : i + e) <= r)
, Rl = class extends Le {
    constructor(t, r, n = 0, s = 12, o = 3){
        super();
        this.type = "ShapeGeometry";
        this.vertexCache = {};
        this._shape = t, this._depth = r, this._bevel = n, this._curveSegments = s, this._bevelSegmentsInput = o, n <= 0 ? (this._bevelSize = 0, this._bevelSegments = 0) : (this._bevelSize = Math.min(n, r / 2 - 1e-12), this._bevelSegments = Math.floor(o));
        let a = this._shape.extractShapePointsToFlatArray([], s), l = this._shape.shapeHoles.map((A)=>{
            let x = A.extractShapePointsToFlatArray([], s), E = [];
            for(let _ = x.length - 1; _ >= 1; _ -= 2){
                let C = x[_ - 1], I = x[_ - 0];
                E.push(C, I);
            }
            return E;
        }), c = Xo({
            windingRule: Zt.ODD,
            elementType: Tr.BOUNDARY_CONTOURS,
            vertexSize: 2,
            strict: !0,
            contours: [
                a
            ]
        }), h = Xo({
            windingRule: Zt.ODD,
            elementType: Tr.BOUNDARY_CONTOURS,
            vertexSize: 2,
            strict: !0,
            contours: [
                ...l
            ]
        });
        if (!c) throw new Error("error generating geometry");
        let u = c.elementCount;
        if (h) {
            c.elementCount += h.elementCount;
            for(let A = 0; A < h.elements.length; A++){
                let x = h.elements[A], E = A % 2 === 0 ? c.vertexCount : 0;
                c.elements.push(x + E);
            }
            for(let A12 = 0; A12 < h.vertexIndices.length; A12++){
                let x = h.vertexIndices[A12], E = c.vertexCount;
                c.vertexIndices.push(x + E);
            }
            for(let A13 = 0; A13 < h.vertices.length; A13++){
                let x = h.vertices[A13];
                c.vertices.push(x);
            }
        }
        let f = 1 / 0, d = -1 / 0, p = 1 / 0, m = -1 / 0;
        for(let A11 = 0, x9 = c.vertexCount; A11 < x9; A11++){
            let E = A11 * 2, _ = c.vertices[E + 0], C = c.vertices[E + 1];
            _ < f && (f = _), _ > d && (d = _), C < p && (p = C), C > m && (m = C);
        }
        this._minX = f, this._minY = p, this._width = d - f, this._height = m - p;
        let g = c.vertexCount * 2 * (2 + this._bevelSegments);
        this._buffer = new Wh(g);
        let v = [], y = [];
        for(let A10 = c.elementCount - 1; A10 >= 0; A10--){
            let x = A10 >= u, E = A10 * 2, _ = c.elements[E + 0], C = c.elements[E + 1], I = _ + C, N = {
                start: _,
                count: C,
                normals: [],
                continuous: [],
                concave: []
            }, R = _, k = I - 1, G = _ + 1, te = this._shape.roundedCurves.length;
            do {
                let z = R - _, O = c.vertices[k * 2 + 0], j = c.vertices[k * 2 + 1], q = c.vertices[R * 2 + 0], J = c.vertices[R * 2 + 1], W = c.vertices[G * 2 + 0], ge = c.vertices[G * 2 + 1], oe = q - O, le = J - j, H = Math.sqrt(oe * oe + le * le);
                oe /= H, le /= H;
                let he = q - W, K = J - ge, V = Math.sqrt(he * he + K * K);
                he /= V, K /= V, N.normals[z * 2 + 0] = -K, N.normals[z * 2 + 1] = he, N.concave[z] = oe * K - le * he > 0;
                let Z = c.vertexIndices[R];
                if (Array.isArray(Z)) N.continuous[z] = !1;
                else {
                    let [ce, se] = this._shape.getCurveIndexFromVertexId(Z - 1, !0);
                    if (se > 0 && se < 1) N.continuous[z] = !0;
                    else {
                        let pe = se === 1 ? ce + 1 : ce - 1;
                        pe = (pe + te) % te;
                        let ve = se === 1 ? 0 : 1, me = this._shape.roundedCurves[ce].getTangent(se), Pe = this._shape.roundedCurves[pe].getTangent(ve);
                        N.continuous[z] = me.dot(Pe) > .95;
                    }
                }
                x && (N.normals[z * 2 + 0] *= -1, N.normals[z * 2 + 1] *= -1), [k, R, G] = [
                    R,
                    G,
                    G + 1
                ], G >= I && (G -= C);
            }while (G !== _ + 1)
            let Q = [];
            Q.push({
                bevelI: 0,
                angle: 0,
                size: 0,
                boundary: {
                    vertices: c.vertices.slice(_ * 2, I * 2),
                    vertexCount: C,
                    vertexIndices: new Array(C).fill(!0).map((z, O)=>[
                            O,
                            O
                        ]
                    ),
                    elements: [
                        0,
                        C
                    ],
                    elementCount: 1,
                    mesh: null
                },
                reverseMap: [],
                insetPoints: c.vertices.slice(_ * 2, I * 2)
            });
            for(let z9 = 1; z9 <= this._bevelSegments; z9++){
                let O = z9 / this._bevelSegments * Math.PI / 2, j = (1 - Math.cos(O)) * this._bevelSize, q = [], J = [], W = [], ge = [], oe = 0;
                for(let H7 = 0; H7 < C; H7++){
                    let he = H7 * 2, K = (H7 - 1 + C) % C * 2, V = c.vertices[N.start * 2 + he + 0], Z = c.vertices[N.start * 2 + he + 1], ce = -N.normals[K + 0] * j, se = -N.normals[K + 1] * j, pe = -N.normals[he + 0] * j, ve = -N.normals[he + 1] * j;
                    if (N.concave[H7] || !N.concave[H7] && x) {
                        let me = Math.atan2(se, ce), Pe = Math.atan2(ve, pe);
                        Pe > me && (Pe -= Math.PI * 2);
                        let ke = Pe - me;
                        if (N.continuous[H7] || x) {
                            let L = me + ke / 2, D = Math.cos(L) * j, re = Math.sin(L) * j;
                            q[2 * oe + 0] = V + D * (x ? -1 : 1), q[2 * oe + 1] = Z + re * (x ? -1 : 1), ge[oe] = H7, oe++;
                        } else {
                            let L = Math.max(1, Math.floor(s / 4 * Math.abs(ke) / Math.PI));
                            for(let D = 0; D <= L; D++){
                                let re = me + ke * (D / L), ye = Math.cos(re) * j, Se = Math.sin(re) * j;
                                q[2 * oe + 0] = V + ye, q[2 * oe + 1] = Z + Se, ge[oe] = H7, oe++;
                            }
                        }
                    } else q[2 * oe + 0] = V + ce, q[2 * oe + 1] = Z + se, ge[oe] = H7, J[H7] = oe, oe++, q[2 * oe + 0] = V, q[2 * oe + 1] = Z, ge[oe] = H7, oe++, q[2 * oe + 0] = V + pe, q[2 * oe + 1] = Z + ve, ge[oe] = H7, W[H7] = oe, oe++;
                }
                let le = Xo({
                    windingRule: Zt.POSITIVE,
                    elementType: Tr.BOUNDARY_CONTOURS,
                    vertexSize: 2,
                    strict: !0,
                    contours: [
                        q
                    ],
                    edgeCreateCallback: (H)=>{
                        let K = H.Org.idx, V = ge[K], Z = ge[(K + 1) % ge.length];
                        H.idx = [
                            V,
                            Z
                        ], H.Sym.idx = [
                            Z,
                            V
                        ];
                    },
                    vertexIdCallback: (H)=>{
                        let he = H.Lprev.idx;
                        return [
                            he ? he[1] : 0,
                            H.idx[0]
                        ];
                    }
                });
                if (!le) throw console.log("Error"), new Error(`error generating bevel geometry for ${z9}'th loop`);
                if (!le.vertexCount) break;
                for(let H6 = 0; H6 < le.vertexIndices.length; H6++){
                    let [he, K] = le.vertexIndices[H6];
                    if (he === K) continue;
                    let V = K;
                    K < he && (V += C);
                    for(let Z = he; Z < V; Z++){
                        let ce = Z % C, se = (Z + 1) % C;
                        if (!N.continuous[ce] || !N.continuous[se]) {
                            le.vertexIndices[H6] = [
                                he,
                                ce
                            ], le.vertexIndices.splice(H6 + 1, 0, [
                                se,
                                K
                            ]), le.vertices.splice((H6 + 1) * 2, 0, le.vertices[H6 * 2], le.vertices[H6 * 2 + 1]);
                            break;
                        }
                    }
                }
                Q.push({
                    bevelI: z9,
                    angle: O,
                    size: j,
                    boundary: le,
                    reverseMap: ge,
                    insetPoints: q
                });
            }
            let Y = (z, O, j)=>{
                let q = 0, J = z.boundary.vertexIndices.length;
                for(; q < J && j(z.boundary.vertexIndices[O]);)O = (O + 1) % J, q++;
                return q;
            }, F = v.length;
            for(let z8 = 1; z8 < Q.length; z8++){
                let O = Q[z8 - 1], j = Q[z8], q = O.boundary.vertexIndices.length, J = j.boundary.vertexIndices.length;
                if (!q || !J) break;
                let W = N.concave.length, ge = 0, oe = av(ge, C);
                for(; !O.boundary.vertexIndices.filter(oe).length || !j.boundary.vertexIndices.filter(oe).length;)ge++, oe = av(ge, C);
                let le = O.boundary.vertexIndices.findIndex(oe), H = j.boundary.vertexIndices.findIndex(oe);
                do le = (le + 1) % q;
                while (oe(O.boundary.vertexIndices[le]))
                do H = (H + 1) % J;
                while (oe(j.boundary.vertexIndices[H]))
                ge = (ge + 1) % C;
                let he = ge, K = this.buildBevelVert(N, O, (le - 1 + q) % q), V = this.buildBevelVert(N, j, (H - 1 + J) % J), Z = K, ce = V, se, pe, ve = !1;
                do {
                    oe = av(ge, C);
                    let me = Y(O, le, oe), Pe = Y(j, H, oe), ke = ve;
                    if (ve = !1, me && !Pe) {
                        for(let L = 0; L < me; L++)se = this.buildBevelVert(N, O, (le + L) % q, L / (me - 1)), v.push(Z.topN, se.topP, ce.topN), v.push(se.bottomP, Z.bottomN, ce.bottomN), Z = se;
                        ve = !0;
                    } else if (!me && Pe) for(let L = 0; L < Pe; L++)pe = this.buildBevelVert(N, j, (H + L) % J, L / (Pe - 1)), v.push(ce.topN, Z.topP, pe.topP), v.push(Z.bottomP, ce.bottomN, pe.bottomP), ce = pe;
                    else if (me && Pe) {
                        if (se = this.buildBevelVert(N, O, le, 0), pe = this.buildBevelVert(N, j, H, 0), ke ? (v.push(Z.topN, pe.topP, ce.topN), v.push(Z.topN, se.topP, pe.topP), v.push(pe.bottomP, Z.bottomN, ce.bottomN), v.push(pe.bottomP, se.bottomP, Z.bottomN)) : (v.push(ce.topN, Z.topN, se.topP), v.push(ce.topN, se.topP, pe.topP), v.push(se.bottomP, Z.bottomN, ce.bottomN), v.push(se.bottomP, ce.bottomN, pe.bottomP)), Z = se, ce = pe, me === Pe) for(let L = 1; L < me; L++)se = this.buildBevelVert(N, O, (le + L) % q, L / (me - 1)), pe = this.buildBevelVert(N, j, (H + L) % J, L / (Pe - 1)), v.push(Z.topN, se.topP, ce.topN), v.push(ce.topN, se.topP, pe.topP), v.push(se.bottomP, Z.bottomN, ce.bottomN), v.push(se.bottomP, ce.bottomN, pe.bottomP), Z = se, ce = pe;
                        else if (me > Pe) {
                            let L = me / Pe, D = 0;
                            for(let re = 1; re < me; re++)se = this.buildBevelVert(N, O, (le + re) % q, re / (me - 1)), v.push(Z.topN, se.topP, ce.topN), v.push(se.bottomP, Z.bottomN, ce.bottomN), Z = se, re > (D + 1) * L && (D++, pe = this.buildBevelVert(N, j, (H + D) % J, D / (Pe - 1)), v.push(ce.topN, se.topP, pe.topP), v.push(se.bottomP, ce.bottomN, pe.bottomP), ce = pe);
                        } else {
                            let L = Pe / me, D = 0;
                            for(let re = 1; re < Pe; re++)pe = this.buildBevelVert(N, j, (H + re) % J, re / (Pe - 1)), v.push(ce.topN, se.topP, pe.topP), v.push(se.bottomP, ce.bottomN, pe.bottomP), ce = pe, re > (D + 1) * L && (D++, se = this.buildBevelVert(N, O, (le + D) % q, D / (me - 1)), v.push(Z.topN, se.topP, ce.topN), v.push(se.bottomP, Z.bottomN, ce.bottomN), Z = se);
                        }
                    }
                    le = (le + me) % q, H = (H + Pe) % J, ge = (ge + 1) % W;
                }while (ge !== he)
            }
            {
                let z = Q[0];
                for(let O = 0, j = z.boundary.vertexCount; O < j; O++){
                    let q = this.buildBevelVert(N, z, O), J = this.buildBevelVert(N, z, (O + 1) % j);
                    v.push(J.topP, q.topN, q.bottomN), v.push(J.topP, q.bottomN, J.bottomP);
                }
            }
            if (x) {
                let z = [];
                for(let O = v.length - 1; O >= F + 2; O -= 3){
                    let j = v[O - 2], q = v[O - 1], J = v[O - 0];
                    z.push(J, q, j);
                }
                v.splice(F, v.length - F, ...z);
            }
            if (x) {
                let z = [];
                for(let O = Q[Q.length - 1].boundary.vertices.length - 1; O >= 1; O -= 2){
                    let j = Q[Q.length - 1].boundary.vertices[O - 1], q = Q[Q.length - 1].boundary.vertices[O - 0];
                    z.push(j, q);
                }
                y.push(z);
            }
            if (!x) {
                let z = Q[Q.length - 1], O = Xo({
                    windingRule: Q.length > 1 ? Zt.POSITIVE : Zt.ODD,
                    elementType: Tr.POLYGONS,
                    vertexSize: 2,
                    strict: !0,
                    contours: [
                        z.insetPoints,
                        ...y
                    ]
                });
                if (!O) throw new Error("Error generating geometry for surface");
                Object.assign(this, {
                    capStartIndex: v.length
                });
                for(let j = 0; j < O.elementCount * 3; j += 3){
                    let q = this.buildSurfaceVert(O, O.elements[j + 0]), J = this.buildSurfaceVert(O, O.elements[j + 1]), W = this.buildSurfaceVert(O, O.elements[j + 2]);
                    v.push(q.top, J.top, W.top), v.push(W.bottom, J.bottom, q.bottom);
                }
            }
            this.vertexCache = {};
        }
        this._buffer.shrink();
        let w = new Ve(Uint32Array.from(v), 1), b = new Ve(this._buffer.positions, 3), S = new Ve(this._buffer.normals, 3), T = new Ve(this._buffer.uvs, 2);
        b.needsUpdate = !0, S.needsUpdate = !0, T.needsUpdate = !0, w.needsUpdate = !0, this.setAttribute("position", b), this.setAttribute("normal", S), this.setAttribute("uv", T), this.setIndex(w);
    }
    buildSurfaceVert(t, r) {
        let n = r.toString();
        if (n in this.vertexCache) return this.vertexCache[n];
        let s = t.vertices[r * 2 + 0], o = t.vertices[r * 2 + 1], a = (s - this._minX) / this._width, l = (o - this._minY) / this._height, c = this._buffer.get(2), h = c * 3, u = c * 2, f = {
            top: c + 0,
            bottom: c + 1
        };
        return this._buffer.positions[h + 0] = s, this._buffer.positions[h + 1] = o, this._buffer.positions[h + 2] = this._depth, this._buffer.normals[h + 0] = 0, this._buffer.normals[h + 1] = 0, this._buffer.normals[h + 2] = 1, this._buffer.uvs[u + 0] = a, this._buffer.uvs[u + 1] = l, this._buffer.positions[h + 3] = s, this._buffer.positions[h + 4] = o, this._buffer.positions[h + 5] = 0, this._buffer.normals[h + 3] = 0, this._buffer.normals[h + 4] = 0, this._buffer.normals[h + 5] = -1, this._buffer.uvs[u + 2] = a, this._buffer.uvs[u + 3] = l, this.vertexCache[n] = f, f;
    }
    buildBevelVert(t, r, n, s = 1) {
        let o = `${r.bevelI}:${n}`;
        if (o in this.vertexCache) return this.vertexCache[o];
        let [a, l] = r.boundary.vertexIndices[n], c, h, u, f;
        a !== l ? (h = a, c = l, f = !1, u = t.continuous[h] && t.continuous[c]) : (c = a, h = (c - 1 + t.count) % t.count, f = t.concave[c] && r.bevelI > 0, u = t.continuous[c] || f);
        let d = Math.cos(r.angle), p = Math.sin(r.angle), m = n * 2, g = c * 2, v = h * 2, y = r.boundary.vertices[m + 0], w = r.boundary.vertices[m + 1], b = (1 - p) * this._bevelSize, S = (y - this._minX) / this._width, T = (w - this._minY) / this._height, A = t.normals[g + 0], x = t.normals[g + 1], E = t.normals[v + 0], _ = t.normals[v + 1];
        if (f) {
            let k = E - A, G = _ - x;
            A = A + k * (1 - s), x = x + G * (1 - s);
            let te = Math.sqrt(A * A + x * x);
            A /= te, x /= te;
        }
        let C = this._buffer.get(u ? 2 : 4), I = C * 3, N = C * 2, R = {
            i: n,
            fi: c,
            topP: C + 0,
            topN: C + 0,
            bottomP: C + 1,
            bottomN: C + 1
        };
        return this._buffer.positions[I + 0] = y, this._buffer.positions[I + 1] = w, this._buffer.positions[I + 2] = this._depth - b, this._buffer.normals[I + 0] = A * d, this._buffer.normals[I + 1] = x * d, this._buffer.normals[I + 2] = p, this._buffer.uvs[N + 0] = S, this._buffer.uvs[N + 1] = T, this._buffer.positions[I + 3] = y, this._buffer.positions[I + 4] = w, this._buffer.positions[I + 5] = b, this._buffer.normals[I + 3] = A * d, this._buffer.normals[I + 4] = x * d, this._buffer.normals[I + 5] = -p, this._buffer.uvs[N + 2] = T, this._buffer.uvs[N + 3] = S, u || (C += 2, I += 6, N += 4, R.topP = C + 0, R.bottomP = C + 1, this._buffer.positions[I + 0] = y, this._buffer.positions[I + 1] = w, this._buffer.positions[I + 2] = this._depth - b, this._buffer.normals[I + 0] = E * d, this._buffer.normals[I + 1] = _ * d, this._buffer.normals[I + 2] = p, this._buffer.uvs[N + 0] = S, this._buffer.uvs[N + 1] = T, this._buffer.positions[I + 3] = y, this._buffer.positions[I + 4] = w, this._buffer.positions[I + 5] = b, this._buffer.normals[I + 3] = E * d, this._buffer.normals[I + 4] = _ * d, this._buffer.normals[I + 5] = -p, this._buffer.uvs[N + 2] = T, this._buffer.uvs[N + 3] = S), this.vertexCache[o] = R, R;
    }
    clone() {
        let t = new Rl(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
        return t.userData = Sh(this.userData), t;
    }
};
var Hr = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var c, h, u, f, d, p, m;
        let t = Object.assign({}, (c = e == null ? void 0 : e.parameters) != null ? c : {
            width: 100,
            subdivisions: 40,
            roundness: 0,
            extrudeDepth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 3
        }, i.parameters), r = Math.abs(t.width), n = Math.abs((h = t.height) != null ? h : t.width), s = Math.abs(t.depth !== void 0 && t.depth === 0 && t.extrudeDepth > 0 ? t.extrudeDepth : (u = t.depth) != null ? u : 0), o = (f = i.shape) != null ? f : e == null ? void 0 : e.shape, a = (d = o == null ? void 0 : o.roundness) != null ? d : t.roundness;
        o !== void 0 && (o instanceof Tt ? (o.width !== r || o.height !== n) && o.applySize(r, n) : o = new Tt(r, n).fromJSON(o), ((p = i.parameters) == null ? void 0 : p.roundness) !== void 0 && ((m = i.parameters) == null ? void 0 : m.roundness) > 0 && o.update(!1));
        let l = o != null ? o : new Tt(r, n);
        return {
            parameters: Object.assign(t, {
                width: r,
                height: n,
                depth: s,
                extrudeDepth: s,
                roundness: a
            }),
            shape: l
        };
    }
    static build(i) {
        let { extrudeDepth: e , extrudeBevelSize: t , extrudeBevelSegments: r , subdivisions: n , roundness: s  } = i.parameters;
        i.shape.roundness = s;
        let o;
        return e <= 0 ? o = new Il(i.shape, n) : o = new Rl(i.shape, e, t, n, r), Object.assign(o, {
            userData: xe(ie({}, i), {
                type: "VectorGeometry"
            })
        });
    }
};
var l1 = Math.PI * 2, c1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var n, s, o;
        let t = Object.assign({}, (n = e == null ? void 0 : e.parameters) != null ? n : {
            width: 100,
            depth: 0,
            spikes: 64,
            angle: 360,
            innerRadius: 0,
            extrudeDepth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1
        }, i.parameters);
        return {
            shape: i.shape && i.shape instanceof Tt ? i.shape : new Tt,
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((s = t.height) != null ? s : t.width),
                depth: Math.abs(t.depth !== void 0 && t.depth === 0 && t.extrudeDepth > 0 ? t.extrudeDepth : (o = t.depth) != null ? o : 0)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , spikes: r , angle: n , innerRadius: s , depth: o , extrudeBevelSize: a , extrudeBevelSegments: l  } = i.parameters, c = i.shape, h = e * .5, u = t * .5, f = tF(c, h, u, n * Math.PI / 180, r, s);
        c.isClosed = !0, c.update();
        let d = Hr.create({
            shape: c,
            parameters: {
                subdivisions: f,
                depth: o,
                extrudeBevelSize: a,
                extrudeBevelSegments: l
            }
        });
        return Object.assign(d, {
            userData: xe(ie({}, i), {
                type: "EllipseGeometry"
            })
        });
    }
};
function tF(i, e, t, r, n, s) {
    if (r >= l1) return n > 30 || n % 4 === 0 ? (nF(i, e, t, s), Math.round(n / 4)) : a1(i, r, n, e, t, s);
    let o = {
        x: 0,
        y: t
    }, a = r + Math.PI * .5, l = {
        x: Math.cos(a) * e,
        y: Math.sin(a) * t
    }, c = r1({
        px: o.x,
        py: o.y,
        cx: l.x,
        cy: l.y,
        rx: e,
        ry: t,
        largeArcFlag: r > Math.PI,
        sweepFlag: !0
    });
    return n > 30 || n % c.length === 0 ? rF(i, o.x, o.y, c, n, e, t, s) : a1(i, r, n, e, t, s);
}
function rF(i, e, t, r, n, s, o, a) {
    let l = Math.round(n / r.length);
    i.addPoint(Bl(e, t));
    for(let c = 0, h = r.length; c < h; c++){
        let u = r[c], f = i.points[c], d = Bl(u.x, u.y);
        f.controls[1].position.set(u.x1, u.y1), d.controls[0].position.set(u.x2, u.y2), i.addPoint(d);
    }
    return a > 0 ? h1(i, s, o, a) : i.addPoint(Bl(0, 0)), l;
}
function a1(i, e, t, r, n, s) {
    let o = -e / t;
    for(let a = 0; a <= t; a++){
        let l = o * a, c = Math.sin(l) * r, h = Math.cos(l) * n;
        i.addPoint(Bl(c, h));
    }
    return e < l1 ? s > 0 ? h1(i, r, n, s) : i.addPoint(Bl(0, 0)) : (i.removePoint(i.points[i.points.length - 1]), s > 0 && u1(i, r, n, s)), 1;
}
function nF(i, e, t, r = 0, n = 0, s = 0) {
    let o = .5522847498, a = e * o, l = t * o;
    i.addPoint(dp(n - e, s, n - e, s - l, n - e, s + l)), i.addPoint(dp(n, s + t, n - a, s + t, n + a, s + t)), i.addPoint(dp(n + e, s, n + e, s + l, n + e, s - l)), i.addPoint(dp(n, s - t, n + a, s - t, n - a, s - t)), r > 0 && u1(i, e, t, r);
}
function Bl(i, e) {
    return new ui(et.generateUUID(), new B(i, e));
}
function dp(i, e, t, r, n, s) {
    let o = Bl(i, e);
    return o.controls[0].position.set(t, r), o.controls[1].position.set(n, s), o;
}
function h1(i, e, t, r) {
    f1(i, e, t, r).forEach((s)=>i.addPoint(s)
    );
}
function u1(i, e, t, r) {
    let n = f1(i, e, t, r), s = new Tt;
    n.forEach((o)=>s.addPoint(o)
    ), s.isClosed = !0, i.shapeHoles.push(s);
}
function f1(i, e, t, r) {
    let n = r * e / 100, s = n * (Math.abs(t) / Math.abs(e)), o = new B(n / e, s / t), a = i.points.map((l)=>{
        let c = l.clone();
        return c.uuid = et.generateUUID(), c;
    }).reverse();
    return a.forEach((l)=>{
        l.position.multiply(o);
        let c = l.controls[0].position.clone().multiply(o), h = l.controls[1].position.clone().multiply(o);
        l.controls[0].position.copy(h), l.controls[1].position.copy(c);
    }), a;
}
var d1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var a, l, c;
        let t = Object.assign({}, (a = e == null ? void 0 : e.parameters) != null ? a : {
            width: 100,
            revolutions: 2,
            segments: 40,
            pathRadius: 10,
            pathType: 0,
            pathSegments: 30,
            cornerRadius: 30,
            cornerSegments: 4
        }, i.parameters), r = Math.abs(t.width), n = Math.abs((l = t.height) != null ? l : r), s = Math.abs((c = t.depth) != null ? c : r), o = Math.abs(Math.min(r, s)) / 2;
        return {
            parameters: Object.assign(t, {
                width: r,
                height: n,
                depth: s,
                radius: o,
                segments: Math.round(t.segments),
                pathSegments: Math.round(t.pathSegments),
                cornerSegments: Math.round(t.cornerSegments)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , depth: r , radius: n , revolutions: s , segments: o , pathRadius: a , pathType: l , pathSegments: c , cornerRadius: h , cornerSegments: u  } = i.parameters, f = new jh(!1, e, t, r, n, s, o, a, l, c, h, u);
        return Object.assign(f, {
            userData: xe(ie({}, i), {
                type: "HelixGeometry"
            })
        });
    }
}, jh = class extends Le {
    constructor(e = !0, t = 1, r = 1, n = 1, s = 1, o = 1, a = 1, l = 1, c = 1, h = 1, u = 1, f = 1){
        super();
        let d = e && o === 1;
        d && (f = 0), u > 100 && (u = 100);
        let p = ()=>new M
        , m = new M, g = p(), v = p(), y = p(), w, b, S, T, A, x, E, _, C = p(), I = p(), N = p(), R = p(), k = p(), G = p(), te = p(), Q = p(), Y = r - 2 * l + .001, F = Y / o, z = Math.ceil(a * o), O = z + 1, j = Y / z, q = -Y / 2, J = h + 1, W = 2 * Math.PI / h, ge = Math.PI / 2 / f, oe = .01, le = Math.min((1 - u / 100) * l, l - oe), H = l - le, he = 0, K = 2, V = f * K + K, Z = J * V / K, ce = Z + J * O, se = J * (O + V), [pe, ve, me] = [
            3,
            3,
            2
        ].map((Ee)=>Array(se * Ee).fill(0)
        ), Pe = [], ke = s - l;
        function L(Ee, U) {
            let Me = Math.PI / 2;
            x = U * j, _ = 2 * Math.PI * (x % F) / F + Me, x += q, E = Math.sin(_) * ke, A = Math.cos(_) * ke, e ? Ee.set(A, E, x) : Ee.set(A, x, E);
        }
        L(m, -0.0000000001), L(g, 0), C.copy(m), L(m, 1);
        let D = m.distanceTo(g), re = H + le, ye = D * z + 2 * re, Se = le, Ie = ye - re;
        for(let Ee2 = 0; Ee2 <= z; Ee2++){
            L(v, Ee2), Q.subVectors(v, C).normalize(), C.copy(v), G.copy(v).setComponent(+e + 1, 0).normalize(), te.crossVectors(Q, G).normalize();
            let U = Ee2 === 0, Me = Ee2 === z, De = U ? 3 * Math.PI / 2 : ge, Ze = U ? Se : Ie, Oe = U ? J : ce, Qe = U ? 0 : se - J, Te = Q.clone().multiplyScalar(U ? -H : H).add(v), $e = Q.clone().multiplyScalar(U ? -1 : 1).normalize();
            for(let lt = 0; lt < J; lt++){
                let dt = lt * W;
                if (I.addVectors(m.copy(G).multiplyScalar(l * Math.cos(dt)), g.copy(te).multiplyScalar(l * Math.sin(dt))), N.copy(I).normalize(), U || Me) {
                    d || (he = Qe + lt, [
                        0,
                        1,
                        2
                    ].forEach((Ut)=>{
                        pe[he * 3 + Ut] = Te.getComponent(Ut), ve[he * 3 + Ut] = $e.getComponent(Ut);
                    }), me[he * 2] = +Me, me[he * 2 + 1] = lt / h), g.copy(N).multiplyScalar(le), y.addVectors(v, g);
                    for(let Ut1 = 0; Ut1 < f; Ut1++){
                        let Ur = Ut1 * ge + De;
                        R.addVectors(m.copy(Q).multiplyScalar(H * Math.sin(Ur)), g.copy(N).multiplyScalar(H * Math.cos(Ur))), k.copy(R).normalize(), g.addVectors(y, R), R.normalize(), he = Oe + Ut1 * J + lt, [
                            0,
                            1,
                            2
                        ].forEach((Nn)=>{
                            pe[he * 3 + Nn] = g.getComponent(Nn), ve[he * 3 + Nn] = k.getComponent(Nn);
                        });
                        let ia = +U + Math.sin(Ur);
                        me[he * 2] = (Ze + H * ia) / ye, me[he * 2 + 1] = lt / h;
                    }
                }
                g.addVectors(v, I), he = Z + Ee2 * J + lt, [
                    0,
                    1,
                    2
                ].forEach((Ut)=>{
                    pe[he * 3 + Ut] = g.getComponent(Ut), ve[he * 3 + Ut] = N.getComponent(Ut);
                }), me[he * 2] = (re + Ee2 * D) / ye, me[he * 2 + 1] = lt / h;
            }
        }
        let Fe = O + 2 * f + K, ue = 1, [rt, st] = d ? [
            ue,
            ue + O - 1
        ] : [
            0,
            Fe - 1
        ];
        for(let Ee1 = rt; Ee1 <= st - 1; Ee1++){
            let U = d && Ee1 === st - 1;
            for(let Me = 0; Me < J - 1; Me++)w = Ee1 * J + Me, b = w + 1, S = (U ? Me : w) + J, T = (U ? Me + 1 : b) + J, Ee1 === 0 ? Pe.push(b, T, S) : Ee1 === Fe - 2 ? Pe.push(w, b, S) : Pe.push(w, b, S, b, T, S);
        }
        this.setIndex(Pe), this.setAttribute("position", new Ce(pe, 3)), this.setAttribute("normal", new Ce(ve, 3)), this.setAttribute("uv", new Ce(me, 2));
    }
};
var p1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            detail: 0,
            corner: 0,
            cornerSides: 4
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , depth: r , detail: n , corner: s , cornerSides: o  } = i.parameters, a = n === 0 && s !== 0 ? new qh(e * .5, s, o) : new Va(e * .5, n);
        return a.scale(1, t / e, r / e), Object.assign(a, {
            userData: xe(ie({}, i), {
                type: "IcosahedronGeometry"
            })
        });
    }
}, qh = class extends oo {
    constructor(e = 1, t = .2, r = 4){
        let n = (1 + Math.sqrt(5)) / 2, s = [
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            0,
            0,
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            n,
            0,
            -1,
            n,
            0,
            1,
            -n,
            0,
            -1,
            -n,
            0,
            1
        ], o = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
        ], a = "IcosahedronGeometry";
        super(s, o, a, e, t, r), this.type = a;
    }
    static fromJSON(e) {
        return new qh(e.radius, e.corner, e.cornerSides);
    }
};
var m1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s, o, a;
        ((n = (r = i.parameters) == null ? void 0 : r.points) != null ? n : []).forEach((l)=>{
            Array.isArray(l) && (l.x = l[0], l.y = l[1]);
        });
        let t = Object.assign({}, (s = e == null ? void 0 : e.parameters) != null ? s : {
            width: 100,
            segments: 64,
            verticalSegments: 64,
            points: [
                {
                    x: 0,
                    y: -50,
                    id: 0
                },
                {
                    x: 50,
                    y: -50,
                    id: 1
                },
                {
                    x: 50,
                    y: 50,
                    id: 2
                },
                {
                    x: 0,
                    y: 50,
                    id: 3
                }
            ]
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((o = t.height) != null ? o : t.width),
                depth: Math.abs((a = t.depth) != null ? a : t.width)
            })
        };
    }
    static build(i) {
        let { points: e , segments: t , verticalSegments: r  } = i.parameters, n = new rn;
        n.moveTo(e[0].x, e[0].y), n.bezierCurveTo(e[1].x, e[1].y, e[2].x, e[2].y, e[3].x, e[3].y);
        let s = new Ua(n.extractPoints(r).shape, t);
        return s.rotateZ(Math.PI), Object.assign(s, {
            userData: xe(ie({}, i), {
                type: "LatheGeometry"
            })
        });
    }
};
var Oi = new Ae, lv = new ot, pp = new M, lo = class extends Yt {
    constructor(){
        super(), this.uuid = et.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
    }
    applyMatrix4(e) {
        let t = new Ft().getNormalMatrix(e);
        for(let r = 0, n = this.vertices.length; r < n; r++)this.vertices[r].applyMatrix4(e);
        for(let r8 = 0, n9 = this.faces.length; r8 < n9; r8++){
            let s = this.faces[r8];
            s.normal.applyMatrix3(t).normalize();
            for(let o = 0, a = s.vertexNormals.length; o < a; o++)s.vertexNormals[o].applyMatrix3(t).normalize();
        }
        return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
    }
    rotateX(e) {
        return Oi.makeRotationX(e), this.applyMatrix4(Oi), this;
    }
    rotateY(e) {
        return Oi.makeRotationY(e), this.applyMatrix4(Oi), this;
    }
    rotateZ(e) {
        return Oi.makeRotationZ(e), this.applyMatrix4(Oi), this;
    }
    translate(e, t, r) {
        return Oi.makeTranslation(e, t, r), this.applyMatrix4(Oi), this;
    }
    scale(e, t, r) {
        return Oi.makeScale(e, t, r), this.applyMatrix4(Oi), this;
    }
    lookAt(e) {
        return lv.lookAt(e), lv.updateMatrix(), this.applyMatrix4(lv.matrix), this;
    }
    fromBufferGeometry(e) {
        let t = this, r = e.index !== null ? e.index : void 0, n = e.attributes;
        if (n.position === void 0) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
        let s = n.position, o = n.normal, a = n.color, l = n.uv, c = n.uv2;
        c !== void 0 && (this.faceVertexUvs[1] = []);
        for(let f9 = 0; f9 < s.count; f9++)t.vertices.push(new M().fromBufferAttribute(s, f9)), a !== void 0 && t.colors.push(new be().fromBufferAttribute(a, f9));
        function h(f, d, p, m) {
            let g = a === void 0 ? [] : [
                t.colors[f].clone(),
                t.colors[d].clone(),
                t.colors[p].clone()
            ], v = o === void 0 ? [] : [
                new M().fromBufferAttribute(o, f),
                new M().fromBufferAttribute(o, d),
                new M().fromBufferAttribute(o, p)
            ], y = new Nl(f, d, p, v, g, m);
            t.faces.push(y), l !== void 0 && t.faceVertexUvs[0].push([
                new B().fromBufferAttribute(l, f),
                new B().fromBufferAttribute(l, d),
                new B().fromBufferAttribute(l, p)
            ]), c !== void 0 && t.faceVertexUvs[1].push([
                new B().fromBufferAttribute(c, f),
                new B().fromBufferAttribute(c, d),
                new B().fromBufferAttribute(c, p)
            ]);
        }
        let u = e.groups;
        if (u.length > 0) for(let f6 = 0; f6 < u.length; f6++){
            let d = u[f6], p = d.start, m = d.count;
            for(let g = p, v = p + m; g < v; g += 3)r !== void 0 ? h(r.getX(g), r.getX(g + 1), r.getX(g + 2), d.materialIndex) : h(g, g + 1, g + 2, d.materialIndex);
        }
        else if (r !== void 0) for(let f7 = 0; f7 < r.count; f7 += 3)h(r.getX(f7), r.getX(f7 + 1), r.getX(f7 + 2));
        else for(let f8 = 0; f8 < s.count; f8 += 3)h(f8, f8 + 1, f8 + 2);
        return this.computeFaceNormals(), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(pp).negate(), this.translate(pp.x, pp.y, pp.z), this;
    }
    normalize() {
        this.computeBoundingSphere();
        let e = this.boundingSphere.center, t = this.boundingSphere.radius, r = t === 0 ? 1 : 1 / t, n = new Ae;
        return n.set(r, 0, 0, -r * e.x, 0, r, 0, -r * e.y, 0, 0, r, -r * e.z, 0, 0, 0, 1), this.applyMatrix4(n), this;
    }
    computeFaceNormals() {
        let e = new M, t = new M;
        for(let r = 0, n = this.faces.length; r < n; r++){
            let s = this.faces[r], o = this.vertices[s.a], a = this.vertices[s.b], l = this.vertices[s.c];
            e.subVectors(l, a), t.subVectors(o, a), e.cross(t), e.normalize(), s.normal.copy(e);
        }
    }
    computeVertexNormals(e = !0) {
        let t = new Array(this.vertices.length);
        for(let r = 0, n = this.vertices.length; r < n; r++)t[r] = new M;
        if (e) {
            let r = new M, n = new M;
            for(let s = 0, o = this.faces.length; s < o; s++){
                let a = this.faces[s], l = this.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c];
                r.subVectors(h, c), n.subVectors(l, c), r.cross(n), t[a.a].add(r), t[a.b].add(r), t[a.c].add(r);
            }
        } else {
            this.computeFaceNormals();
            for(let r = 0, n = this.faces.length; r < n; r++){
                let s = this.faces[r];
                t[s.a].add(s.normal), t[s.b].add(s.normal), t[s.c].add(s.normal);
            }
        }
        for(let r9 = 0, n10 = this.vertices.length; r9 < n10; r9++)t[r9].normalize();
        for(let r10 = 0, n11 = this.faces.length; r10 < n11; r10++){
            let s = this.faces[r10], o = s.vertexNormals;
            o.length === 3 ? (o[0].copy(t[s.a]), o[1].copy(t[s.b]), o[2].copy(t[s.c])) : (o[0] = t[s.a].clone(), o[1] = t[s.b].clone(), o[2] = t[s.c].clone());
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }
    computeFlatVertexNormals() {
        this.computeFaceNormals();
        for(let e = 0, t = this.faces.length; e < t; e++){
            let r = this.faces[e], n = r.vertexNormals;
            n.length === 3 ? (n[0].copy(r.normal), n[1].copy(r.normal), n[2].copy(r.normal)) : (n[0] = r.normal.clone(), n[1] = r.normal.clone(), n[2] = r.normal.clone());
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }
    computeMorphNormals() {
        for(let t = 0, r = this.faces.length; t < r; t++){
            let n = this.faces[t];
            n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
            for(let s = 0, o = n.vertexNormals.length; s < o; s++)n.__originalVertexNormals[s] ? n.__originalVertexNormals[s].copy(n.vertexNormals[s]) : n.__originalVertexNormals[s] = n.vertexNormals[s].clone();
        }
        let e = new lo;
        e.faces = this.faces;
        for(let t8 = 0, r11 = this.morphTargets.length; t8 < r11; t8++){
            if (!this.morphNormals[t8]) {
                this.morphNormals[t8] = {}, this.morphNormals[t8].faceNormals = [], this.morphNormals[t8].vertexNormals = [];
                let s = this.morphNormals[t8].faceNormals, o = this.morphNormals[t8].vertexNormals;
                for(let a = 0, l = this.faces.length; a < l; a++){
                    let c = new M, h = {
                        a: new M,
                        b: new M,
                        c: new M
                    };
                    s.push(c), o.push(h);
                }
            }
            let n = this.morphNormals[t8];
            e.vertices = this.morphTargets[t8].vertices, e.computeFaceNormals(), e.computeVertexNormals();
            for(let s = 0, o = this.faces.length; s < o; s++){
                let a = this.faces[s], l = n.faceNormals[s], c = n.vertexNormals[s];
                l.copy(a.normal), c.a.copy(a.vertexNormals[0]), c.b.copy(a.vertexNormals[1]), c.c.copy(a.vertexNormals[2]);
            }
        }
        for(let t9 = 0, r12 = this.faces.length; t9 < r12; t9++){
            let n = this.faces[t9];
            n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals;
        }
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Kt), this.boundingBox.setFromPoints(this.vertices);
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Lr), this.boundingSphere.setFromPoints(this.vertices);
    }
    merge(e, t, r = 0) {
        if (!(e && e.isGeometry)) {
            console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
            return;
        }
        let n, s = this.vertices.length, o = this.vertices, a = e.vertices, l = this.faces, c = e.faces, h = this.colors, u = e.colors;
        t !== void 0 && (n = new Ft().getNormalMatrix(t));
        for(let f = 0, d = a.length; f < d; f++){
            let m = a[f].clone();
            t !== void 0 && m.applyMatrix4(t), o.push(m);
        }
        for(let f10 = 0, d11 = u.length; f10 < d11; f10++)h.push(u[f10].clone());
        for(let f11 = 0, d12 = c.length; f11 < d12; f11++){
            let p = c[f11], m, g, v = p.vertexNormals, y = p.vertexColors, w = new Nl(p.a + s, p.b + s, p.c + s);
            w.normal.copy(p.normal), n !== void 0 && w.normal.applyMatrix3(n).normalize();
            for(let b = 0, S = v.length; b < S; b++)m = v[b].clone(), n !== void 0 && m.applyMatrix3(n).normalize(), w.vertexNormals.push(m);
            w.color.copy(p.color);
            for(let b8 = 0, S5 = y.length; b8 < S5; b8++)g = y[b8], w.vertexColors.push(g.clone());
            w.materialIndex = p.materialIndex + r, l.push(w);
        }
        for(let f12 = 0, d13 = e.faceVertexUvs.length; f12 < d13; f12++){
            let p = e.faceVertexUvs[f12];
            this.faceVertexUvs[f12] === void 0 && (this.faceVertexUvs[f12] = []);
            for(let m = 0, g = p.length; m < g; m++){
                let v = p[m], y = [];
                for(let w = 0, b = v.length; w < b; w++)y.push(v[w].clone());
                this.faceVertexUvs[f12].push(y);
            }
        }
    }
    mergeMesh(e) {
        if (!(e && e.isMesh)) {
            console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
            return;
        }
        e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix);
    }
    mergeVertices(e = 4) {
        let t = {}, r = [], n = [], s = Math.pow(10, e);
        for(let l = 0, c = this.vertices.length; l < c; l++){
            let h = this.vertices[l], u = Math.round(h.x * s) + "_" + Math.round(h.y * s) + "_" + Math.round(h.z * s);
            t[u] === void 0 ? (t[u] = l, r.push(this.vertices[l]), n[l] = r.length - 1) : n[l] = n[t[u]];
        }
        let o = [];
        for(let l11 = 0, c10 = this.faces.length; l11 < c10; l11++){
            let h = this.faces[l11];
            h.a = n[h.a], h.b = n[h.b], h.c = n[h.c];
            let u = [
                h.a,
                h.b,
                h.c
            ];
            for(let f = 0; f < 3; f++)if (u[f] === u[(f + 1) % 3]) {
                o.push(l11);
                break;
            }
        }
        for(let l12 = o.length - 1; l12 >= 0; l12--){
            let c = o[l12];
            this.faces.splice(c, 1);
            for(let h = 0, u = this.faceVertexUvs.length; h < u; h++)this.faceVertexUvs[h].splice(c, 1);
        }
        let a = this.vertices.length - r.length;
        return this.vertices = r, a;
    }
    setFromPoints(e) {
        this.vertices = [];
        for(let t = 0, r = e.length; t < r; t++){
            let n = e[t];
            this.vertices.push(new M(n.x, n.y, n.z || 0));
        }
        return this;
    }
    sortFacesByMaterialIndex() {
        let e = this.faces, t = e.length;
        for(let l14 = 0; l14 < t; l14++)e[l14]._id = l14;
        function r(l, c) {
            return l.materialIndex - c.materialIndex;
        }
        e.sort(r);
        let n = this.faceVertexUvs[0], s = this.faceVertexUvs[1], o, a;
        n && n.length === t && (o = []), s && s.length === t && (a = []);
        for(let l13 = 0; l13 < t; l13++){
            let c = e[l13]._id;
            o && o.push(n[c]), a && a.push(s[c]);
        }
        o && (this.faceVertexUvs[0] = o), a && (this.faceVertexUvs[1] = a);
    }
    toJSON() {
        let e = {
            metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), this.parameters !== void 0) {
            let p = this.parameters;
            for(let m in p)p[m] !== void 0 && (e[m] = p[m]);
            return e;
        }
        let t = [];
        for(let p7 = 0; p7 < this.vertices.length; p7++){
            let m = this.vertices[p7];
            t.push(m.x, m.y, m.z);
        }
        let r = [], n = [], s = {}, o = [], a = {}, l = [], c = {};
        for(let p6 = 0; p6 < this.faces.length; p6++){
            let m = this.faces[p6], g = !0, v = !1, y = this.faceVertexUvs[0][p6] !== void 0, w = m.normal.length() > 0, b = m.vertexNormals.length > 0, S = m.color.r !== 1 || m.color.g !== 1 || m.color.b !== 1, T = m.vertexColors.length > 0, A = 0;
            if (A = h(A, 0, 0), A = h(A, 1, g), A = h(A, 2, v), A = h(A, 3, y), A = h(A, 4, w), A = h(A, 5, b), A = h(A, 6, S), A = h(A, 7, T), r.push(A), r.push(m.a, m.b, m.c), r.push(m.materialIndex), y) {
                let x = this.faceVertexUvs[0][p6];
                r.push(d(x[0]), d(x[1]), d(x[2]));
            }
            if (w && r.push(u(m.normal)), b) {
                let x = m.vertexNormals;
                r.push(u(x[0]), u(x[1]), u(x[2]));
            }
            if (S && r.push(f(m.color)), T) {
                let x = m.vertexColors;
                r.push(f(x[0]), f(x[1]), f(x[2]));
            }
        }
        function h(p, m, g) {
            return g ? p | 1 << m : p & ~(1 << m);
        }
        function u(p) {
            let m = p.x.toString() + p.y.toString() + p.z.toString();
            return s[m] !== void 0 || (s[m] = n.length / 3, n.push(p.x, p.y, p.z)), s[m];
        }
        function f(p) {
            let m = p.r.toString() + p.g.toString() + p.b.toString();
            return a[m] !== void 0 || (a[m] = o.length, o.push(p.getHex())), a[m];
        }
        function d(p) {
            let m = p.x.toString() + p.y.toString();
            return c[m] !== void 0 || (c[m] = l.length / 2, l.push(p.x, p.y)), c[m];
        }
        return e.data = {}, e.data.vertices = t, e.data.normals = n, o.length > 0 && (e.data.colors = o), l.length > 0 && (e.data.uvs = [
            l
        ]), e.data.faces = r, e;
    }
    clone() {
        return new lo().copy(this);
    }
    copy(e) {
        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
        let t = e.vertices;
        for(let f = 0, d = t.length; f < d; f++)this.vertices.push(t[f].clone());
        let r = e.colors;
        for(let f13 = 0, d14 = r.length; f13 < d14; f13++)this.colors.push(r[f13].clone());
        let n = e.faces;
        for(let f14 = 0, d15 = n.length; f14 < d15; f14++)this.faces.push(n[f14].clone());
        for(let f15 = 0, d16 = e.faceVertexUvs.length; f15 < d16; f15++){
            let p = e.faceVertexUvs[f15];
            this.faceVertexUvs[f15] === void 0 && (this.faceVertexUvs[f15] = []);
            for(let m = 0, g = p.length; m < g; m++){
                let v = p[m], y = [];
                for(let w = 0, b = v.length; w < b; w++){
                    let S = v[w];
                    y.push(S.clone());
                }
                this.faceVertexUvs[f15].push(y);
            }
        }
        let s = e.morphTargets;
        for(let f16 = 0, d17 = s.length; f16 < d17; f16++){
            let p = {};
            if (p.name = s[f16].name, s[f16].vertices !== void 0) {
                p.vertices = [];
                for(let m = 0, g = s[f16].vertices.length; m < g; m++)p.vertices.push(s[f16].vertices[m].clone());
            }
            if (s[f16].normals !== void 0) {
                p.normals = [];
                for(let m = 0, g = s[f16].normals.length; m < g; m++)p.normals.push(s[f16].normals[m].clone());
            }
            this.morphTargets.push(p);
        }
        let o = e.morphNormals;
        for(let f17 = 0, d18 = o.length; f17 < d18; f17++){
            let p = {};
            if (o[f17].vertexNormals !== void 0) {
                p.vertexNormals = [];
                for(let m = 0, g = o[f17].vertexNormals.length; m < g; m++){
                    let v = o[f17].vertexNormals[m], y = {};
                    y.a = v.a.clone(), y.b = v.b.clone(), y.c = v.c.clone(), p.vertexNormals.push(y);
                }
            }
            if (o[f17].faceNormals !== void 0) {
                p.faceNormals = [];
                for(let m = 0, g = o[f17].faceNormals.length; m < g; m++)p.faceNormals.push(o[f17].faceNormals[m].clone());
            }
            this.morphNormals.push(p);
        }
        let a = e.skinWeights;
        for(let f18 = 0, d19 = a.length; f18 < d19; f18++)this.skinWeights.push(a[f18].clone());
        let l = e.skinIndices;
        for(let f19 = 0, d20 = l.length; f19 < d20; f19++)this.skinIndices.push(l[f19].clone());
        let c = e.lineDistances;
        for(let f20 = 0, d21 = c.length; f20 < d21; f20++)this.lineDistances.push(c[f20]);
        let h = e.boundingBox;
        h !== null && (this.boundingBox = h.clone());
        let u = e.boundingSphere;
        return u !== null && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this;
    }
    toBufferGeometry() {
        let e = new cv().fromGeometry(this), t = new Le, r = new Float32Array(e.vertices.length * 3);
        if (t.setAttribute("position", new Ve(r, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
            let n = new Float32Array(e.normals.length * 3);
            t.setAttribute("normal", new Ve(n, 3).copyVector3sArray(e.normals));
        }
        if (e.colors.length > 0) {
            let n = new Float32Array(e.colors.length * 3);
            t.setAttribute("color", new Ve(n, 3).copyColorsArray(e.colors));
        }
        if (e.uvs.length > 0) {
            let n = new Float32Array(e.uvs.length * 2);
            t.setAttribute("uv", new Ve(n, 2).copyVector2sArray(e.uvs));
        }
        if (e.uvs2.length > 0) {
            let n = new Float32Array(e.uvs2.length * 2);
            t.setAttribute("uv2", new Ve(n, 2).copyVector2sArray(e.uvs2));
        }
        t.groups = e.groups;
        for(let n in e.morphTargets){
            let s = [], o = e.morphTargets[n];
            for(let a = 0, l = o.length; a < l; a++){
                let c = o[a], h = new Ce(c.data.length * 3, 3);
                h.name = c.name, s.push(h.copyVector3sArray(c.data));
            }
            t.morphAttributes[n] = s;
        }
        if (e.skinIndices.length > 0) {
            let n = new Ce(e.skinIndices.length * 4, 4);
            t.setAttribute("skinIndex", n.copyVector4sArray(e.skinIndices));
        }
        if (e.skinWeights.length > 0) {
            let n = new Ce(e.skinWeights.length * 4, 4);
            t.setAttribute("skinWeight", n.copyVector4sArray(e.skinWeights));
        }
        return e.boundingSphere !== null && (t.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (t.boundingBox = e.boundingBox.clone()), t;
    }
    computeTangents() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
    }
    computeLineDistances() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    }
    applyMatrix(e) {
        return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e);
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    static createBufferGeometryFromObject(e) {
        let t = new Le, r = e.geometry;
        if (e.isPoints || e.isLine) {
            let n = new Ce(r.vertices.length * 3, 3), s = new Ce(r.colors.length * 3, 3);
            if (t.setAttribute("position", n.copyVector3sArray(r.vertices)), t.setAttribute("color", s.copyColorsArray(r.colors)), r.lineDistances && r.lineDistances.length === r.vertices.length) {
                let o = new Ce(r.lineDistances.length, 1);
                t.setAttribute("lineDistance", o.copyArray(r.lineDistances));
            }
            r.boundingSphere !== null && (t.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (t.boundingBox = r.boundingBox.clone());
        } else e.isMesh && (t = r.toBufferGeometry());
        return t;
    }
};
lo.prototype.isGeometry = !0;
var cv = class {
    constructor(){
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
    }
    computeGroups(e) {
        let t = [], r, n, s, o = e.faces;
        for(n = 0; n < o.length; n++){
            let a = o[n];
            a.materialIndex !== s && (s = a.materialIndex, r !== void 0 && (r.count = n * 3 - r.start, t.push(r)), r = {
                start: n * 3,
                materialIndex: s
            });
        }
        r !== void 0 && (r.count = n * 3 - r.start, t.push(r)), this.groups = t;
    }
    fromGeometry(e) {
        let t = e.faces, r = e.vertices, n = e.faceVertexUvs, s = n[0] && n[0].length > 0, o = n[1] && n[1].length > 0, a = e.morphTargets, l = a.length, c;
        if (l > 0) {
            c = [];
            for(let v = 0; v < l; v++)c[v] = {
                name: a[v].name,
                data: []
            };
            this.morphTargets.position = c;
        }
        let h = e.morphNormals, u = h.length, f;
        if (u > 0) {
            f = [];
            for(let v = 0; v < u; v++)f[v] = {
                name: h[v].name,
                data: []
            };
            this.morphTargets.normal = f;
        }
        let d = e.skinIndices, p = e.skinWeights, m = d.length === r.length, g = p.length === r.length;
        r.length > 0 && t.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        for(let v = 0; v < t.length; v++){
            let y = t[v];
            this.vertices.push(r[y.a], r[y.b], r[y.c]);
            let w = y.vertexNormals;
            if (w.length === 3) this.normals.push(w[0], w[1], w[2]);
            else {
                let S = y.normal;
                this.normals.push(S, S, S);
            }
            let b = y.vertexColors;
            if (b.length === 3) this.colors.push(b[0], b[1], b[2]);
            else {
                let S = y.color;
                this.colors.push(S, S, S);
            }
            if (s === !0) {
                let S = n[0][v];
                S !== void 0 ? this.uvs.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", v), this.uvs.push(new B, new B, new B));
            }
            if (o === !0) {
                let S = n[1][v];
                S !== void 0 ? this.uvs2.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", v), this.uvs2.push(new B, new B, new B));
            }
            for(let S = 0; S < l; S++){
                let T = a[S].vertices;
                c[S].data.push(T[y.a], T[y.b], T[y.c]);
            }
            for(let S6 = 0; S6 < u; S6++){
                let T = h[S6].vertexNormals[v];
                f[S6].data.push(T.a, T.b, T.c);
            }
            m && this.skinIndices.push(d[y.a], d[y.b], d[y.c]), g && this.skinWeights.push(p[y.a], p[y.b], p[y.c]);
        }
        return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), this;
    }
}, Nl = class {
    constructor(e, t, r, n, s, o = 0){
        this.a = e, this.b = t, this.c = r, this.normal = n && n.isVector3 ? n : new M, this.vertexNormals = Array.isArray(n) ? n : [], this.color = s && s.isColor ? s : new be, this.vertexColors = Array.isArray(s) ? s : [], this.materialIndex = o;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
        for(let t = 0, r = e.vertexNormals.length; t < r; t++)this.vertexNormals[t] = e.vertexNormals[t].clone();
        for(let t10 = 0, r13 = e.vertexColors.length; t10 < r13; t10++)this.vertexColors[t10] = e.vertexColors[t10].clone();
        return this;
    }
};
var iF = [
    "a",
    "b",
    "c"
];
function sF(i, e) {
    switch(e){
        case "c":
            return i.c;
        case "b":
            return i.b;
        case "a":
        default:
            return i.a;
    }
}
function hv(i, e, t) {
    let r = Math.min(i, e), n = Math.max(i, e), s = r + "_" + n;
    return t.get(s);
}
function uv(i, e, t, r, n, s) {
    let o = Math.min(i, e), a = Math.max(i, e), l = o + "_" + a, c;
    if (r.has(l)) c = r.get(l);
    else {
        let h = t[o], u = t[a];
        c = {
            a: h,
            b: u,
            newEdge: null,
            faces: []
        }, r.set(l, c);
    }
    c.faces.push(n), s[i].edges.push(c), s[e].edges.push(c);
}
function oF(i, e, t, r) {
    let n, s, o;
    for(n = 0, s = i.length; n < s; n++)t[n] = {
        edges: []
    };
    for(n = 0, s = e.length; n < s; n++)o = e[n], uv(o.a, o.b, i, r, o, t), uv(o.b, o.c, i, r, o, t), uv(o.c, o.a, i, r, o, t);
}
function mp(i, e, t, r, n) {
    i.push(new Nl(e, t, r, void 0, void 0, n));
}
function Ol(i, e) {
    return Math.abs(e - i) / 2 + Math.min(i, e);
}
function gp(i, e, t, r) {
    i.push([
        e.clone(),
        t.clone(),
        r.clone()
    ]);
}
var yp = class {
    constructor(e = 1){
        this.subdivisions = e;
    }
    modify(e) {
        e instanceof Le ? e = new lo().fromBufferGeometry(e) : e = e.clone(), e.mergeVertices();
        let t = this.subdivisions;
        for(; t-- > 0;)this._smooth(e);
        return e.computeFaceNormals(), e.computeVertexNormals(), e;
    }
    _smooth(e) {
        let t = new M, r, n, s, o, a, l = e.vertices, c = e.faces, h = e.faceVertexUvs[0], u = h !== void 0 && h.length > 0, f = [], d = new Map;
        oF(l, c, f, d);
        let p = [], m, g, v, y, w, b, S;
        for (let oe of Array.from(d.keys())){
            for(g = d.get(oe), v = new M, w = 3 / 8, b = 1 / 8, S = g.faces.length, S != 2 && (w = .5, b = 0), v.addVectors(g.a, g.b).multiplyScalar(w), t.set(0, 0, 0), o = 0; o < S; o++){
                for(y = g.faces[o], a = 0; a < 3 && (m = l[sF(y, iF[a])], !(m !== g.a && m !== g.b)); a++);
                m && t.add(m);
            }
            t.multiplyScalar(b), v.add(t), g.newEdge = p.length, p.push(v);
        }
        let T, A, x, E, _, C, I, N = [];
        for(n = 0, s = l.length; n < s; n++){
            for(C = l[n], _ = f[n].edges, r = _.length, r == 3 ? T = 3 / 16 : r > 3 && (T = 3 / (8 * r)), A = 1 - r * Number(T), x = T, r <= 2 && r == 2 && (A = 3 / 4, x = 1 / 8), I = C.clone().multiplyScalar(A), t.set(0, 0, 0), o = 0; o < r; o++)E = _[o], m = E.a !== C ? E.a : E.b, t.add(m);
            t.multiplyScalar(Number(x)), I.add(t), N.push(I);
        }
        let R = N.concat(p), k = N.length, G, te, Q, Y = [], F = [], z, O, j, q, J = new B, W = new B, ge = new B;
        for(n = 0, s = c.length; n < s; n++)y = c[n], G = Number(hv(y.a, y.b, d).newEdge) + k, te = Number(hv(y.b, y.c, d).newEdge) + k, Q = Number(hv(y.c, y.a, d).newEdge) + k, mp(Y, G, te, Q, y.materialIndex), mp(Y, y.a, G, Q, y.materialIndex), mp(Y, y.b, te, G, y.materialIndex), mp(Y, y.c, Q, te, y.materialIndex), u && (z = h[n], O = z[0], j = z[1], q = z[2], J.set(Ol(O.x, j.x), Ol(O.y, j.y)), W.set(Ol(j.x, q.x), Ol(j.y, q.y)), ge.set(Ol(O.x, q.x), Ol(O.y, q.y)), gp(F, J, W, ge), gp(F, O, J, ge), gp(F, j, W, J), gp(F, q, ge, W));
        e.vertices = R, e.faces = Y, u && (e.faceVertexUvs[0] = F);
    }
};
var Er = new M, g1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var s, o;
        let t = (o = (s = i.geometry) != null ? s : e == null ? void 0 : e.geometry) != null ? o : new Le().copy(new vn(100, 100, 100)), r;
        e === void 0 ? (t.computeBoundingBox(), t.boundingBox.getSize(Er), r = {
            width: Er.x,
            height: Er.y,
            depth: Er.z,
            subdivisions: 0
        }) : r = e.parameters;
        let n = ie(ie({}, r), i.parameters);
        return {
            parameters: {
                width: Math.abs(n.width),
                height: Math.abs(n.height),
                depth: Math.abs(n.depth),
                subdivisions: Math.abs(n.subdivisions)
            },
            geometry: t
        };
    }
    static build(i) {
        var l;
        let { width: e , height: t , depth: r , subdivisions: n  } = i.parameters, s = (l = i.geometry) != null ? l : new Le().copy(new vn(100, 100, 100)), o = s.userData.parameters;
        o === void 0 ? (s.computeBoundingBox(), s.boundingBox.getSize(Er)) : Er.set(o.width, o.height, o.depth), (e !== Er.x || t !== Er.y || r !== Er.z) && s.scale(Er.x === 0 ? 1 : e / Er.x, Er.y === 0 ? 1 : t / Er.y, Er.z === 0 ? 1 : r / Er.z);
        let a = s.originalGeometry;
        return n > 0 ? (a === void 0 || (o == null ? void 0 : o.subdivisions) !== n) && (a === void 0 && (a = s), s = new yp(n).modify(a).toBufferGeometry()) : (a !== void 0 && (s = a), a = void 0, s.getAttribute("normal") === void 0 && s.computeVertexNormals()), a !== void 0 && Object.assign(s, {
            originalGeometry: a
        }), delete i.geometry, Object.assign(s, {
            userData: xe(ie({}, i), {
                type: "NonParametricGeometry"
            })
        });
    }
    static loadFromUrl(i, e, t) {
        new Ws(t).load(i, (n)=>{
            let s = this.normalizeInputs({
                geometry: n
            });
            n.boundingBox.getSize(Er);
            let o = 100 / Er.x;
            Object.assign(s.parameters, {
                width: 100,
                height: Er.y * o,
                depth: Er.z * o
            }), e(this.build(s));
        });
    }
};
var y1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var n, s, o;
        let t = Object.assign({}, (n = e == null ? void 0 : e.parameters) != null ? n : {
            width: 100,
            depth: 0,
            spikes: 5,
            cornerRadius: 0,
            extrudeDepth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 3
        }, i.parameters);
        return {
            shape: i.shape && i.shape instanceof Tt ? i.shape : new Tt,
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((s = t.height) != null ? s : t.width),
                depth: Math.abs(t.depth !== void 0 && t.depth === 0 && t.extrudeDepth > 0 ? t.extrudeDepth : (o = t.depth) != null ? o : 0)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , spikes: r , cornerRadius: n , depth: s , extrudeBevelSize: o , extrudeBevelSegments: a  } = i.parameters, l = i.shape, c = e * .5, h = t * .5, u = 0, f = 0, d = 2 * Math.PI / r;
        for(let m = 0; m < r; m++){
            let g = d * m, v = u + Math.sin(g) * c, y = f + Math.cos(g) * h;
            l.addPoint(l.createPoint(v, y));
        }
        l.isClosed = !0;
        for(let m5 = 0, g = l.points.length; m5 < g; m5++)l.points[m5].roundness = n;
        l.roundness = n, l.update();
        let p = Hr.create({
            shape: l,
            parameters: {
                roundness: n,
                depth: s,
                extrudeBevelSize: o,
                extrudeBevelSegments: a
            }
        });
        return Object.assign(p, {
            userData: xe(ie({}, i), {
                type: "PolygonGeometry"
            })
        });
    }
};
var v1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            radialSegments: 4,
            heightSegments: 1,
            cornerRadius: 0,
            cornerSegments: 8,
            openEnded: !1
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , depth: r , radialSegments: n , heightSegments: s , openEnded: o , cornerRadius: a , cornerSegments: l  } = i.parameters, c = new dv(e * .5, t, n, s, o, a, l);
        return c.scale(1, 1, r / e), Object.assign(c, {
            userData: xe(ie({}, i), {
                type: "PyramidGeometry"
            })
        });
    }
};
function Yh(i, e, t) {
    t.x = i.x * e.x, t.y = i.y, t.z = i.x * e.y;
}
function fv(i, e, t, r, n, s) {
    let o = e.clone().sub(i), a = t.clone().sub(i), l = o.angleTo(a);
    if (o.normalize(), a.normalize(), r === n) {
        let c = o.add(a).normalize();
        s.copy(i).addScaledVector(c, r / Math.sin(l / 2));
    } else {
        let c = o.angleTo(a);
        s.copy(i), s.addScaledVector(o, n / Math.sin(c)), s.addScaledVector(a, r / Math.sin(c));
    }
}
function aF(i, e, t) {
    let r = i.clone().sub(e), n = t.clone().sub(e);
    return r.projectOnVector(n), r.add(e);
}
var dv = class extends Le {
    constructor(e = .5, t = 1, r = 4, n = 1, s = !1, o = 0, a = 4){
        super(), r = Math.floor(Math.max(3, r)), n = Math.floor(n), a = Math.floor(a);
        let l = [], c = [], h = [], u = [], f = 0, d = t / 2, p = Math.PI / r, m = e * Math.cos(Math.PI / r), g = 2 * Math.PI / r, v = (r - 2) * Math.PI / r, y = Math.PI - v, w = new M(0, -d, 0), b = new M(0, d, 0), S = new B(e, -d), T = new B(m, -d), A = new B(0, b.y).sub(T), x = new B(0, b.y).sub(S), E = new B(A.y, -A.x).normalize(), _ = new B(x.y, -x.x).normalize(), I = e * Math.cos(Math.PI / r) * Math.tan((Math.PI - A.angle()) / 2) - 1e-8;
        o = Math.min(o, I);
        let N;
        {
            let F = new M(E.x, E.y, 0), z = new M(Math.cos(g) * F.x, F.y, Math.sin(g) * F.x);
            N = F.angleTo(z);
        }
        let R = o / Math.tan((Math.PI - A.angle()) / 2), k = o / Math.tan((Math.PI - N) / 2), G = new M;
        if (!s) {
            c.push(w.x, w.y, w.z), h.push(0, -1, 0), u.push(0, 0);
            let F = f++, z = [], O = S.clone(), j = R / Math.cos(Math.PI / r);
            O.x -= j;
            for(let q = 0; q < r; q++){
                let J = q / r * Math.PI * 2 + p, W = new B(Math.sin(J), Math.cos(J));
                Yh(O, W, G), c.push(G.x, G.y, G.z), h.push(0, -1, 0), u.push(0, 0), z.push(f++);
            }
            for(let q5 = 0; q5 < z.length; q5++)l.push(z[q5], F, z[(q5 + 1) % z.length]);
        }
        let te = [];
        {
            let F = new M, z = new M, O = new M, j = new M, q = new M, J = new M;
            for(let W = 0; W < r; W++){
                let ge = W / r * Math.PI * 2 + p, oe = (W + .5) / r * Math.PI * 2 + p, le = (W + 1) / r * Math.PI * 2 + p, H = new B(Math.sin(ge), Math.cos(ge)), he = new B(Math.sin(oe), Math.cos(oe)), K = new B(Math.sin(le), Math.cos(le));
                Yh(S, H, z), Yh(S, K, O), Yh(E, he, F), fv(b, z, O, k, k, j), c.push(j.x, j.y, j.z), fv(z, b, O, k, R, q), c.push(q.x, q.y, q.z), fv(O, z, b, R, k, J), c.push(J.x, J.y, J.z), h.push(F.x, F.y, F.z), h.push(F.x, F.y, F.z), h.push(F.x, F.y, F.z), u.push(0, 0), u.push(0, 0), u.push(0, 0);
                let V = f++, Z = f++, ce = f++;
                if (l.push(V, Z, ce), o > 0) {
                    {
                        let ve = z.clone().add(O).multiplyScalar(.5), me = b.clone().sub(ve).normalize(), ke = w.clone().sub(ve).normalize().add(me).normalize().multiplyScalar(-1), L = J.clone().sub(q);
                        Q(ve, L, ke, A.angle());
                    }
                    let se, pe;
                    {
                        let ve = new M;
                        Yh(_, K, ve);
                        let me = J.clone().add(j).multiplyScalar(.5);
                        me = aF(me, O, b);
                        let Pe = J.clone().sub(j);
                        [se, pe] = Q(me, Pe, ve, N, j.y);
                    }
                    {
                        let ve = se, me = ve.clone().setY(0).normalize(), Pe = new M(0, -1, 0), ke = me.clone().cross(Pe);
                        Y(ve, me, Pe, ke);
                    }
                    te.concat(pe);
                    {
                        let ve = A.angle(), me = Math.PI - ve, Pe = b.clone();
                        Pe.y -= o / Math.sin(ve - Math.PI / 2);
                        let ke = new M, L = [];
                        for(let re = 0; re < a; re++){
                            let ye = [], Se = Math.PI / 2 - me * re / a, Ie = Math.cos(Se), Fe = Math.sin(Se), ue = oe;
                            for(let rt = 0; rt <= re; rt++){
                                let st = Math.cos(ue), Ee = Math.sin(ue);
                                F.x = Ie * Ee, F.y = Fe, F.z = Ie * st, ke.copy(Pe).addScaledVector(F, o), c.push(ke.x, ke.y, ke.z), h.push(F.x, F.y, F.z), u.push(0, 0), ye.push(f++), ue += Math.PI * 2 / re / r;
                            }
                            L.push(ye);
                        }
                        pe.reverse(), L.push(pe);
                        let D = L.length - 1;
                        for(let re1 = 0; re1 < D; re1++){
                            let ye = L[re1], Se = L[re1 + 1], Ie = ye.length - 1;
                            l.push(Se[1], ye[0], Se[0]);
                            for(let Fe = 1; Fe <= Ie; Fe++)l.push(ye[Fe], ye[Fe - 1], Se[Fe]), l.push(Se[Fe + 1], ye[Fe], Se[Fe]);
                        }
                    }
                }
            }
        }
        this.setIndex(l), this.setAttribute("position", new Ce(c, 3)), this.setAttribute("normal", new Ce(h, 3)), this.setAttribute("uv", new Ce(u, 2));
        function Q(F, z, O, j, q) {
            let J = -j / 2, W = (Math.PI - j) / 2, ge = z.clone().normalize().cross(O);
            F.addScaledVector(O, -o / Math.sin(W));
            let oe = new M, le = new M, H = 1, he = f, K = [];
            for(let V = 0; V <= a; V++){
                let Z = J + V / a * j;
                le.set(0, 0, 0), le.addScaledVector(ge, Math.sin(Z)), le.addScaledVector(O, Math.cos(Z));
                for(let ce = 0; ce <= H; ce++){
                    let se = ce / H - .5;
                    if (oe.copy(F), oe.addScaledVector(z, se), oe.addScaledVector(le, o), q != null) {
                        let pe = Math.max(0, oe.y - q);
                        oe.addScaledVector(z, -pe / z.y);
                    }
                    c.push(oe.x, oe.y, oe.z), h.push(le.x, le.y, le.z), u.push(0, 0), ce === 0 && K.push(f), f++;
                }
            }
            for(let V14 = 0; V14 < a; V14++)for(let Z = 0; Z < H; Z++){
                let ce = he + Z + (H + 1) * V14, se = ce + (H + 1), pe = se + 1, ve = ce + 1;
                l.push(ce, se, ve), l.push(se, pe, ve);
            }
            return [
                F.clone().addScaledVector(z, .5),
                K
            ];
        }
        function Y(F, z, O, j) {
            let q = Math.PI / 2, J = x.angle() - q, W = [], ge = new M, oe = new M;
            for(let H = 0; H <= a; H++){
                let he = [], K = H / a;
                for(let V = 0; V <= H; V++){
                    let ce = ((H ? V / H : 0) - .5) * y, se = Math.cos(ce), pe = Math.sin(ce), ve = Math.atan(Math.tan(J) * se), me = (q + ve) * K, Pe = Math.cos(me), ke = Math.sin(me);
                    ge.set(0, 0, 0), ge.addScaledVector(z, ke * se), ge.addScaledVector(O, Pe), ge.addScaledVector(j, ke * pe), oe.copy(F).addScaledVector(ge, o), c.push(oe.x, oe.y, oe.z), h.push(ge.x, ge.y, ge.z), u.push(0, 0), he.push(f++);
                }
                W.push(he);
            }
            let le = W.length - 1;
            for(let H10 = 0; H10 < le; H10++){
                let he = W[H10], K = W[H10 + 1], V = he.length - 1;
                l.push(he[0], K[1], K[0]);
                for(let Z = 1; Z <= V; Z++)l.push(he[Z - 1], he[Z], K[Z]), l.push(he[Z], K[Z + 1], K[Z]);
            }
        }
    }
};
var vp = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var s, o, a, l;
        let t = Object.assign({}, (s = e == null ? void 0 : e.parameters) != null ? s : {
            width: 100,
            depth: 0,
            cornerRadius: [
                0,
                0,
                0,
                0
            ],
            cornerType: 1,
            extrudeDepth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1
        }, i.parameters), r = Object.assign((o = e == null ? void 0 : e.ui) != null ? o : {
            enabledIndieCorners: !1
        }, i.ui);
        return {
            shape: i.shape && i.shape instanceof Tt ? i.shape : new Tt,
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((a = t.height) != null ? a : t.width),
                depth: Math.abs(t.depth !== void 0 && t.depth === 0 && t.extrudeDepth > 0 ? t.extrudeDepth : (l = t.depth) != null ? l : 0)
            }),
            ui: r
        };
    }
    static build(i) {
        let e = i.shape, { width: t , height: r , cornerRadius: n , cornerType: s , depth: o , extrudeBevelSize: a , extrudeBevelSegments: l  } = i.parameters, c = {
            x: t * .5,
            y: r * .5
        }, h = {
            x: -c.x,
            y: -c.y
        }, u = {
            x: c.x,
            y: c.y
        };
        function f(b, S, T) {
            return S > t && T > r ? Math.min(b * t / S, b * r / T) : S > t ? b * t / S : T > r ? b * r / T : b;
        }
        let d = [];
        d[0] = n[0] === 0 ? 0 : f(n[0], n[0] + n[3], n[0] + n[1]), d[1] = n[1] === 0 ? 0 : f(n[1], n[1] + n[2], n[1] + n[0]), d[2] = n[2] === 0 ? 0 : f(n[2], n[2] + n[1], n[2] + n[3]), d[3] = n[3] === 0 ? 0 : f(n[3], n[3] + n[0], n[3] + n[2]);
        let p = h.x, m = u.x, g = u.y, v = h.y;
        e.addPoint(e.createPoint(p, g)), e.addPoint(e.createPoint(m, g)), e.addPoint(e.createPoint(m, v)), e.addPoint(e.createPoint(p, v)), e.isClosed = !0;
        let y = !0;
        for(let b9 = 0, S7 = e.points.length; b9 < S7; b9++)e.points[b9].roundness = d[b9], b9 > 0 && d[b9] !== d[b9 - 1] && (y = !1);
        y && (e.roundness = d[0]), e.useCubicForRoundedCorners = s !== 1, e.update();
        let w = Hr.create({
            shape: e,
            parameters: {
                depth: o,
                extrudeBevelSize: a,
                extrudeBevelSegments: l
            }
        });
        return Object.assign(w, {
            userData: xe(ie({}, i), {
                type: "RectangleGeometry"
            })
        });
    }
};
var x1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            widthSegments: 64,
            heightSegments: 64,
            phiStart: 0,
            phiLength: 2 * Math.PI,
            thetaStart: 0,
            thetaLength: Math.PI
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width)
            })
        };
    }
    static build(i) {
        let { width: e = 100 , height: t = e , depth: r = e , widthSegments: n = 64 , heightSegments: s = 64 , phiStart: o , phiLength: a , thetaStart: l , thetaLength: c  } = i.parameters, h = new Ro(.5 * e, n, s, o, a, l, c);
        return h.scale(1, t / e, r / e), Object.assign(h, {
            userData: xe(ie({}, i), {
                type: "SphereGeometry"
            })
        });
    }
};
var b1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            depth: 0,
            widthSegments: 8,
            heightSegments: 8
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: 0
            })
        };
    }
    static build(i) {
        let { width: e = 100 , height: t = e , widthSegments: r = 8 , heightSegments: n = 8  } = i.parameters, s = new is(e, t, r, n);
        return s.scale(1, 1, 1), Object.assign(s, {
            userData: xe(ie({}, i), {
                type: "PlaneGeometry"
            })
        });
    }
};
var w1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var n, s, o;
        let t = Object.assign({}, (n = e == null ? void 0 : e.parameters) != null ? n : {
            width: 100,
            depth: 0,
            innerRadiusPercent: 38.19,
            spikes: 5,
            cornerRadius: 0,
            angle: 360,
            extrudeDepth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1
        }, i.parameters);
        return {
            shape: i.shape && i.shape instanceof Tt ? i.shape : new Tt,
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((s = t.height) != null ? s : t.width),
                depth: Math.abs(t.depth !== void 0 && t.depth === 0 && t.extrudeDepth > 0 ? t.extrudeDepth : (o = t.depth) != null ? o : 0)
            })
        };
    }
    static build(i) {
        let { width: e , height: t , innerRadiusPercent: r , spikes: n , cornerRadius: s , angle: o , depth: a , extrudeBevelSize: l , extrudeBevelSegments: c  } = i.parameters, h = i.shape, u = e * .5, f = t * .5, d = 0, p = 0, m = o * Math.PI / 360 / n, g = Math.PI / 2 * -3, v = u * r / 100, y = f * r / 100;
        if (n === 3 && r === 50) {
            m = 2 * Math.PI / n;
            for(let b = 0; b < n; b++){
                let S = m * b, T = d + Math.sin(S) * u, A = p + Math.cos(S) * f;
                h.addPoint(h.createPoint(T, A));
            }
        } else for(let b = 0; b < n; b++){
            let S = d + Math.cos(g) * u, T = p + Math.sin(g) * f;
            h.addPoint(h.createPoint(S, T)), g += m, S = d + Math.cos(g) * v, T = p + Math.sin(g) * y, h.addPoint(h.createPoint(S, T)), g += m;
        }
        h.isClosed = !0;
        for(let b10 = 0, S = h.points.length; b10 < S; b10++)h.points[b10].roundness = s;
        h.roundness = s, h.update();
        let w = Hr.create({
            shape: h,
            parameters: {
                roundness: s,
                depth: a,
                extrudeBevelSize: l,
                extrudeBevelSegments: c
            }
        });
        return Object.assign(w, {
            userData: xe(ie({}, i), {
                type: "StarGeometry"
            })
        });
    }
};
var xp = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            depth: 0
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : 0)
            })
        };
    }
    static build(i) {
        let { width: e , height: t  } = i.parameters, r = new is(e, t);
        return Object.assign(r, {
            userData: xe(ie({}, i), {
                type: "TextFrameGeometry"
            })
        });
    }
};
var S1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var o, a, l;
        let t = Object.assign({}, (o = e == null ? void 0 : e.parameters) != null ? o : {
            width: 100,
            radialSegments: 32,
            tubularSegments: 64,
            arc: Math.PI * 2,
            cornerRadius: 30,
            cornerSegments: 8
        }, i.parameters), r = Math.abs(t.width), n = Math.abs((a = t.height) != null ? a : t.width), s = Math.abs((l = t.depth) != null ? l : t.width * .25);
        return {
            parameters: Object.assign(t, {
                width: r,
                height: n,
                depth: s
            })
        };
    }
    static build(i) {
        let { width: e , height: t , depth: r , radialSegments: n , tubularSegments: s , arc: o , cornerRadius: a , cornerSegments: l  } = i.parameters, c = lF(e, t, r, e * .5, o, s, 0, 0, n, a, l);
        return c.scale(1, t / e, 1), Object.assign(c, {
            userData: xe(ie({}, i), {
                type: "TorusGeometry"
            })
        });
    }
};
function lF(i, e, t, r, n, s, o, a, l, c, h) {
    return [e, t] = [
        t,
        e
    ], o = e / 2, n /= 2 * Math.PI, n == 1 && (c = 0), new jh(!0, i, e, t, r, n, s, o, a, l, c, h);
}
var M1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var r, n, s, o;
        let t = Object.assign({}, (r = e == null ? void 0 : e.parameters) != null ? r : {
            width: 100,
            tubularSegments: 64,
            radialSegments: 32,
            p: 2,
            q: 3
        }, i.parameters);
        return {
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((n = t.height) != null ? n : t.width),
                depth: Math.abs((s = t.depth) != null ? s : t.width),
                tube: (o = t.tube) != null ? o : t.width * .125
            })
        };
    }
    static build(i) {
        let { width: e , tube: t , tubularSegments: r , radialSegments: n , p: s , q: o  } = i.parameters, a = e * .5;
        a !== t && (a -= t);
        let l = new Ha(a, t, r, n, s, o);
        return Object.assign(l, {
            userData: xe(ie({}, i), {
                type: "TorusKnotGeometry"
            })
        });
    }
};
var A1 = class {
    static create(i) {
        return this.build(this.normalizeInputs(i));
    }
    static normalizeInputs(i, e) {
        var n, s, o;
        let t = Object.assign({}, (n = e == null ? void 0 : e.parameters) != null ? n : {
            width: 100,
            depth: 0,
            spikes: 5,
            cornerRadius: 0,
            extrudeDepth: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1,
            isRect: !1
        }, i.parameters);
        return {
            shape: i.shape && i.shape instanceof Tt ? i.shape : new Tt,
            parameters: Object.assign(t, {
                width: Math.abs(t.width),
                height: Math.abs((s = t.height) != null ? s : t.width * (t.isRect ? 1 : Math.sqrt(3) / 2)),
                depth: Math.abs(t.depth !== void 0 && t.depth === 0 && t.extrudeDepth > 0 ? t.extrudeDepth : (o = t.depth) != null ? o : 0)
            })
        };
    }
    static build(i) {
        let { width: e = 100 , height: t , cornerRadius: r , depth: n , extrudeBevelSize: s , extrudeBevelSegments: o , isRect: a  } = i.parameters, l = i.shape, c = e * .5, h = t * .5;
        a ? (l.addPoint(l.createPoint(-c, h)), l.addPoint(l.createPoint(c, -h)), l.addPoint(l.createPoint(-c, -h))) : (l.addPoint(l.createPoint(0, h)), l.addPoint(l.createPoint(c, -h)), l.addPoint(l.createPoint(-c, -h))), l.isClosed = !0;
        for(let f = 0, d = l.points.length; f < d; f++)l.points[f].roundness = r;
        l.roundness = r, l.update();
        let u = Hr.create({
            shape: l,
            parameters: {
                roundness: r,
                depth: n,
                extrudeBevelSize: s,
                extrudeBevelSegments: o
            }
        });
        return Object.assign(u, {
            userData: xe(ie({}, i), {
                type: "TriangleGeometry"
            })
        });
    }
};
var Xh = {};
Tx(Xh, {
    addBarycentricAttribute: ()=>uF
    ,
    fixUvs: ()=>dF
    ,
    loadFromUrl: ()=>fF
    ,
    resizeGeometry: ()=>hF
    ,
    roundShapePolygon: ()=>cF
});
var T1 = function(i, e) {
    let t = e.x - i.x, r = e.y - i.y, n = Math.sqrt(t * t + r * r), s = t / n, o = r / n, a = Math.atan2(o, s);
    return {
        x: t,
        y: r,
        len: n,
        nx: s,
        ny: o,
        ang: a
    };
}, cF = (i, e, t)=>{
    let r, n, s, o, a, l, c, h, u, f, d, p, m, g, v = e.length;
    for(o = e[v - 2], i.curves = [], r = 1; r < v - 1; r++){
        a = e[r % v], l = e[(r + 1) % v];
        let y = T1(a, o), w = T1(a, l);
        c = y.nx * w.ny - y.ny * w.nx, h = y.nx * w.nx - y.ny * -w.ny, d = Math.asin(c), u = 1, f = !1, h < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, u = -1, f = !0) : d > 0 && (u = -1, f = !0), p = d / 2, g = Math.abs(Math.cos(p) * t / Math.sin(p)), g > Math.min(y.len / 2, w.len / 2) ? (g = Math.min(y.len / 2, w.len / 2), m = Math.abs(g * Math.sin(p) / Math.cos(p))) : m = t, n = a.x + w.nx * g, s = a.y + w.ny * g, n += -w.ny * m * u, s += w.nx * m * u, i.absarc(n, s, m, y.ang + Math.PI / 2 * u, w.ang - Math.PI / 2 * u, f), o = a, a = l;
    }
    i.closePath();
}, hF = (i, { width: e , height: t , depth: r  })=>{
    e = Math.abs(e), t = Math.abs(t), r = Math.abs(r);
    let n = i.userData.parameters, s, o, a;
    e === 0 ? (e = n.width, s = 1) : s = e / n.width, t === 0 ? (t = n.height, o = 1) : o = t / n.height, r === 0 ? (r = n.depth, a = 1) : a = r / n.depth, i.scale(s, o, a), n.width = e, n.height = t, n.depth = r;
}, uF = (i, e)=>{
    let t = [
        new M(1, 0, 0),
        new M(0, 1, 0),
        new M(0, 0, 1)
    ], r = i.attributes.position, n = new Float32Array(r.count * 3);
    for(let s = 0, o = r.count; s < o; s++)t[s % 3].toArray(n, s * 3);
    i.setAttribute(e, new Ce(n, 3));
}, fF = (i)=>new Promise((e)=>{
        new Ws().load(i, (r)=>e(r)
        );
    })
, dF = (i, e, t)=>{
    let r = i.getAttribute("uv");
    if (r) for(let n = 0; n < r.count; n++){
        let s = r.getX(n), o = r.getY(n);
        r.setXY(n, (s + e / 2) / e, 1 - (o - t / 2) / t * -1);
    }
};
var pF, bp = new Promise((i)=>{
    pF = i;
});
var Qh = class {
    constructor(e){
        e = e != null ? e : {}, this.name = e.name, this.type = e.type, this.node = e.node, this.size = e.size, this.needsUpdate = e.needsUpdate;
    }
    get value() {
        return this.node.value;
    }
    set value(e) {
        this.node.value = e;
    }
};
var We = class {
    constructor(e){
        this.hashProperties = void 0;
        this.isNode = !0;
        this.shortcuts = {};
        this.uuid = et.generateUUID(), this.type = e, this.name = "", this.userData = {};
    }
    analyze(e, t) {
        t = t != null ? t : {}, e.analyzing = !0, this.build(e.addFlow(t.slot, t.cache, t.context), "v4"), e.clearVertexNodeCode(), e.clearFragmentNodeCode(), e.removeFlow(), e.analyzing = !1;
    }
    analyzeAndFlow(e, t, r) {
        return r = r != null ? r : {}, this.analyze(e, r), this.flow(e, t, r);
    }
    flow(e, t, r) {
        r = r != null ? r : {}, e.addFlow(r.slot, r.cache, r.context);
        let n = {
            result: this.build(e, t),
            code: e.clearNodeCode(),
            extra: e.context.extra
        };
        return e.removeFlow(), n;
    }
    build(e, t, r) {
        t = t != null ? t : this.getType(e, t);
        let n = e.getNodeData(r != null ? r : this);
        return e.analyzing && this.appendDepsNode(e, n, t), e.nodes.indexOf(this) === -1 && e.nodes.push(this), this.updateFrame !== void 0 && e.updaters.indexOf(this) === -1 && e.updaters.push(this), this.generate(e, t, r);
    }
    updateFrame(e) {}
    generateReadonly(e, t, r, n, s, o) {
        return "";
    }
    generate(e, t, r, n, s) {
        return "";
    }
    parse(e, t, r, n) {}
    appendDepsNode(e, t, r) {
        t.deps = (t.deps || 0) + 1;
        let n = e.getTypeLength(r);
        (n > (t.outputMax || 0) || this.getType(e, r)) && (t.outputMax = n, t.output = r);
    }
    setName(e) {
        this.name = e;
    }
    getName() {
        return this.name;
    }
    getType(e, t) {
        return t === "sampler2D" || t === "samplerCube" ? t : this.type;
    }
    getJSONNode(e) {
        if ((e == null ? void 0 : e.materials) && (e == null ? void 0 : e.materials[this.uuid]) !== void 0) return e.materials[this.uuid];
    }
    getHash() {
        let e = "{", t, r;
        for(t in this)r = this[t], r instanceof We && (e += '"' + t + '":' + r.getHash() + ",");
        if (this.hashProperties) for(let n = 0; n < this.hashProperties.length; n++)t = this.hashProperties[n], r = this[t], e += '"' + t + '":"' + String(r) + '",';
        return e += '"id":"' + this.uuid + '"}', e;
    }
    copy(e) {
        return this.name = e.name, e.type && (this.type = e.type), e.frameId && (this.frameId = e.frameId), e.hashProperties && (this.hashProperties = e.hashProperties.map((t)=>t
        )), this.userData = JSON.parse(JSON.stringify(e.userData)), this.shortcuts = JSON.parse(JSON.stringify(e.shortcuts)), this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    createJSONNode(e) {
        let t = e === void 0 || typeof e == "string";
        if (typeof this.type != "string") throw new Error("Node does not allow serialization.");
        let r = {};
        return r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), !t && e && (e.nodes[this.uuid] = r), r;
    }
    toJSON(e) {
        var t;
        return (t = this.getJSONNode(e)) != null ? t : this.createJSONNode(e);
    }
    fromJSON(e, t) {
        return this.uuid = e.uuid, this.type = e.type, e.name && (this.name = e.name), e.userData && (this.userData = e.userData), this;
    }
};
var pv = class {
    constructor(){
        this.nodes = {};
        this.keywords = {};
    }
    add(e) {
        this.nodes[e.name] = e;
    }
    addKeyword(e, t, r) {
        r = r !== void 0 ? r : !0, this.keywords[e] = {
            callback: t,
            cache: r
        };
    }
    remove(e) {
        delete this.nodes[e.name];
    }
    removeKeyword(e) {
        delete this.keywords[e];
    }
    get(e) {
        return this.nodes[e];
    }
    getKeyword(e, t) {
        return this.keywords[e].callback(t);
    }
    getKeywordData(e) {
        return this.keywords[e];
    }
    contains(e) {
        return this.nodes[e] !== void 0;
    }
    containsKeyword(e) {
        return this.keywords[e] !== void 0;
    }
}, _r = new pv;
var Ye = class extends We {
    constructor(t, r){
        super(t);
        this.scope = "";
        r = r != null ? r : {}, this.shared = r.shared !== void 0 ? r.shared : !0, this.unique = r.unique !== void 0 ? r.unique : !1;
    }
    build(t, r, n, s) {
        if (r = r != null ? r : this.getType(t), this.getShared(t, r)) {
            let o = this.getUnique(t, r);
            o && this.uuid === void 0 && (this.uuid = et.generateUUID()), n = t.getUUID(n != null ? n : this.getUUID(), !o);
            let a = t.getNodeData(n), l = a.output || this.getType(t);
            if (t.analyzing) return (a.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(t, a, r), this.generate(t, r, n)) : super.build(t, r, n);
            if (o) return a.name = a.name || super.build(t, r, n), a.name;
            if (!this.getLabel() && (!this.getShared(t, l) || t.context.ignoreCache || a.deps === 1)) return super.build(t, r, n);
            n = this.getUUID(!1);
            let c = this.getTemp(t, n);
            if (c) return t.format(c, l, r);
            {
                c = super.generate(t, r, n, a.output, s);
                let h = this.generate(t, l, n);
                return t.addNodeCode(c + " = " + h + ";"), t.format(c, l, r);
            }
        }
        return super.build(t, r, n);
    }
    getShared(t, r) {
        return r !== "sampler2D" && r !== "samplerCube" && this.shared;
    }
    getUnique(t, r) {
        return this.unique;
    }
    setLabel(t) {
        return this.label = t, this;
    }
    getLabel() {
        return this.label;
    }
    getUUID(t) {
        let r = this.uuid;
        return typeof this.scope == "string" && (r = this.scope + "-" + r), r;
    }
    getTemp(t, r) {
        r = r || this.uuid;
        let n = t.getVars()[r];
        return n ? n.name : void 0;
    }
    generate(t, r, n, s, o) {
        return this.getShared(t, r) || console.error("TempNode is not shared"), n = n != null ? n : this.uuid, t.getTempVar(n, s != null ? s : this.getType(t), o, this.getLabel()).name;
    }
};
var jt = class extends Ye {
    constructor(t, r){
        r = r != null ? r : {}, r.shared = r.shared !== void 0 ? r.shared : !1;
        super(t, r);
        this.readonly = !1;
    }
    setReadonly(t) {
        return this.readonly = t, this.hashProperties = this.readonly ? [
            "value"
        ] : void 0, this;
    }
    getReadonly() {
        return this.readonly;
    }
    createJSONNode(t) {
        let r = super.createJSONNode(t);
        return this.readonly === !0 && (r.readonly = this.readonly), r;
    }
    fromJSON(t, r) {
        return super.fromJSON(t, r), t.readonly !== void 0 && this.setReadonly(t.readonly), this;
    }
    generate(t, r, n, s, o, a) {
        n = t.getUUID(n != null ? n : this.getUUID()), s = s != null ? s : this.getType(t);
        let l = t.getNodeData(n);
        return this.getReadonly() && this.generateReadonly !== void 0 ? this.generateReadonly(t, r, n, s, o, a) : t.isShader("vertex") ? (l.vertex || (l.vertex = t.createVertexUniform(s, this, o, a, this.getLabel())), t.format(l.vertex.name, s, r)) : (l.fragment || (l.fragment = t.createFragmentUniform(s, this, o, a, this.getLabel())), t.format(l.fragment.name, s, r));
    }
    copy(t) {
        return super.copy(t), this.readonly = t.readonly, this;
    }
};
var Nr = class extends jt {
    constructor(t = 0, r){
        super("v2");
        this.nodeType = "Vector2";
        this.value = t instanceof B ? t : new B(t, r);
    }
    get x() {
        return this.value.x;
    }
    set x(t) {
        this.value.x = t;
    }
    get y() {
        return this.value.y;
    }
    set y(t) {
        this.value.y = t;
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format("vec2(" + this.value.x + ", " + this.value.y + ")", s, r);
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), this;
    }
};
var Or = class extends jt {
    constructor(t = 0, r, n){
        super("v3");
        this.nodeType = "Vector3";
        this.value = t instanceof M ? t : new M(t, r, n);
    }
    get x() {
        return this.value.x;
    }
    set x(t) {
        this.value.x = t;
    }
    get y() {
        return this.value.y;
    }
    set y(t) {
        this.value.y = t;
    }
    get z() {
        return this.value.z;
    }
    set z(t) {
        this.value.z = t;
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", s, r);
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), this;
    }
};
var Wr = class extends be {
    constructor(t, r, n, s){
        super(t, r, n);
        this.isColorA = !0;
        this.a = s;
    }
    setRGBA(t, r, n, s) {
        super.setRGB(t, r, n), this.a = s;
    }
    copy(t) {
        return super.copy(t), this.a = "a" in t ? t.a : 1, this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b, this.a);
    }
    get x() {
        return this.r;
    }
    get y() {
        return this.g;
    }
    get z() {
        return this.b;
    }
    get w() {
        return this.a;
    }
    set x(t) {
        this.r = t;
    }
    set y(t) {
        this.g = t;
    }
    set z(t) {
        this.b = t;
    }
    set w(t) {
        this.a = t;
    }
};
var fi = class extends jt {
    constructor(t){
        super("v4");
        this.nodeType = "Vector4";
        this.value = t instanceof Wr ? t : new Wr(t.r, t.g, t.b, t.a);
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format("vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")", s, r);
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), this;
    }
};
var mF = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i, E1 = /[a-z_0-9]+/gi, Ne = class extends Ye {
    constructor(t, r, n, s, o){
        super(o);
        this.src = "";
        this.nodeType = "Function";
        this.useKeywords = !0;
        this.includes = [];
        this.extensions = {};
        this.keywords = {};
        this.isMethod = o === void 0, this.isInterface = !1, this.parse(t, r, n, s);
    }
    getShared(t, r) {
        return !this.isMethod;
    }
    getType(t) {
        return t.getTypeByFormat(this.type);
    }
    getInputByName(t) {
        if (this.inputs) {
            let r = this.inputs.length;
            for(; r--;)if (this.inputs[r].name === t) return this.inputs[r];
        }
    }
    getIncludeByName(t) {
        if (this.includes) {
            let r = this.includes.length;
            for(; r--;)if (this.includes[r].name === t) return this.includes[r];
        }
    }
    generate(t, r, n, s, o) {
        let a, l = 0, c = this.src;
        if (this.includes) for(let u = 0; u < this.includes.length; u++)t.include(this.includes[u], this);
        for(let u6 in this.extensions)t.extensions[u6] = !0;
        let h = [];
        for(; a = E1.exec(this.src);)h.push(a);
        for(let u7 = 0; u7 < h.length; u7++){
            let f = h[u7], d = f[0], p = this.isMethod ? !this.getInputByName(d) : !0, m = d;
            if (this.keywords[d] || this.useKeywords && p && _r.containsKeyword(d)) {
                let g = this.keywords[d];
                if (!g) {
                    let v = _r.getKeywordData(d);
                    v.cache && (g = t.keywords[d]), g = g || _r.getKeyword(d, t), v.cache && (t.keywords[d] = g);
                }
                m = g.build(t);
            }
            d !== m && (c = c.substring(0, f.index + l) + m + c.substring(f.index + d.length + l), l += m.length - d.length), this.getIncludeByName(m) === void 0 && _r.contains(m) && t.include(_r.get(m));
        }
        return r === "source" ? c : this.isMethod ? (this.isInterface || t.include(this, void 0, c), this.name) : t.format("( " + c + " )", this.getType(t), r);
    }
    parse(t, r, n, s) {
        if (this.src = t || "", this.includes = r != null ? r : [], this.extensions = n != null ? n : {}, this.keywords = s != null ? s : {}, this.isMethod) {
            let o = mF.exec(this.src);
            if (this.inputs = [], o && o.length == 4) {
                this.type = o[1], this.name = o[2];
                let a = o[3].match(E1);
                if (a) {
                    let l = 0;
                    for(; l < a.length;){
                        let c = a[l++], h;
                        c === "in" || c === "out" || c === "inout" ? h = a[l++] : (h = c, c = "");
                        let u = a[l++];
                        this.inputs.push({
                            name: u,
                            type: h,
                            qualifier: c
                        });
                    }
                }
                this.isInterface = this.src.indexOf("{") === -1;
            } else this.type = "", this.name = "";
        }
    }
    copy(t) {
        return super.copy(t), this.isMethod = t.isMethod, this.useKeywords = t.useKeywords, t.type !== void 0 && (this.type = t.type), this.parse(t.src, t.includes, t.extensions, t.keywords), this;
    }
    toJSON(t) {
        var n;
        let r = this.getJSONNode(t);
        if (!r) {
            r = this.createJSONNode(t), r.src = this.src, r.isMethod = this.isMethod, r.useKeywords = this.useKeywords, this.isMethod || (r.type = this.type), r.extensions = JSON.parse(JSON.stringify(this.extensions));
            let s = {};
            for(let o in this.keywords)s[o] = this.keywords[o].toJSON(t).uuid;
            if (r.keywords = s, (n = this.includes) != null && n.length) {
                let o = [];
                for(let a = 0; a < this.includes.length; a++)o.push(this.includes[a].toJSON(t).uuid);
                r.includes = o;
            }
            r.isMethod = this.isMethod, r.inputs = this.inputs;
        }
        return r.nodeType = this.nodeType, r;
    }
    fromJSON(t, r) {
        if (super.fromJSON(t, r), t.inputs !== void 0 && (this.inputs = t.inputs), t.isMethod !== void 0 && (this.isMethod = t.isMethod), t.src && (this.src = t.src), t.isMethod && (this.isMethod = t.isMethod), t.useKeywords && (this.useKeywords = t.useKeywords), t.type && (this.type = t.type), t.extensions && (this.extensions = t.extensions), t.keywords && r) {
            this.keywords = {};
            for(let n in t.keywords)this.keywords[n] = r.getNode(t.keywords[n]);
        }
        return t.includes && r && (this.includes = t.includes.map((n)=>r.getNode(n)
        )), this;
    }
};
var gF = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i, mv = class extends Ye {
    constructor(t = "", r){
        super();
        this.src = "";
        this.useDefine = !1;
        this.nodeType = "Const";
        this.parse(t || mv.PI, void 0, void 0, void 0, r);
    }
    getType(t) {
        return t.getTypeByFormat(this.type);
    }
    parse(t, r, n, s, o) {
        this.src = t || "";
        let a, l, c = "", h = gF.exec(t);
        this.useDefine = o != null ? o : this.src.charAt(0) === "#", h && h.length > 1 ? (l = h[1], a = h[2], c = h[3]) : (a = this.src, l = "f"), this.name = a, this.type = l, this.value = c;
    }
    build(t, r) {
        if (r === "source") {
            if (this.value) return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";";
            if (this.useDefine) return this.src;
        }
        return t.include(this), t.format(this.name, this.getType(t), r);
    }
    generate(t, r, n, s, o) {
        return t.format(this.name, this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.parse(t.src, void 0, void 0, void 0, t.useDefine), this;
    }
}, wt = mv;
wt.PI = "PI", wt.PI2 = "PI2", wt.RECIPROCAL_PI = "RECIPROCAL_PI", wt.RECIPROCAL_PI2 = "RECIPROCAL_PI2", wt.LOG2 = "LOG2", wt.EPSILON = "EPSILON";
var yF = new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim"), vF = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim"), Fl = class extends Ye {
    constructor(t = ""){
        super();
        this.inputs = [];
        this.src = "";
        this.nodeType = "Struct";
        this.parse(t);
    }
    getType(t) {
        return t.getTypeByFormat(this.name);
    }
    getInputByName(t) {
        let r = this.inputs.length;
        for(; r--;)if (this.inputs[r].name === t) return this.inputs[r];
    }
    generate(t, r, n, s, o) {
        return r === "source" ? this.src + ";" : t.format("( " + this.src + " )", this.getType(t), r);
    }
    parse(t = "") {
        this.src = t, this.inputs = [];
        let r = yF.exec(t);
        if (r) {
            let n = r[2], s;
            for(; s = vF.exec(n);)this.inputs.push({
                type: s[1],
                name: s[2]
            });
            this.name = r[1];
        } else this.name = "";
        this.type = this.name;
    }
};
var Ul = class extends Ye {
    constructor(t){
        super("v2", {
            shared: !1
        });
        this.nodeType = "UV";
        this.index = t != null ? t : 0;
    }
    generate(t, r) {
        t.requires.uv[this.index] = !0;
        let n = this.index > 0 ? this.index + 1 : "", s = t.isShader("vertex") ? "uv" + n : "vUv" + n;
        return t.format(s, this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.index = t.index, this;
    }
    toJSON(t) {
        let r = this.getJSONNode(t);
        return r || (r = this.createJSONNode(t), r.index = this.index), r.nodeType = this.nodeType, r;
    }
    fromJSON(t, r) {
        return super.fromJSON(t, r), t.index && (this.index = t.index), this;
    }
};
_r.addKeyword("uv", function() {
    return new Ul;
});
_r.addKeyword("uv2", function() {
    return new Ul(1);
});
var Qo = class extends Ye {
    constructor(t = new We, r){
        super("v4");
        this.nodeType = "ColorSpace";
        this.factor = new We;
        this.input = t, this.method = r != null ? r : Qo.LINEAR_TO_LINEAR, this.hashProperties = [
            "method"
        ];
    }
    static getEncodingComponents(t) {
        switch(t){
            case gn:
                return [
                    "Linear"
                ];
            case je:
                return [
                    "sRGB"
                ];
            default:
                return [];
        }
    }
    generate(t, r) {
        var l;
        let n = this.input.build(t, "v4"), s = this.getType(t), o = Qo.Nodes[this.method], a = t.include(o);
        if (a === Qo.LINEAR_TO_LINEAR) return t.format(n, s, r);
        if (((l = o.inputs) == null ? void 0 : l.length) === 2) {
            let c = this.factor.build(t, "f");
            return t.format(a + "( " + n + ", " + c + " )", s, r);
        } else return t.format(a + "( " + n + " )", s, r);
    }
    fromEncoding(t) {
        let r = Qo.getEncodingComponents(t);
        this.method = "LinearTo" + r[0], this.factor = r[1];
    }
    fromDecoding(t) {
        let r = Qo.getEncodingComponents(t);
        this.method = r[0] + "ToLinear", this.factor = r[1];
    }
    copy(t) {
        return super.copy(t), this.input.copy(t.input), this.method = t.method, this.factor.copy(t.factor), this;
    }
}, dn = Qo;
dn.Nodes = {
    LinearToLinear: new Ne([
        "vec4 LinearToLinear( in vec4 value ) {",
        "	return value;",
        "}"
    ].join(`
`)),
    sRGBToLinear: new Ne([
        "vec4 sRGBToLinear( in vec4 value ) {",
        "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
        "}"
    ].join(`
`)),
    LinearTosRGB: new Ne([
        "vec4 LinearTosRGB( in vec4 value ) {",
        "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
        "}"
    ].join(`
`))
}, dn.LINEAR_TO_LINEAR = "LinearToLinear", dn.SRGB_TO_LINEAR = "sRGBToLinear", dn.LINEAR_TO_SRGB = "LinearTosRGB";
var Gt = class extends Ne {
    constructor(t = "", r, n, s, o){
        super(t, o, s, n, r);
        this.nodeType = "Expression";
    }
};
var Fi = class extends Dt {
    toJSON(e) {
        let t = super.toJSON(e), r = e === void 0 || typeof e == "string";
        if (this.image !== void 0 && !r) {
            let n = this.image;
            if (Array.isArray(n)) {
                e.images[n.uuid].url = [];
                for(let s = 0; s < n.length; s++)e.images[n.uuid].url[s] = _1(n[s]);
            } else e.images[n.uuid].url = _1(n);
        }
        return t;
    }
};
function _1(i) {
    return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? xF(i) : (console.warn("THREE.Texture: Unable to serialize Texture."), "");
}
var zl;
function xF(i) {
    if (/^data:/i.test(i.src)) return i.src;
    let e;
    if (i instanceof HTMLCanvasElement) e = i;
    else {
        zl === void 0 && (zl = document.createElement("canvas")), zl.width = i.width, zl.height = i.height;
        let r = zl.getContext("2d");
        i instanceof ImageData ? r.putImageData(i, 0, 0) : r.drawImage(i, 0, 0, i.width, i.height), e = zl;
    }
    let t = i.src.startsWith("blob:") ? i.fileName : i.src;
    return /\.jpe?g$/i.test(t) ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png");
}
var jr = class extends jt {
    constructor(t = new Fi, r, n, s){
        super("v4", {
            shared: !0
        });
        this.nodeType = "Texture";
        this.value = t, this.uv = r != null ? r : new Ul, this.bias = n, this.project = s !== void 0 ? s : !1;
    }
    getTexture(t, r) {
        return super.generate(t, r, this.value.uuid, "t");
    }
    generate(t, r) {
        var u;
        if (r === "sampler2D") return this.getTexture(t, r);
        let n = this.getTexture(t, r), s = this.uv.build(t, this.project ? "v4" : "v2"), o = this.bias ? this.bias.build(t, "f") : void 0;
        o === void 0 && t.context.bias && (o = t.context.bias.setTexture(this).build(t, "f"));
        let a, l;
        this.project ? a = "texture2DProj" : a = o ? "tex2DBias" : "tex2D", o ? l = a + "( " + n + ", " + s + ", " + o + " )" : l = a + "( " + n + ", " + s + " )";
        let c = {
            include: t.isShader("vertex"),
            ignoreCache: !0
        }, h = this.getType(t);
        return t.addContext(c), this.colorSpace = (u = this.colorSpace) != null ? u : new dn(new Gt("", h)), this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(l), l = this.colorSpace.build(t, h), t.removeContext(), t.format(l, h, r);
    }
    copy(t) {
        return super.copy(t), t.value.isRenderTargetTexture ? this.value = t.value : this.value.copy(t.value), this.uv.copy(t.uv), t.bias ? this.bias ? this.bias.copy(t.bias) : this.bias = t.bias.clone() : this.bias = void 0, t.colorSpace ? this.colorSpace ? this.colorSpace.copy(t.colorSpace) : this.colorSpace = t.colorSpace.clone() : this.colorSpace = void 0, this.project = t.project, t.value.isRenderTargetTexture || (this.value.updateMatrix(), this.value.needsUpdate = !0), this;
    }
};
var Be = class extends jt {
    constructor(t){
        super("f");
        this.nodeType = "Float";
        this.value = t != null ? t : 0;
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format(this.value + (this.value % 1 ? "" : ".0"), s, r);
    }
    copy(t) {
        return super.copy(t), this.value = t.value, this;
    }
};
var Jh = class extends Ye {
    constructor(t, r){
        super();
        this.inputs = [];
        this.nodeType = "FunctionCall";
        this.value = t, this.inputs = r != null ? r : [];
    }
    getFunction() {
        return this.value;
    }
    getType(t) {
        return this.value.getType(t);
    }
    generate(t, r, n, s, o) {
        s = this.getType(t);
        let a = this.value, l = a.build(t, r) + "( ", c = [];
        if (a.inputs) {
            for(let h = 0; h < a.inputs.length; h++){
                let u = a.inputs[h], f = this.inputs[h] || this.inputs[u.name];
                c.push(f.build(t, t.getTypeByFormat(u.type)));
            }
            l += c.join(", ") + " )";
        }
        return t.format(l, s, r);
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), this.inputs = t.inputs.map((r)=>r.clone()
        ), this;
    }
    toJSON(t) {
        var n;
        let r = this.getJSONNode(t);
        if (!r) {
            let s = this.value;
            if (r = this.createJSONNode(t), r.value = this.value.toJSON(t).uuid, (n = s.inputs) != null && n.length) {
                r.inputs = {};
                for(let o = 0; o < s.inputs.length; o++){
                    let a = s.inputs[o], l = this.inputs[o];
                    r.inputs[a.name] = l.toJSON(t).uuid;
                }
            }
        }
        return r;
    }
};
var gv = class extends Ye {
    constructor(t = new We, r = new We, n = gv.ADD){
        super();
        this.nodeType = "Operator";
        this.type = t.type, this.a = t, this.b = r, this.op = n;
    }
    getType(t) {
        let r = this.a.getType(t), n = this.b.getType(t);
        return t.isTypeMatrix(r) ? "v4" : t.getTypeLength(n) > t.getTypeLength(r) ? n : r;
    }
    generate(t, r) {
        let n = this.getType(t);
        this.type = n;
        let s = this.a.build(t, n), o = this.b.build(t, n);
        return t.format("( " + s + " " + this.op + " " + o + " )", n, r);
    }
    copy(t) {
        return super.copy(t), this.a.copy(t.a), this.b.copy(t.b), this.op = t.op, this;
    }
}, Mn = gv;
Mn.ADD = "+", Mn.SUB = "-", Mn.MUL = "*", Mn.DIV = "/";
var Nt = class extends Ye {
    constructor(t = new We, r = Nt.ABS, n, s){
        super();
        this.nodeType = "Math";
        this.a = t, typeof r != "string" ? this.b = r : s = r, typeof n != "string" ? this.c = n : s = n, this.method = s, this.hashProperties = [
            "method"
        ];
    }
    getNumInputs(t) {
        switch(this.method){
            case Nt.MIX:
            case Nt.CLAMP:
            case Nt.REFRACT:
            case Nt.SMOOTHSTEP:
            case Nt.FACEFORWARD:
                return 3;
            case Nt.MIN:
            case Nt.MAX:
            case Nt.MOD:
            case Nt.STEP:
            case Nt.REFLECT:
            case Nt.DISTANCE:
            case Nt.DOT:
            case Nt.CROSS:
            case Nt.POW:
                return 2;
            default:
                return 1;
        }
    }
    getInputType(t) {
        let r = t.getTypeLength(this.a.getType(t)), n = this.b ? t.getTypeLength(this.b.getType(t)) : 0, s = this.c ? t.getTypeLength(this.c.getType(t)) : 0;
        return r > n && r > s ? this.a.getType(t) : n > s ? this.b.getType(t) : this.c.getType(t);
    }
    getType(t) {
        switch(this.method){
            case Nt.LENGTH:
            case Nt.DISTANCE:
            case Nt.DOT:
                return "f";
            case Nt.CROSS:
                return "v3";
        }
        return this.getInputType(t);
    }
    generate(t, r) {
        let n, s, o, a = this.a ? t.getTypeLength(this.a.getType(t)) : 0, l = this.b ? t.getTypeLength(this.b.getType(t)) : 0, c = this.c ? t.getTypeLength(this.c.getType(t)) : 0, h = this.getInputType(t), u = this.getType(t);
        switch(this.type = u, this.method){
            case Nt.NEGATE:
                return t.format("( -" + this.a.build(t, h) + " )", h, r);
            case Nt.INVERT:
                return t.format("( 1.0 - " + this.a.build(t, h) + " )", h, r);
            case Nt.CROSS:
                n = this.a.build(t, "v3"), s = this.b.build(t, "v3");
                break;
            case Nt.STEP:
                n = this.a.build(t, a === 1 ? "f" : h), s = this.b.build(t, h);
                break;
            case Nt.MIN:
            case Nt.MAX:
            case Nt.MOD:
                n = this.a.build(t, h), s = this.b.build(t, l === 1 ? "f" : h);
                break;
            case Nt.REFRACT:
                n = this.a.build(t, h), s = this.b.build(t, h), o = this.c.build(t, "f");
                break;
            case Nt.MIX:
                n = this.a.build(t, h), s = this.b.build(t, h), o = this.c.build(t, c === 1 ? "f" : h);
                break;
            default:
                n = this.a.build(t, h), this.b && (s = this.b.build(t, h)), this.c && (o = this.c.build(t, h));
                break;
        }
        let f = [];
        f.push(n), s && f.push(s), o && f.push(o);
        let d = this.getNumInputs(t);
        if (f.length !== d) throw Error(`Arguments not match used in "${this.method}". Require ${d}, currently ${f.length}.`);
        return t.format(this.method + "( " + f.join(", ") + " )", u, r);
    }
    copy(t) {
        return super.copy(t), this.a.copy(t.a), this.b = t.b instanceof We ? t.b.clone() : t.b, this.c = t.c instanceof We ? t.c.clone() : t.c, this.method = t.method, this;
    }
}, tt = Nt;
tt.RAD = "radians", tt.DEG = "degrees", tt.EXP = "exp", tt.EXP2 = "exp2", tt.LOG = "log", tt.LOG2 = "log2", tt.SQRT = "sqrt", tt.INV_SQRT = "inversesqrt", tt.FLOOR = "floor", tt.CEIL = "ceil", tt.NORMALIZE = "normalize", tt.FRACT = "fract", tt.SATURATE = "saturate", tt.SIN = "sin", tt.COS = "cos", tt.TAN = "tan", tt.ASIN = "asin", tt.ACOS = "acos", tt.ARCTAN = "atan", tt.ABS = "abs", tt.SIGN = "sign", tt.LENGTH = "length", tt.NEGATE = "negate", tt.INVERT = "invert", tt.MIN = "min", tt.MAX = "max", tt.MOD = "mod", tt.STEP = "step", tt.REFLECT = "reflect", tt.DISTANCE = "distance", tt.DOT = "dot", tt.CROSS = "cross", tt.POW = "pow", tt.MIX = "mix", tt.CLAMP = "clamp", tt.REFRACT = "refract", tt.SMOOTHSTEP = "smoothstep", tt.FACEFORWARD = "faceforward";
var Gl = class extends Ye {
    constructor(t = new We, r = new We, n = new We){
        super("v4");
        this.nodeType = "TextureCubeUV";
        this.value = t, this.uv = r, this.bias = n;
    }
    bilinearCubeUV(t, r, n, s) {
        var c, h, u, f;
        let o = new Jh(Gl.Nodes.bilinearCubeUV, [
            r,
            n,
            s
        ]);
        this.colorSpaceTL = (c = this.colorSpaceTL) != null ? c : new dn(new Gt("", "v4")), this.colorSpaceTL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(o.build(t) + ".tl"), this.colorSpaceTR = (h = this.colorSpaceTR) != null ? h : new dn(new Gt("", "v4")), this.colorSpaceTR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(o.build(t) + ".tr"), this.colorSpaceBL = (u = this.colorSpaceBL) != null ? u : new dn(new Gt("", "v4")), this.colorSpaceBL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(o.build(t) + ".bl"), this.colorSpaceBR = (f = this.colorSpaceBR) != null ? f : new dn(new Gt("", "v4")), this.colorSpaceBR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(o.build(t) + ".br");
        let a = {
            include: t.isShader("vertex"),
            ignoreCache: !0
        };
        t.addContext(a), this.colorSpaceTLExp = new Gt(this.colorSpaceTL.build(t, "v4"), "v4"), this.colorSpaceTRExp = new Gt(this.colorSpaceTR.build(t, "v4"), "v4"), this.colorSpaceBLExp = new Gt(this.colorSpaceBL.build(t, "v4"), "v4"), this.colorSpaceBRExp = new Gt(this.colorSpaceBR.build(t, "v4"), "v4"), t.removeContext();
        let l = new Gt("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4");
        return l.keywords.cubeUV_TL = this.colorSpaceTLExp, l.keywords.cubeUV_TR = this.colorSpaceTRExp, l.keywords.cubeUV_BL = this.colorSpaceBLExp, l.keywords.cubeUV_BR = this.colorSpaceBRExp, l.keywords.cubeUV = o, l;
    }
    generate(t, r) {
        if (t.isShader("fragment")) {
            let n = this.uv, s = this.bias || t.context.roughness, o = new Jh(Gl.Nodes.roughnessToMip, [
                s
            ]), a = new tt(o, Gl.Nodes.m0, Gl.Nodes.cubeUV_maxMipLevel, tt.CLAMP), l = new tt(a, tt.FLOOR), c = new tt(a, tt.FRACT), h = this.bilinearCubeUV(t, this.value, n, l), u = this.bilinearCubeUV(t, this.value, n, new Mn(l, new Be(1).setReadonly(!0), Mn.ADD)), f = new tt(h, u, c, tt.MIX);
            return t.format(f.build(t), "v4", r);
        } else return console.warn("TextureCubeUVNode is not compatible with " + t.shader + " shader."), t.format("vec4( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.uv.copy(t.uv), this.bias.copy(t.bias), this.value.copy(t.value), t.colorSpaceTL ? this.colorSpaceTL ? this.colorSpaceTL.copy(t.colorSpaceTL) : this.colorSpaceTL = t.colorSpaceTL.clone() : this.colorSpaceTL = void 0, t.colorSpaceTR ? this.colorSpaceTR ? this.colorSpaceTR.copy(t.colorSpaceTR) : this.colorSpaceTR = t.colorSpaceTR.clone() : this.colorSpaceTR = void 0, t.colorSpaceBL ? this.colorSpaceBL ? this.colorSpaceBL.copy(t.colorSpaceBL) : this.colorSpaceBL = t.colorSpaceBL.clone() : this.colorSpaceBL = void 0, t.colorSpaceBR ? this.colorSpaceBR ? this.colorSpaceBR.copy(t.colorSpaceBR) : this.colorSpaceBR = t.colorSpaceBR.clone() : this.colorSpaceBR = void 0, t.colorSpaceTLExp ? this.colorSpaceTLExp ? this.colorSpaceTLExp.copy(t.colorSpaceTLExp) : this.colorSpaceTLExp = t.colorSpaceTLExp.clone() : this.colorSpaceTLExp = void 0, t.colorSpaceTRExp ? this.colorSpaceTRExp ? this.colorSpaceTRExp.copy(t.colorSpaceTRExp) : this.colorSpaceTRExp = t.colorSpaceTRExp.clone() : this.colorSpaceTRExp = void 0, t.colorSpaceBLExp ? this.colorSpaceBLExp ? this.colorSpaceBLExp.copy(t.colorSpaceBLExp) : this.colorSpaceBLExp = t.colorSpaceBLExp.clone() : this.colorSpaceBLExp = void 0, t.colorSpaceBRExp ? this.colorSpaceBRExp ? this.colorSpaceBRExp.copy(t.colorSpaceBRExp) : this.colorSpaceBRExp = t.colorSpaceBRExp.clone() : this.colorSpaceBRExp = void 0, this;
    }
}, kl = Gl;
kl.Nodes = function() {
    let t = new Fl(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`), r = new wt("float cubeUV_maxMipLevel 8.0", !0), n = new wt("float cubeUV_minMipLevel 4.0", !0), s = new wt("float cubeUV_maxTileSize 256.0", !0), o = new wt("float cubeUV_minTileSize 16.0", !0), a = new Ne(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
    a.useKeywords = !1;
    let l = new Ne(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
    l.useKeywords = !1;
    let c = new Ne(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [
        t,
        a,
        l,
        r,
        n,
        s,
        o
    ]);
    c.useKeywords = !1;
    let h = new wt("float r0 1.0", !0), u = new wt("float v0 0.339", !0), f = new wt("float m0 -2.0", !0), d = new wt("float r1 0.8", !0), p = new wt("float v1 0.276", !0), m = new wt("float m1 -1.0", !0), g = new wt("float r4 0.4", !0), v = new wt("float v4 0.046", !0), y = new wt("float m4 2.0", !0), w = new wt("float r5 0.305", !0), b = new wt("float v5 0.016", !0), S = new wt("float m5 3.0", !0), T = new wt("float r6 0.21", !0), A = new wt("float v6 0.0038", !0), x = new wt("float m6 4.0", !0), E = [
        h,
        u,
        f,
        d,
        p,
        m,
        g,
        v,
        y,
        w,
        b,
        S,
        T,
        A,
        x
    ], _ = new Ne(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, E);
    return {
        bilinearCubeUV: c,
        roughnessToMip: _,
        m0: f,
        cubeUV_maxMipLevel: r
    };
}();
var Jo = class extends Ye {
    constructor(t){
        super("v3");
        this.nodeType = "Normal";
        this.scope = t != null ? t : Jo.VIEW;
    }
    getShared() {
        return this.scope === Jo.WORLD;
    }
    build(t, r, n, s) {
        let o = t.context[this.scope + "Normal"];
        return o ? o.build(t, r, n, s) : super.build(t, r, n);
    }
    generate(t, r, n, s, o) {
        let a;
        switch(this.scope){
            case Jo.VIEW:
                t.isShader("vertex") ? a = "transformedNormal" : a = "geometryNormal";
                break;
            case Jo.LOCAL:
                t.isShader("vertex") ? a = "objectNormal" : (t.requires.normal = !0, a = "vObjectNormal");
                break;
            case Jo.WORLD:
                t.isShader("vertex") ? a = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (t.requires.worldNormal = !0, a = "vWNormal");
                break;
        }
        return t.format(a, this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.scope = t.scope, this;
    }
    toJSON(t) {
        let r = this.getJSONNode(t);
        return r || (r = this.createJSONNode(t), r.scope = this.scope), r.nodeType = this.nodeType, r;
    }
    fromJSON(t, r) {
        return super.fromJSON(t, r), t.scope && (this.scope = t.scope), this;
    }
}, Fr = Jo;
Fr.LOCAL = "local", Fr.WORLD = "world", Fr.VIEW = "view", Fr.NORMAL = "normal";
_r.addKeyword("viewNormal", function() {
    return new Fr(Fr.VIEW);
});
_r.addKeyword("localNormal", function() {
    return new Fr(Fr.NORMAL);
});
_r.addKeyword("worldNormal", function() {
    return new Fr(Fr.WORLD);
});
var Ui = class extends Ye {
    constructor(t){
        super("v3");
        this.nodeType = "Position";
        this.scope = t != null ? t : Ui.LOCAL;
    }
    getType() {
        switch(this.scope){
            case Ui.PROJECTION:
                return "v4";
        }
        return this.type;
    }
    getShader() {
        switch(this.scope){
            case Ui.LOCAL:
            case Ui.WORLD:
                return !1;
        }
        return !0;
    }
    generate(t, r, n, s, o) {
        let a;
        switch(this.scope){
            case Ui.LOCAL:
                t.isShader("vertex") ? a = "transformed" : (t.requires.position = !0, a = "vPosition");
                break;
            case Ui.WORLD:
                if (t.isShader("vertex")) return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
                t.requires.worldPosition = !0, a = "vWPosition";
                break;
            case Ui.VIEW:
                a = t.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
                break;
            case Ui.PROJECTION:
                a = t.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )";
                break;
        }
        return t.format(a, this.getType(), r);
    }
    copy(t) {
        return super.copy(t), this.scope = t.scope, this;
    }
    toJSON(t) {
        let r = this.getJSONNode(t);
        return r || (r = this.createJSONNode(t), r.scope = this.scope), r.nodeType = this.nodeType, r;
    }
    fromJSON(t, r) {
        return super.fromJSON(t, r), t.scope && (this.scope = t.scope), this;
    }
}, qr = Ui;
qr.LOCAL = "local", qr.WORLD = "world", qr.VIEW = "view", qr.PROJECTION = "projection";
_r.addKeyword("position", function() {
    return new qr;
});
_r.addKeyword("worldPosition", function() {
    return new qr(qr.WORLD);
});
_r.addKeyword("viewPosition", function() {
    return new qr(qr.VIEW);
});
var di = class extends Ye {
    constructor(t){
        super("v3");
        this.nodeType = "Reflect";
        this.scope = t != null ? t : di.CUBE;
    }
    getUnique(t) {
        return !t.context.viewNormal;
    }
    getType() {
        switch(this.scope){
            case di.SPHERE:
                return "v2";
        }
        return this.type;
    }
    generate(t, r) {
        let n = this.getUnique(t);
        if (t.isShader("fragment")) {
            let s;
            switch(this.scope){
                case di.VECTOR:
                    {
                        let o = new Fr(Fr.VIEW), a = t.context.roughness, l = o.build(t, "v3"), c = new qr(qr.VIEW).build(t, "v3"), h = a ? a.build(t, "f") : void 0, u = `reflect( -normalize( ${c} ), ${l} )`;
                        h && (u = `normalize( mix( ${u}, ${l}, ${h} * ${h} ) )`);
                        let f = `inverseTransformDirection( ${u}, viewMatrix )`;
                        n ? (t.addNodeCode(`vec3 reflectVec = ${f};`), s = "reflectVec") : s = f;
                        break;
                    }
                case di.CUBE:
                    {
                        let o = new di(di.VECTOR).build(t, "v3"), a = "vec3( -" + o + ".x, " + o + ".yz )";
                        n ? (t.addNodeCode(`vec3 reflectCubeVec = ${a};`), s = "reflectCubeVec") : s = a;
                        break;
                    }
                case di.SPHERE:
                    {
                        let o = new di(di.VECTOR).build(t, "v3"), a = "normalize( ( viewMatrix * vec4( " + o + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
                        n ? (t.addNodeCode(`vec2 reflectSphereVec = ${a};`), s = "reflectSphereVec") : s = a;
                        break;
                    }
            }
            return t.format(s, this.getType(), r);
        } else return console.warn("ReflectNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.type, r);
    }
    copy(t) {
        return super.copy(t), this.scope = t.scope, this;
    }
    toJSON(t) {
        let r = this.getJSONNode(t);
        return r || (r = this.createJSONNode(t), r.scope = this.scope), r.nodeType = this.nodeType, r;
    }
    fromJSON(t, r) {
        return super.fromJSON(t, r), t.scope && (this.scope = t.scope), this;
    }
}, zi = di;
zi.CUBE = "cube", zi.SPHERE = "sphere", zi.VECTOR = "vector";
var wp = class extends Ye {
    constructor(t = new jr, r, n){
        super("v4");
        this.nodeType = "TextureCube";
        this.value = t, this.radianceNode = new kl(this.value, r != null ? r : new zi(zi.VECTOR), n), this.irradianceNode = new kl(this.value, new Fr(Fr.WORLD), new Be(1).setReadonly(!0));
    }
    generate(t, r) {
        return t.isShader("fragment") ? (t.require("irradiance"), t.context.bias && t.context.bias.setTexture(this.value), (t.slot === "irradiance" ? this.irradianceNode : this.radianceNode).build(t, r)) : (console.warn("TextureCubeNode is not compatible with " + t.shader + " shader."), t.format("vec4( 0.0 )", this.getType(t), r));
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), this.radianceNode.copy(t.radianceNode), this.irradianceNode.copy(t.irradianceNode), this;
    }
};
var Sp = class extends jt {
    constructor(t = new Fs, r, n){
        super("v4", {
            shared: !0
        });
        this.nodeType = "CubeTexture";
        this.value = t, this.uv = r != null ? r : new zi, this.bias = n;
    }
    getTexture(t, r) {
        return super.generate(t, r, this.value.uuid, "tc");
    }
    generate(t, r) {
        var h, u;
        if (r === "samplerCube") return this.getTexture(t, r);
        let n = this.getTexture(t, r), s = (h = this.uv) == null ? void 0 : h.build(t, "v3"), o = this.bias ? this.bias.build(t, "f") : void 0;
        o === void 0 && t.context.bias && (o = t.context.bias.setTexture(this).build(t, "f"));
        let a;
        o ? a = "texCubeBias( " + n + ", " + s + ", " + o + " )" : a = "texCube( " + n + ", " + s + " )";
        let l = {
            include: t.isShader("vertex"),
            ignoreCache: !0
        }, c = this.getType(t);
        return t.addContext(l), this.colorSpace = (u = this.colorSpace) != null ? u : new dn(new Gt("", c)), this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(a), a = this.colorSpace.build(t, c), t.removeContext(), t.format(a, c, r);
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), t.uv ? this.uv ? this.uv.copy(t.uv) : this.uv = t.uv.clone() : this.uv = void 0, t.bias ? this.bias ? this.bias.copy(t.bias) : this.bias = t.bias.clone() : this.bias = void 0, this;
    }
};
var C1 = [
    "x",
    "y",
    "z",
    "w"
], bF = [
    "float",
    "vec2",
    "vec3",
    "vec4"
], wF = {
    float: "f",
    vec2: "v2",
    vec3: "v3",
    vec4: "v4",
    mat4: "v4",
    int: "i",
    bool: "b",
    "float[]": "f[]",
    "vec4[]": "v4[]"
}, SF = {
    t: "sampler2D",
    tc: "samplerCube",
    b: "bool",
    i: "int",
    f: "float",
    c: "vec3",
    v2: "vec2",
    v3: "vec3",
    v4: "vec4",
    m3: "mat3",
    m4: "mat4",
    "f[]": "float[]",
    "v4[]": "vec4[]"
}, Mp = class {
    constructor(){
        this.includes = {
            consts: {},
            functions: {},
            structs: {}
        };
        this.cache = "";
        this.slot = "";
        this.shader = "";
        this.context = {};
        this.getIncludesCode = function() {
            function e(t, r) {
                return t.deps.length - r.deps.length;
            }
            return function(r, n) {
                let s = this.getIncludes(r, n);
                if (!s) return "";
                let o = "";
                s = s.sort(e);
                for(let a = 0; a < s.length; a++)s[a].src && (o += s[a].src + `
`);
                return o;
            };
        }();
        this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.requires = {
            uv: [],
            color: [],
            lights: !1,
            fog: !1,
            transparent: !1,
            irradiance: !1,
            position: !1,
            worldPosition: !1,
            normal: !1,
            worldNormal: !1,
            vWorldViewDir: !1,
            modelMatrix: !1,
            viewMatrix: !1,
            projectionMatrix: !1
        }, this.includes = {
            consts: [],
            functions: [],
            structs: []
        }, this.attributes = {}, this.prefixCode = [
            "#ifdef TEXTURE_LOD_EXT",
            "	#define texCube(a, b) textureCube(a, b)",
            "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)",
            "	#define tex2D(a, b) texture2D(a, b)",
            "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)",
            "#else",
            "	#define texCube(a, b) textureCube(a, b)",
            "	#define texCubeBias(a, b, c) textureCube(a, b, c)",
            "	#define tex2D(a, b) texture2D(a, b)",
            "	#define tex2DBias(a, b, c) texture2D(a, b, c)",
            "#endif",
            `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,
            "#include <packing>",
            "#include <common>"
        ].join(`
`), this.parsCode = {
            vertex: [
                "float neighbor_offset = 0.0001;",
                ""
            ].join(`
`),
            fragment: [
                "float accumAlpha = 0.0;",
                `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,
                ""
            ].join(`
`)
        }, this.code = {
            vertex: "",
            fragment: ""
        }, this.nodeCode = {
            vertex: "",
            fragment: ""
        }, this.resultCode = {
            vertex: "",
            fragment: ""
        }, this.finalCode = {
            vertex: "",
            fragment: ""
        }, this.inputs = {
            uniforms: {
                list: [],
                vertex: [],
                fragment: []
            },
            arrayUniforms: {
                list: [],
                vertex: [],
                fragment: []
            },
            vars: {
                varying: [],
                vertex: [],
                fragment: []
            }
        }, this.defines = {}, this.uniforms = {}, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.updaters = [], this.nodes = [], this.analyzing = !1;
    }
    build(e, t) {
        this.buildShader("vertex", e), this.buildShader("fragment", t);
        for(let r = 0; r < this.requires.uv.length; r++)if (this.requires.uv[r]) {
            let n = r > 0 ? r + 1 : "";
            this.addVaryCode("varying vec2 vUv" + n + ";"), r > 0 && this.addVertexParsCode("attribute vec2 uv" + n + ";"), this.addVertexFinalCode("vUv" + n + " = uv" + n + ";");
        }
        return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition && (this.addVaryCode("varying vec3 vWPosition;"), this.addVertexFinalCode("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;")), this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.modelMatrix && this.addFragmentParsCode("uniform mat4 modelMatrix;"), this.requires.viewMatrix && this.addFragmentParsCode("uniform mat4 viewMatrix;"), this.requires.projectionMatrix && this.addFragmentParsCode("uniform mat4 projectionMatrix;"), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this;
    }
    buildShader(e, t) {
        this.resultCode[e] = t.build(this.setShader(e), "v4");
    }
    setMaterial(e, t) {
        return this.material = e, this.renderer = t, this.requires.lights = e.lights, this.requires.fog = e.fog, this.mergeDefines(e.defines), this;
    }
    addFlow(e, t, r) {
        return this.addSlot(e).addCache(t).addContext(r);
    }
    removeFlow() {
        return this.removeSlot().removeCache().removeContext();
    }
    addCache(e) {
        return this.cache = e != null ? e : "", this.caches.push(this.cache), this;
    }
    removeCache() {
        return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this;
    }
    addContext(e) {
        return this.context = Object.assign({}, this.context, e), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this;
    }
    removeContext() {
        return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this;
    }
    addSlot(e) {
        return this.slot = e || "", this.slots.push(this.slot), this;
    }
    removeSlot() {
        return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this;
    }
    addFragmentVariable(e, t) {
        this.fragmentVariables[e] === void 0 && (this.addFragmentCode(`${t} ${e};`), this.fragmentVariables[e] = "");
    }
    addVertexCode(e) {
        this.addCode(e, "vertex");
    }
    addFragmentCode(e) {
        this.addCode(e, "fragment");
    }
    addCode(e, t) {
        this.code[t != null ? t : this.shader] += e + `
`;
    }
    addVertexNodeCode(e) {
        this.addNodeCode(e, "vertex");
    }
    addFragmentNodeCode(e) {
        this.addNodeCode(e, "fragment");
    }
    addNodeCode(e, t) {
        this.nodeCode[t != null ? t : this.shader] += e + `
`;
    }
    clearNodeCode(e) {
        e = e != null ? e : this.shader;
        let t = this.nodeCode[e];
        return this.nodeCode[e] = "", t;
    }
    clearVertexNodeCode() {
        return this.clearNodeCode("vertex");
    }
    clearFragmentNodeCode() {
        return this.clearNodeCode("fragment");
    }
    addVertexFinalCode(e) {
        this.addFinalCode(e, "vertex");
    }
    addFragmentFinalCode(e) {
        this.addFinalCode(e, "fragment");
    }
    addFinalCode(e, t) {
        this.finalCode[t != null ? t : this.shader] += e + `
`;
    }
    addVertexParsCode(e) {
        this.addParsCode(e, "vertex");
    }
    addFragmentParsCode(e) {
        this.addParsCode(e, "fragment");
    }
    addParsCode(e, t) {
        this.parsCode[t != null ? t : this.shader] += e + `
`;
    }
    addVaryCode(e) {
        this.addVertexParsCode(e), this.addFragmentParsCode(e);
    }
    isCache(e) {
        return this.caches.indexOf(e) !== -1;
    }
    isSlot(e) {
        return this.slots.indexOf(e) !== -1;
    }
    define(e, t) {
        this.defines[e] = t === void 0 ? 1 : t;
    }
    require(e) {
        this.requires[e] = !0;
    }
    isDefined(e) {
        return this.defines[e] !== void 0;
    }
    getVar(e, t, r, n = "varying", s = "V", o = "") {
        let a = this.getVars(n), l = a[e];
        if (!l) {
            let c = a.length;
            l = {
                name: r || "node" + s + c + (o ? "_" + o : ""),
                type: t
            }, a.push(l), a[e] = l;
        }
        return l;
    }
    getTempVar(e, t, r, n) {
        return this.getVar(e, t, r, this.shader, "T", n);
    }
    getAttribute(e, t) {
        if (!this.attributes[e]) {
            let r = this.getVar(e, t);
            this.addVertexParsCode("attribute " + t + " " + e + ";"), this.addVertexFinalCode(r.name + " = " + e + ";"), this.attributes[e] = {
                varying: r,
                name: e,
                type: t
            };
        }
        return this.attributes[e];
    }
    getCode(e) {
        return [
            this.prefixCode,
            this.parsCode[e],
            this.getVarListCode(this.getVars("varying"), "varying"),
            this.getVarListCode(this.inputs.uniforms[e], "uniform"),
            this.getVarListCode(this.inputs.arrayUniforms[e], "uniform"),
            this.getIncludesCode("consts", e),
            this.getIncludesCode("structs", e),
            this.getIncludesCode("functions", e),
            "void main() {",
            this.getVarListCode(this.getVars(e)),
            this.code[e],
            this.resultCode[e],
            this.finalCode[e],
            "}"
        ].join(`
`);
    }
    getVarListCode(e, t) {
        t = t != null ? t : "";
        let r = "";
        for(let n = 0, s = e.length; n < s; ++n){
            let o = e[n], a = o.type, l = o.name, c = o.size, h = this.getFormatByType(a);
            if (h === void 0) throw new Error("Node pars " + h + " not found.");
            h.includes("[]") ? r += t + " " + h.substring(0, h.length - 2) + " " + l + `[${c}];
` : r += t + " " + h + " " + l + `;
`;
        }
        return r;
    }
    getVars(e) {
        return this.inputs.vars[e != null ? e : this.shader];
    }
    getNodeData(e) {
        let t = e instanceof We ? e.uuid : e;
        return this.nodeData[t] = this.nodeData[t] || {};
    }
    createUniform(e, t, r, n, s, o) {
        if (t.includes("[]")) {
            let a = this.inputs.arrayUniforms, l = a.list.length, c = new Qh({
                type: t,
                size: r.size,
                name: n || "nodeUA" + l + (o ? "_" + o : ""),
                node: r,
                needsUpdate: s
            });
            return a.list.push(c), a[e].push(c), a[e][c.name] = c, this.uniforms[c.name] = c, c;
        } else {
            let a = this.inputs.uniforms, l = a.list.length, c = new Qh({
                type: t,
                name: n || "nodeU" + l + (o ? "_" + o : ""),
                node: r,
                needsUpdate: s
            });
            return a.list.push(c), a[e].push(c), a[e][c.name] = c, this.uniforms[c.name] = c, c;
        }
    }
    createVertexUniform(e, t, r, n, s) {
        return this.createUniform("vertex", e, t, r, n, s);
    }
    createFragmentUniform(e, t, r, n, s) {
        return this.createUniform("fragment", e, t, r, n, s);
    }
    include(e, t, r) {
        var o;
        let n;
        if (e = typeof e == "string" ? _r.get(e) : e, this.context.include === !1) return e.name;
        e instanceof Ne ? n = this.includes.functions : e instanceof wt ? n = this.includes.consts : e instanceof Fl && (n = this.includes.structs);
        let s = n[this.shader] = n[this.shader] || [];
        if (e) {
            let a = s[e.name];
            if (a || (a = s[e.name] = {
                node: e,
                deps: []
            }, s.push(a), a.src = e.build(this, "source")), e instanceof Ne && t && s[t.name] && s[t.name].deps.indexOf(e) === -1 && (s[t.name].deps.push(e), (o = e.includes) != null && o.length)) {
                let l = 0;
                do this.include(e.includes[l++], t);
                while (l < e.includes.length)
            }
            return r && (a.src = r), e.name;
        } else throw new Error("Include not found.");
    }
    colorToVectorProperties(e) {
        return e.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w");
    }
    colorToVector(e) {
        return e.replace(/c/g, "v3");
    }
    getIncludes(e, t) {
        return this.includes[e][t || this.shader];
    }
    getConstructorFromLength(e) {
        return bF[e - 1];
    }
    isTypeMatrix(e) {
        return /^m/.test(e);
    }
    getTypeLength(e) {
        return e === "f" ? 1 : parseInt(this.colorToVector(e).substr(1));
    }
    getTypeFromLength(e) {
        return e === 1 ? "f" : "v" + e;
    }
    findNode(...e) {
        for(let t = 0; t < arguments.length; t++){
            let r = e[t];
            if (r != null && r.isNode) return r;
        }
    }
    resolve(...e) {
        for(let t = 0; t < arguments.length; t++){
            let r = e[t];
            if (r !== void 0) {
                if (r.isNode) return r;
                if (r.isTexture) switch(r.mapping){
                    case Rs:
                    case Bs:
                        return new Sp(r);
                    case Ya:
                        return new wp(new jr(r));
                    default:
                        return new jr(r);
                }
                else {
                    if (r.isVector2) return new Nr(r);
                    if (r.isVector3) return new Or(r);
                    if (r.isVector4) return new fi(r);
                }
            }
        }
    }
    format(e, t, r) {
        switch(this.colorToVector(r + " <- " + t)){
            case "f <- v2":
                return e + ".x";
            case "f <- v3":
                return e + ".x";
            case "f <- v4":
                return e + ".x";
            case "f <- i":
            case "f <- b":
                return "float( " + e + " )";
            case "v2 <- f":
                return "vec2( " + e + " )";
            case "v2 <- v3":
                return e + ".xy";
            case "v2 <- v4":
                return e + ".xy";
            case "v2 <- i":
            case "v2 <- b":
                return "vec2( float( " + e + " ) )";
            case "v3 <- f":
                return "vec3( " + e + " )";
            case "v3 <- v2":
                return "vec3( " + e + ", 0.0 )";
            case "v3 <- v4":
                return e + ".xyz";
            case "v3 <- i":
            case "v3 <- b":
                return "vec2( float( " + e + " ) )";
            case "v4 <- f":
                return "vec4( " + e + " )";
            case "v4 <- v2":
                return "vec4( " + e + ", 0.0, 1.0 )";
            case "v4 <- v3":
                return "vec4( " + e + ", 1.0 )";
            case "v4 <- i":
            case "v4 <- b":
                return "vec4( float( " + e + " ) )";
            case "i <- f":
            case "i <- b":
                return "int( " + e + " )";
            case "i <- v2":
                return "int( " + e + ".x )";
            case "i <- v3":
                return "int( " + e + ".x )";
            case "i <- v4":
                return "int( " + e + ".x )";
            case "b <- f":
                return "( " + e + " != 0.0 )";
            case "b <- v2":
                return "( " + e + " != vec2( 0.0 ) )";
            case "b <- v3":
                return "( " + e + " != vec3( 0.0 ) )";
            case "b <- v4":
                return "( " + e + " != vec4( 0.0 ) )";
            case "b <- i":
                return "( " + e + " != 0 )";
        }
        return e;
    }
    getTypeByFormat(e) {
        return wF[e] || e;
    }
    getFormatByType(e) {
        return SF[e] || e;
    }
    getUUID(e, t) {
        return t = t !== void 0 ? t : !0, t && this.cache && (e = this.cache + "-" + e), e;
    }
    getElementByIndex(e) {
        return C1[e];
    }
    getIndexByElement(e) {
        return C1.indexOf(e);
    }
    isShader(e) {
        return this.shader === e;
    }
    setShader(e) {
        return this.shader = e, this;
    }
    mergeDefines(e) {
        for(let t in e)this.defines[t] = e[t];
        return this.defines;
    }
    mergeUniform(e) {
        for(let t in e)this.uniforms[t] = e[t];
        return this.uniforms;
    }
    getTextureEncodingFromMap(e) {
        let t;
        return e ? e.isTexture && (t = e.encoding) : t = gn, t === gn && this.context.gamma && (t = je), t;
    }
};
var Kh = class extends We {
    constructor(t = new We){
        super("v4");
        this.nodeType = "Raw";
        this.value = t;
    }
    generate(t) {
        let r = this.value.analyzeAndFlow(t, this.type), n = r.code + `
`;
        return t.isShader("vertex") ? n += "gl_Position = " + r.result + ";" : n += "gl_FragColor = " + r.result + ";", n;
    }
    copy(t) {
        return super.copy(t), this.value.copy(t.value), this;
    }
};
var Ot = class extends jt {
    constructor(t = 0, r, n, s){
        super("c");
        this.nodeType = "Color";
        this.value = t instanceof Wr ? t : new Wr(t || 0, r, n, s);
    }
    setRGBA(t) {
        this.value.setRGBA(t.r, t.g, t.b, t.a);
    }
    generate(t, r, n, s, o, a) {
        n = t.getUUID(n != null ? n : this.getUUID()), s = s != null ? s : this.getType(t);
        let l = t.getNodeData(n), c = this.getReadonly() && this.generateReadonly !== void 0;
        if (this.alpha) {
            let h = this.alpha.build(t, "f");
            t.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${h};`);
        }
        return c ? this.generateReadonly(t, r, n, s, o, a) : t.isShader("vertex") ? (l.vertex || (l.vertex = t.createVertexUniform(s, this, o, a, this.getLabel())), t.format(l.vertex.name, s, r)) : (l.fragment || (l.fragment = t.createFragmentUniform(s, this, o, a, this.getLabel())), t.format(l.fragment.name, s, r));
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", s, r);
    }
};
var ht = class extends jt {
    constructor(t){
        super("i");
        this.nodeType = "Int";
        this.value = Math.floor(t != null ? t : 0);
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format(this.value.toString(), s, r);
    }
    copy(t) {
        return super.copy(t), this.value = t.value, this;
    }
};
var $t = class {
    constructor(e, t, r, n){
        this.next = void 0;
        this.uniforms = {};
        this.textures = {};
        this.defines = {};
        if (this.id = e, this.uuid = t, r) {
            this.type = r.type;
            for(let s in r)s !== "type" && s !== "calpha" && (this.uniforms[`f${this.id}_${s}`] = r[s]);
            for(let s9 in n)this.defines[s9] = n[s9];
        }
    }
    copy(e) {
        this.id = e.id, this.type = e.type, this.defines = ie({}, e.defines);
        for(let t in e.uniforms)this.getName(t) === "transmissionSamplerMap" || this.getName(t) === "transmissionDepthMap" || (this.uniforms[t] ? this.uniforms[t].copy(e.uniforms[t]) : this.uniforms[t] = e.uniforms[t].clone());
        return this;
    }
    clone() {
        return new $t(this.id).copy(this);
    }
    fromJSON(e, t) {
        this.id = e.id, this.defines = ie({}, e.defines);
        for(let r in e.uniforms)this.uniforms[r] = t.getNode(e.uniforms[r]);
        if (e.type === "texture") {
            if (!(`f${this.id}_textureSize` in this.uniforms)) {
                let r = this.uniforms[`f${this.id}_texture`].value.image;
                this.uniforms[`f${e.id}_textureSize`] = new Or(r.width, r.height);
            }
            `f${this.id}_size` in this.uniforms || (this.uniforms[`f${e.id}_size`] = new Nr(200, 200)), `f${e.id}_axis` in this.uniforms || (this.uniforms[`f${e.id}_axis`] = new ht(0)), `f${e.id}_side` in this.uniforms || (this.uniforms[`f${e.id}_side`] = new ht(0)), `f${e.id}_projection` in this.uniforms || (this.uniforms[`f${e.id}_projection`] = new ht(0));
        } else e.type === "noise" ? (`f${e.id}_noiseType` in this.uniforms || (this.uniforms[`f${e.id}_noiseType`] = new ht(0)), `f${e.id}_size` in this.uniforms || (this.uniforms[`f${e.id}_size`] = new Or(-1, -1, -1))) : e.type === "depth" && (`f${e.id}_isWorldSpace` in this.uniforms || (this.uniforms[`f${e.id}_isWorldSpace`] = new Be(1)));
        return this;
    }
    toJSON(e) {
        let t = {};
        for(let n in this.uniforms)t[n] = this.uniforms[n].toJSON(e).uuid;
        return {
            id: this.id,
            type: this.type,
            defines: JSON.parse(JSON.stringify(this.defines)),
            uniforms: t,
            next: this.next == null ? void 0 : this.next.toJSON(e)
        };
    }
    copyUniforms(e) {
        for(let t in this.uniforms){
            let r = this.getName(t);
            r !== void 0 && e.uniforms[`f${e.id}_${r}`] && r !== "transmissionDepthMap" && r !== "transmissionSamplerMap" && this.uniforms[t].copy(e.uniforms[`f${e.id}_${r}`]);
        }
        return this;
    }
    hasValueByKey(e) {
        return this.uniforms[e] !== void 0;
    }
    hasValue(e) {
        return this.hasValueByKey(`f${this.id}_${e}`);
    }
    setValue(e, t) {
        let r = `f${this.id}_${e}`;
        this.hasValueByKey(r) && t !== void 0 && (this.uniforms[r].value = t);
    }
    getValue(e) {
        let t = `f${this.id}_${e}`;
        if (this.hasValueByKey(t)) return this.uniforms[t].value;
    }
    getValues() {
        let e = {
            type: this.type
        };
        for(let t in this.uniforms){
            let r = this.getName(t);
            if (r === void 0) continue;
            let s = this.uniforms[`f${this.id}_${r}`].value;
            s !== void 0 && (Array.isArray(s) ? e[r] = s.map((o)=>o.clone ? o.clone() : o
            ) : e[r] = s.clone ? s.clone() : s);
        }
        return e;
    }
    getName(e) {
        let r = /f\d+_(.*)/.exec(e);
        if (r && r.length > 1) return r[1];
        console.log(`Layer.getName: error ${e}`);
    }
    getNames() {
        let e = [];
        for(let t in this.uniforms){
            let r = this.getName(t);
            r && e.push(r);
        }
        return e;
    }
    isEqual(e) {
        for(let t in e.uniforms){
            let r = e.getName(t);
            if (!r) return !1;
            let n = this.getValue(r), s = e.uniforms[t].value;
            if (s.value instanceof Dt) {
                if (n.image !== s.image) return !1;
            } else if (Array.isArray(s)) {
                let o = n;
                for(let a = 0, l = o.length; a < l; ++a)if (o[a] !== s[a]) return !1;
            } else {
                let o = n;
                if (o.equals) {
                    if (!o.equals(s)) return !1;
                } else if (n !== s) return !1;
            }
        }
        return !0;
    }
    dispose() {}
};
function D1(i) {
    let e = i instanceof $t ? i.type : i;
    return e === "texture" || e === "displace_map" || e === "matcap";
}
var Zh = class extends jt {
    constructor(t){
        super("b");
        this.nodeType = "Bool";
        this.value = t != null ? t : !1;
    }
    generateReadonly(t, r, n, s) {
        return t.format(this.value ? "true" : "false", s, r);
    }
    copy(t) {
        return super.copy(t), this.value = t.value, this;
    }
};
var ps = class extends jt {
    constructor(t = 1, r){
        super("v4[]");
        this.nodeType = "Vector4Array";
        this.size = t, this.value = Array.isArray(r) ? r : r instanceof Je ? new Array(t).fill(r) : new Array(t).fill(new Je(0));
    }
    copy(t) {
        return super.copy(t), this.value = t.value.map((r)=>r.clone()
        ), this;
    }
};
var Ko = class extends jt {
    constructor(t = 1, r){
        super("f[]");
        this.nodeType = "FloatArray";
        this.size = t, this.value = Array.isArray(r) ? r : typeof r == "number" ? new Array(t).fill(r) : new Array(t).fill(0);
    }
    copy(t) {
        return super.copy(t), this.size = t.size, this.value = [
            ...t.value
        ], this;
    }
};
var Vl = class extends jt {
    constructor(t){
        super("m3");
        this.nodeType = "Matrix3";
        this.value = t != null ? t : new Ft;
    }
    generateReadonly(t, r, n, s, o, a) {
        return t.format("mat3(" + this.value.elements.join(", ") + ")", s, r);
    }
    copy(t) {
        return super.copy(t), this.elements = t.elements, this;
    }
    get elements() {
        return this.value.elements;
    }
    set elements(t) {
        this.value.fromArray(t);
    }
};
var eu = class extends Ye {
    constructor(t = new jr, r, n, s, o, a, l, c, h){
        super("v3");
        this.nodeType = "CustomTexture";
        this.firstTime = !0, this.texture = t, this.textureSize = r, this.crop = n, this.projection = s, this.axis = o, this.side = a, this.size = l, this.mat = new Vl(this.texture.value.matrix), this.alpha = c, this.mode = h, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        t.require("position"), t.require("normal"), t.require("uv"), t.requires.uv = [
            !0
        ], t.extensions.shaderTextureLOD = !0, t.extensions.derivatives = !0;
        let n = `g${this.uuid.toString().replace(/-/g, "")}`, s;
        switch(this.projection.value){
            case 3:
                s = t.include(eu.Nodes.cylindrical);
                break;
            case 2:
                s = t.include(eu.Nodes.spherical);
                break;
            case 1:
                let a = [
                    "vec3(1.0, 0.0, 0.0)",
                    "vec3(0.0, 1.0, 0.0)",
                    "vec3(0.0, 0.0, 1.0)"
                ][this.axis.value], l = new Ne(`
		vec3 ${n}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${n}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value === 0 ? "" : `lalpha *= step(0.0, ${this.side.value === 2 ? "-1.0 * " : ""}dot(vObjectNormal, mat * ${a}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
                s = t.include(l);
                break;
            default:
                s = t.include(eu.Nodes.uv);
                break;
        }
        if (this.projection.value === 1 && this.firstTime) {
            t.addVertexParsCode(`varying vec2 ${n}_vCustomUv;`), t.addFragmentParsCode(`varying vec2 ${n}_vCustomUv;`);
            let a = [
                "zy",
                "xz",
                "xy"
            ][this.axis.value];
            t.addVertexFinalCode(`${n}_vCustomUv = (1. + (transformed.${a})) / 2.;`);
        }
        t.addFragmentVariable(this.calpha, "float");
        let o = [];
        return o.push(this.texture.getTexture(t, "t")), o.push(this.textureSize.build(t, "v2")), o.push(this.crop.build(t, "f")), o.push(this.mat.build(t, "mat3")), o.push(this.size.build(t, "v2")), o.push(this.alpha.build(t, "f")), o.push(this.mode.build(t, "i")), o.push(this.calpha), this.firstTime = !this.firstTime, t.format(s + "(" + o.join(",") + ")", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.texture.copy(t.texture), this.textureSize = t.textureSize.clone(), this.crop = t.crop.clone(), this.projection = t.projection.clone(), this.axis = t.axis.clone(), this.size = t.size.clone(), this.alpha = t.alpha.clone(), this.mode = t.mode.clone(), this;
    }
}, $h = eu;
$h.Nodes = function() {
    let t = new Ne(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`), r = new Ne(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`), n = new Ne(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
    return {
        cylindrical: t,
        spherical: r,
        uv: n
    };
}();
var yv = class extends Ye {
    constructor(t, r, n, s, o, a, l){
        super("v3");
        this.nodeType = "Fresnel";
        this.color = t, this.bias = r, this.scale = n, this.intensity = s, this.factor = o, this.alpha = a, this.mode = l, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        if (t.require("vWorldViewDir"), t.require("worldNormal"), t.isShader("fragment")) {
            t.addFragmentVariable(this.calpha, "float");
            let n = t.include(yv.Nodes.fresnel), s = [];
            return s.push(this.color.build(t, "c")), s.push(this.bias.build(t, "f")), s.push(this.scale.build(t, "f")), s.push(this.intensity.build(t, "f")), s.push(this.factor.build(t, "f")), s.push(this.alpha.build(t, "f")), s.push(this.mode.build(t, "i")), s.push(this.calpha), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("FresnelNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.color = t.color.clone(), this.bias = t.bias.clone(), this.scale = t.scale.clone(), this.intensity = t.intensity.clone(), this.factor = t.factor.clone(), this.alpha = t.alpha.clone(), this.mode = t.mode.clone(), this.calpha = t.calpha, this;
    }
}, tu = yv;
tu.Nodes = function() {
    return {
        fresnel: new Ne(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`)
    };
}();
var ru = ((s)=>(s.SIMPLEX = "simplex3d", s.SIMPLEX_FRACTAL = "simplex3dFractal", s.ASHIMA = "simplexAshima", s.FBM = "fbm", s.PERLIN = "perlin", s)
)(ru || {}), An = function() {
    let e = new Ne(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`), t = new Ne(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [
        e
    ]);
    t.keywords.F3 = new wt("float F3 0.3333333"), t.keywords.G3 = new wt("float G3 0.1666667");
    let r = new Ne(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [
        t
    ]), n = new Ne("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"), s = new Ne("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"), o = new Ne(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [
        n,
        s
    ]), a = new Ne("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"), l = new Ne("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [
        a
    ]), c = new Ne(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [
        l
    ]), h = new Ne(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [
        c
    ]);
    h.keywords.NUM_OCTAVES = new wt(`int NUM_OCTAVES ${5}`);
    let u = new Ne("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"), f = new Ne(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [
        n,
        s,
        u
    ]);
    return {
        simplex: t,
        simplexFractal: r,
        simplexAshima: o,
        fbm: h,
        perlin: f
    };
}();
var vv = class extends Ye {
    constructor(t, r, n, s, o, a, l){
        super("v3");
        this.nodeType = "Rainbow";
        this.filmThickness = t, this.movement = r, this.wavelengths = n, this.noiseStrength = s, this.noiseScale = o, this.offset = a, this.alpha = l, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        if (t.require("vWorldViewDir"), t.require("worldNormal"), t.isShader("fragment")) {
            t.require("uv"), t.requires.uv = [
                !0
            ], t.addFragmentVariable(this.calpha, "float");
            let n = t.include(vv.Nodes.rainbow), s = [];
            return s.push(this.filmThickness.build(t, "f")), s.push(this.movement.build(t, "f")), s.push(this.wavelengths.build(t, "v3")), s.push(this.noiseStrength.build(t, "f")), s.push(this.noiseScale.build(t, "f")), s.push(this.offset.build(t, "v3")), s.push(this.alpha.build(t, "f")), s.push(this.calpha), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("RainbowNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.filmThickness = t.filmThickness.clone(), this.movement = t.movement.clone(), this.wavelengths = t.wavelengths.clone(), this.noiseStrength = t.noiseStrength.clone(), this.noiseScale = t.noiseScale.clone(), this.offset = t.offset.clone(), this.alpha = t.alpha.clone(), this.calpha = t.calpha, this;
    }
}, nu = vv;
nu.Nodes = function() {
    let t = new Ne(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`, [
        An.simplex
    ]);
    return {
        rainbow: new Ne(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`, [
            t
        ])
    };
}();
var xv = class extends Ye {
    constructor(t, r, n, s, o, a, l, c){
        super("v3");
        this.nodeType = "Transmission";
        this.thickness = t, this.ior = r, this.roughness = n, this.transmissionSamplerSize = s, this.transmissionSamplerMap = o, this.transmissionDepthMap = a, this.aspectRatio = l, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        if (t.extensions.shaderTextureLOD = !0, t.extensions.derivatives = !0, t.isShader("fragment")) {
            t.define("NUM_SAMPLES", 30), t.require("worldPosition"), t.requires.worldNormal = !0, t.requires.modelMatrix = !0, t.requires.projectionMatrix = !0, t.addFragmentVariable(this.calpha, "float");
            let n = t.include(xv.Nodes.transmission), s = [];
            return s.push(this.thickness.build(t, "f")), s.push(this.ior.build(t, "f")), s.push(this.roughness.build(t, "f")), s.push(this.transmissionSamplerSize.build(t, "v2")), s.push(this.transmissionSamplerMap.getTexture(t, "t")), s.push(this.transmissionDepthMap.getTexture(t, "t")), s.push(this.aspectRatio.build(t, "v2")), s.push("normal"), s.push(this.alpha.build(t, "f")), s.push(this.calpha), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("TransmissionNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(this), this.thickness = t.thickness.clone(), this.ior = t.ior.clone(), this.roughness = t.roughness.clone(), this.transmissionSamplerSize = t.transmissionSamplerSize.clone(), this.transmissionSamplerMap = t.transmissionSamplerMap, this.transmissionDepthMap = t.transmissionDepthMap, this.alpha = t.alpha.clone(), this.calpha = t.calpha, this;
    }
}, iu = xv;
iu.Nodes = function() {
    let t = new Ne(`
            float gaussian(vec2 i) {
                const float sigma = float(NUM_SAMPLES) * .25;
                return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );
            }`), r = new Ne(`
            vec4 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

                const int LOD = 2;
                const int sLOD = 4; // tile size = 2^LOD

                vec4 O = vec4(0);
                const int s = NUM_SAMPLES/sLOD;
                for ( int i = 0; i < s*s; i++ ) {
                    int modulo = (i)-((i)/(s))*(s);
                    vec2 d = vec2(float(modulo), float(i/s))*float(sLOD) - float(NUM_SAMPLES)/2.;
                    vec2 uv = U + (scale * aspectRatio) * d;
                    // What is the depth of the opaque object we're trying to sample
                    float opaqueDepth = texture2D(dm, uv).r;
                    if (opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU + ((scale * min(lod / 2., 1.)) * aspectRatio) * d;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
		            #ifdef TEXTURE_LOD_EXT
                    O += gaussian(d) * texture2DLodEXT( sp, uv, lod);
                    #else
                    O += gaussian(d) * textureLod( sp, uv, lod);
                    #endif
                }
                return O / O.a;
            }`, [
        t
    ]), n = new Ne(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`), s = new Ne(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `), o = new Ne(`
vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod / (transmissionSamplerSize.x / 2.)), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`, [
        s,
        r
    ]), a = new Ne(`
vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
        // Get the specular component.
        return vec4( ( 1.0 ) * transmittedLight.rgb, transmittedLight.a );
    }`, [
        o,
        n
    ]);
    return {
        transmission: new Ne(`
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec4 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                float lalpha = alpha;

                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return transmission.rgb;
            }`, [
            a
        ])
    };
}();
var bv = class extends Ye {
    constructor(t, r){
        super("v3");
        this.nodeType = "CustomNormal";
        this.cnormal = t, this.alpha = r;
    }
    generate(t, r) {
        if (t.isShader("fragment")) {
            let n = t.include(bv.Nodes.customNormal), s = [];
            return s.push(this.cnormal.build(t, "v3")), s.push("normal"), s.push(this.alpha.build(t, "f")), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("CustomNormalNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.cnormal.copy(t.cnormal), this.alpha.copy(t.alpha), this;
    }
}, su = bv;
su.Nodes = function() {
    return {
        customNormal: new Ne(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`)
    };
}();
var wv = class extends Ye {
    constructor(t, r, n, s, o, a, l, c){
        super("v3");
        this.nodeType = "Gradient";
        this.gradientType = t, this.smooth = r, this.colors = n, this.steps = s, this.offset = o, this.morph = a, this.angle = l, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        if (t.isShader("fragment")) {
            t.define("GRAD_MAX", 10), t.require("uv"), t.requires.uv = [
                !0
            ], t.addFragmentVariable(this.calpha, "float");
            let n = t.include(wv.Nodes.gradient), s = [];
            return s.push(this.gradientType.build(t, "i")), s.push(this.smooth.build(t, "b")), s.push(this.colors.build(t, "v4[]")), s.push(this.steps.build(t, "f[]")), s.push(this.offset.build(t, "v2")), s.push(this.morph.build(t, "v2")), s.push(this.angle.build(t, "f")), s.push(this.alpha.build(t, "f")), s.push(this.calpha), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("GradientNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.gradientType = t.gradientType.clone(), this.smooth = t.smooth.clone(), this.colors = t.colors.clone(), this.steps = t.steps.clone(), this.offset = t.offset.clone(), this.morph = t.morph.clone(), this.angle = t.angle.clone(), this.alpha = t.alpha.clone(), this.calpha = t.calpha, this;
    }
}, ou = wv;
ou.Nodes = function() {
    return {
        gradient: new Ne(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`)
    };
}();
var Sv = ((t)=>(t.NOISE = "noise", t.MAP = "map", t)
)(Sv || {}), Mv = class extends Ye {
    constructor(t = new ht(0), r, n, s, o, a){
        super("v3");
        this.nodeType = "VertexDisplacement";
        this.displacementTypeIndex = t, this.intensity = r, this.movementOrTexture = n, Object.values(Sv)[this.displacementTypeIndex.value] === "map" && (this.mat = new Vl(this.movementOrTexture.value.matrix)), this.cropOrOffset = s, this.scale = o, this.noiseFunctionIndex = a;
    }
    generate(t, r) {
        if (t.isShader("vertex")) {
            t.define("USE_LAYER_DISPLACE");
            let n, s = [];
            switch(s.push("displaced_position"), s.push("displaced_normal"), Object.values(Sv)[this.displacementTypeIndex.value]){
                case "map":
                    n = t.include(Mv.Nodes.map), s.push(this.movementOrTexture.getTexture(t, "t")), s.push("uv"), s.push(this.cropOrOffset.build(t, "f")), this.mat && s.push(this.mat.build(t, "mat3"));
                    break;
                case "noise":
                    {
                        let a = Object.values(ru)[this.noiseFunctionIndex.value], l = new Ne(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`), c = new Ne(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${a}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`, [
                            An.simplex,
                            An.simplexFractal,
                            An.simplexAshima,
                            An.fbm,
                            An.perlin
                        ]), h = new Ne(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [
                            c,
                            l
                        ]);
                        n = t.include(h), s.push(this.scale.build(t, "f")), s.push(this.cropOrOffset.build(t, "v3")), s.push(this.movementOrTexture.build(t, "f"));
                        break;
                    }
            }
            return s.push(this.intensity.build(t, "f")), s.push("displaced_normal"), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("VertexDisplacementNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        var r, n;
        return super.copy(t), this.noiseFunctionIndex = (r = t.noiseFunctionIndex) == null ? void 0 : r.clone(), this.scale = (n = t.scale) == null ? void 0 : n.clone(), this.cropOrOffset = t.cropOrOffset.clone(), this.intensity = t.intensity.clone(), this.movementOrTexture = t.movementOrTexture.clone(), this;
    }
}, Hl = Mv;
Hl.Nodes = function() {
    let t = new Ne(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`), r = new Ne(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
    return {
        map: new Ne(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [
            t,
            r
        ])
    };
}();
var au = class extends Ye {
    constructor(t = new We, r = new We, n = new We, s = new We, o = new We, a = new We, l = new We, c = new We, h = new We, u = new We, f = new We, d = new We){
        super("v3");
        this.nodeType = "Noise";
        this.scale = t, this.size = r, this.move = n, this.fA = s, this.fB = o, this.distortion = a, this.colorA = l, this.colorB = c, this.colorC = h, this.colorD = u, this.alpha = f, this.noiseType = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r, n, s, o) {
        t.require("uv"), t.requires.uv = [
            !0
        ], t.addFragmentVariable(this.calpha, "float");
        let a = Object.values(ru)[this.noiseType.value], l = new Ne(`vec3 ${a}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, float alpha, out float calpha) {
                vec3 st = position / size;
				st /= scale;
				vec3 q = vec3(${a}(st),
							  ${a}(st + vec3(1.0)),
							  ${a}(st + vec3(1.0)));
				vec3 r = vec3(${a}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${a}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${a}(st * q));
				float f = ${a}(st + r);
				vec4 color;
				color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));

                float lalpha = alpha * color.a;
                calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			    accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return clamp(color, 0.0, 1.0).rgb;
			}`, [
            An.simplex,
            An.simplexFractal,
            An.simplexAshima,
            An.fbm,
            An.perlin
        ]), c = t.include(l), h = [];
        return h.push(this.scale.build(t, "f")), h.push(this.size.build(t, "v3")), h.push(this.move.build(t, "f")), h.push(this.fA.build(t, "v2")), h.push(this.fB.build(t, "v2")), h.push(this.distortion.build(t, "v2")), h.push(this.colorA.build(t, "v4")), h.push(this.colorB.build(t, "v4")), h.push(this.colorC.build(t, "v4")), h.push(this.colorD.build(t, "v4")), h.push(this.alpha.build(t, "f")), h.push(this.calpha), t.format(c + "(" + h.join(",") + ")", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.scale.copy(t.scale), this.size.copy(t.size), this.move.copy(t.move), this.fA.copy(t.fA), this.fB.copy(t.fB), this.distortion.copy(t.distortion), this.colorA.copy(t.colorA), this.colorB.copy(t.colorB), this.colorC.copy(t.colorC), this.colorD.copy(t.colorD), this.alpha.copy(t.alpha), this.calpha = t.calpha, this.noiseType.copy(t.noiseType), this;
    }
};
au.numOctaves = 5;
var lu = class extends Ye {
    constructor(t = new We, r = new We, n = new We, s = new We){
        super("v3");
        this.nodeType = "Blend";
        this.a = t, this.b = r, this.alpha = n, this.mode = s;
    }
    generate(t, r) {
        if (t.isShader("fragment")) {
            let n = [];
            return n.push(this.a.build(t, "c")), n.push(this.b.build(t, "c")), n.push(this.alpha.build(t, "f")), n.push(this.mode.build(t, "i")), t.format("spe_blend(" + n.join(",") + ")", this.getType(t), r);
        } else return console.warn("BlendNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.a.copy(t.a), this.b.copy(t.b), this.alpha.copy(t.alpha), this.mode.copy(t.mode), this;
    }
};
var Wl = class extends Ye {
    constructor(t, r, n, s, o, a, l, c, h, u, f, d){
        super("v3");
        this.nodeType = "Depth";
        this.gradientType = t, this.smooth = r, this.near = n, this.far = s, this.isVector = o, this.isWorldSpace = a, this.origin = l, this.direction = c, this.colors = h, this.steps = u, this.num = f, this.alpha = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        let n = `g${this.uuid.toString().replace(/-/g, "")}`, s = new Ne(`vec3 ${n}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${n}_MAX_COLORS], float steps[10], float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${n}_IS_VECTOR
                   #ifdef ${n}_LINEAR
                       #ifdef ${n}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${n}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${n}_SMOOTH
				for ( int i = 1; i < ${n}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${n}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a;
               calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			   accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
               return color.rgb;
			}`, [
            Wl.Nodes.vectorLinearWorldSpaceDepth,
            Wl.Nodes.vectorLinearObjectSpaceDepth,
            Wl.Nodes.vectorSphericalObjectSpaceDepth,
            Wl.Nodes.vectorSphericalWorldSpaceDepth
        ]);
        if (t.isShader("fragment")) {
            t.define(`${n}_MAX_COLORS`, this.num.value + 1), this.smooth.value && t.define(`${n}_SMOOTH`), this.isVector.value > .5 && t.define(`${n}_IS_VECTOR`), this.gradientType.value === 0 && t.define(`${n}_LINEAR`), this.isWorldSpace.value > .5 && t.define(`${n}_WORLDSPACE`), t.require("worldPosition"), t.addFragmentVariable(this.calpha, "float");
            let o = t.include(s), a = [];
            return a.push(this.near.build(t, "f")), a.push(this.far.build(t, "f")), a.push(this.origin.build(t, "v3")), a.push(this.direction.build(t, "v3")), a.push(this.colors.build(t, "v4[]")), a.push(this.steps.build(t, "f[]")), a.push(this.alpha.build(t, "f")), a.push(this.calpha), t.format(o + "(" + a.join(",") + ")", this.getType(t), r);
        } else return console.warn("DepthNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.gradientType = t.gradientType.clone(), this.smooth = t.smooth.clone(), this.near = t.near.clone(), this.far = t.far.clone(), this.isVector = t.isVector.clone(), this.isWorldSpace = t.isWorldSpace.clone(), this.origin = t.origin.clone(), this.direction = t.direction.clone(), this.colors = t.colors.clone(), this.steps = t.steps.clone(), this.alpha = t.alpha.clone(), this.calpha = t.calpha, this;
    }
}, cu = Wl;
cu.Nodes = function() {
    let t = new Ne(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), r = new Ne(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), n = new Ne(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`), s = new Ne(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);
    return {
        vectorLinearWorldSpaceDepth: t,
        vectorLinearObjectSpaceDepth: r,
        vectorSphericalWorldSpaceDepth: n,
        vectorSphericalObjectSpaceDepth: s
    };
}();
var Av = class extends Ye {
    constructor(t, r, n){
        super("v3");
        this.nodeType = "Matcap";
        this.texture = t, this.alpha = r, this.mode = n, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
    }
    generate(t, r) {
        if (t.isShader("fragment")) {
            t.addFragmentVariable(this.calpha, "float");
            let n = t.include(Av.Nodes.matcap);
            t.require("normal"), t.requires.normal = !0;
            let s = [];
            return s.push(this.texture.getTexture(t, "t")), s.push("normal"), s.push(this.alpha.build(t, "f")), s.push(this.mode.build(t, "i")), s.push(this.calpha), t.format(n + "(" + s.join(",") + ")", this.getType(t), r);
        } else return console.warn("MatcapNode is not compatible with " + t.shader + " shader."), t.format("vec3( 0.0 )", this.getType(t), r);
    }
    copy(t) {
        return super.copy(t), this.texture = t.texture.clone(), this.alpha = t.alpha.clone(), this.mode = t.mode.clone(), this.calpha = t.calpha, this;
    }
}, hu = Av;
hu.Nodes = function() {
    return {
        matcap: new Ne(`vec3 matcap(sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );

                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `)
    };
}();
var Zr = class {
    constructor(e){
        this.id = 2, this.layerCount = 2, this.uuid = et.generateUUID(), this.needsUpdate = !1, this._material = e, this._layerNodes = [];
        let t = this._createLayer({
            id: 0,
            type: "color"
        });
        this._material.color = t.color, this._material.alpha === void 0 && (this._material.alpha = new Be(1));
        let r = new Be(1), n = new ht(0);
        "shadingAlpha" in this._material && "shadingBlend" in this._material && (this._material.shadingAlpha = r, this._material.shadingBlend = n), this._layerNodes.push({
            id: 0,
            type: "color",
            color: t.color,
            alpha: t.alpha,
            mode: t.mode
        }), this._layerNodes.push({
            id: 1,
            type: "light",
            alpha: r,
            mode: n
        }), this.head = t.layer, this.head.next = new $t(1, void 0, {
            type: "light",
            alpha: r,
            mode: n
        }), this.attachLightNodes(this.getLightLayer());
    }
    get material() {
        return this._material;
    }
    set material(e) {
        var s;
        this._material = e;
        let t, r, n = this.head;
        for(; n !== void 0;){
            if (n.type === "light") {
                t = n.uniforms[`f${n.id}_alpha`], r = n.uniforms[`f${n.id}_mode`];
                break;
            }
            n = n.next;
        }
        "shadingAlpha" in this._material && "shadingBlend" in this._material && (this._material.shadingAlpha = t, this._material.shadingBlend = r), this.attachLightNodes((s = e.userData.layers) == null ? void 0 : s.getLightLayer()), this.blendColors(), this.blendAfterColors(), this.blendPositions();
    }
    getLayersOfType(e) {
        let t = [], r = this.head;
        for(; r;)r.type === e && t.push(r), r = r.next;
        return t;
    }
    addLayer(e) {
        var n;
        if (e.id = (n = e.id) != null ? n : ++this.id, this.layerCount++, e.type === "light") {
            let s = this.createLightLayer(e);
            return this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), s;
        }
        let t = this._createLayer(e), r = t.layer;
        if (this.head === void 0) this.head = r;
        else {
            let s = this.head;
            for(; s.next != null;)s = s.next;
            s.next = r;
        }
        return t.color && this._layerNodes.push({
            id: r.id,
            type: "color",
            color: t.color,
            alpha: t.alpha,
            mode: t.mode
        }), t.position && this._layerNodes.push({
            id: r.id,
            type: "position",
            position: t.position
        }), this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), r;
    }
    addLayerBeforeAt(e, t) {
        var a;
        let r = this.head;
        e.id = (a = e.id) != null ? a : ++this.id, this.layerCount++;
        let n = this._createLayer(e), s = n.layer;
        s.next = t;
        let o = 0;
        if (r === t) this.head = s, n.color && this._layerNodes.splice(0, 0, {
            id: s.id,
            type: "color",
            color: n.color,
            alpha: n.alpha,
            mode: n.mode
        }), n.position && this._layerNodes.splice(0, 0, {
            id: s.id,
            type: "position",
            position: n.position
        });
        else {
            for(o = 1; (r == null ? void 0 : r.next) !== t;)r = r == null ? void 0 : r.next, o++;
            r.next = s, n.color && this._layerNodes.splice(o, 0, {
                id: s.id,
                type: "color",
                color: n.color,
                alpha: n.alpha,
                mode: n.mode
            }), n.position && this._layerNodes.splice(o, 0, {
                id: s.id,
                type: "position",
                position: n.position
            });
        }
        return this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), s;
    }
    addLayerAt(e, t) {
        var s;
        t.id = (s = t.id) != null ? s : ++this.id, this.layerCount++;
        let r = this._createLayer(t), n = r.layer;
        if (r.color && this._layerNodes.splice(e, 0, {
            id: n.id,
            type: "color",
            color: r.color,
            alpha: r.alpha,
            mode: r.mode
        }), r.position && this._layerNodes.splice(e, 0, {
            id: n.id,
            type: "position",
            position: r.position
        }), e == 0) n.next = this.head, this.head = n;
        else {
            let o = this.head, a = this.head.next;
            for(let l = 0; l < e - 1; l++)o = a, a = a.next;
            n.next = a, o.next = n;
        }
        return this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), n;
    }
    removeLayer(e) {
        let t = this.head, r, n = 0;
        if ((t == null ? void 0 : t.id) == e) this.head = t.next;
        else for(n = 1, r = t, t = t == null ? void 0 : t.next; t != null;){
            if (t.id == e) {
                r.next = t.next;
                break;
            }
            n++, r = t, t = t.next;
        }
        return this.cleanupChangedLayer(t), this.blendColors(), this.blendAfterColors(), this.blendPositions(), this.uuid = et.generateUUID(), this.layerCount--, n;
    }
    changeLayer(e, t) {
        let r, n = this.head, s;
        if ((n == null ? void 0 : n.id) == e) {
            let o = this._createLayer(ie({
                id: e,
                uuid: n.uuid
            }, t));
            s = o.layer, s.next = n.next, this.head = s, o.color && (this._layerNodes[0] = {
                id: s.id,
                type: "color",
                color: o.color,
                alpha: o.alpha,
                mode: o.mode
            }), o.position && (this._layerNodes[0] = {
                id: s.id,
                type: "position",
                position: o.position
            }), s.uniforms[`f${e}_mode`].value = n.uniforms[`f${e}_mode`].value, s.uniforms[`f${e}_alpha`].value = n.uniforms[`f${e}_alpha`].value;
        } else {
            r = n, n = n.next;
            let o = 1;
            for(; n != null;){
                if (n.id == e) {
                    let a = this._createLayer(ie({
                        id: e,
                        uuid: n.uuid
                    }, t));
                    s = a.layer, r.next = s, s.next = n.next, a.color && (this._layerNodes[o] = {
                        id: e,
                        type: "color",
                        color: a.color,
                        alpha: a.alpha,
                        mode: a.mode
                    }), a.position && (this._layerNodes[o] = {
                        id: e,
                        type: "position",
                        position: a.position
                    }), s.uniforms[`f${e}_mode`].value = n.uniforms[`f${e}_mode`].value, s.uniforms[`f${e}_alpha`].value = n.uniforms[`f${e}_alpha`].value;
                    break;
                }
                r = n, n = n.next, o++;
            }
        }
        return this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors(), this.blendPositions(), s;
    }
    getLayer(e) {
        let t = this.head;
        for(; t != null && t.id != e;)t = t.next;
        return t;
    }
    getLayerByUuid(e) {
        let t = this.head;
        for(; t !== void 0;){
            if (t.uuid === e) return t;
            t = t.next;
        }
    }
    getLayers() {
        let e = [], t = this.head;
        for(; t != null;)e.push(t), t = t.next;
        return e;
    }
    getLayerPosition(e) {
        let t = this.head, r = 0;
        for(; t !== void 0 && t.id != e;)r++, t = t.next;
        return r;
    }
    getDefines() {}
    getBeforeProgram() {}
    getLightingProgram() {}
    getAfterProgram() {}
    getVarPrograms() {}
    getUniforms() {}
    moveLayer(e, t) {
        let r, n = this.head, s;
        if (e == 0) r = this.head, this.head = r.next;
        else {
            for(let a = 0; a < e; a++)s = n, n = n.next;
            s.next = n.next, r = n;
        }
        if (n = this.head, s = void 0, t == 0) r.next = this.head, this.head = r;
        else {
            for(let a = 0; a < t - 1; a++)n = n.next;
            r.next = n == null ? void 0 : n.next, n.next = r;
        }
        let o = this._layerNodes.splice(e, 1)[0];
        this._layerNodes.splice(t, 0, o), this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors();
    }
    updateLayerUniform() {
        this.uuid = et.generateUUID(), this.blendColors(), this.blendAfterColors();
    }
    copy(e) {
        this.needsUpdate = !1, this.layerCount = e.layerCount, this._layerNodes = [], this.layerCount = 0, this.head = void 0, this.rebuildLayerNodes(this.head, e.head);
        let t = e.head, r = this.head;
        for(; t.next != null;)this.rebuildLayerNodes(r, t.next), r = r.next, t = t.next;
        return this.id = e.id, this.uuid = e.uuid, this.blendColors(), this.blendAfterColors(), this.blendPositions(), this;
    }
    createLightLayer(e) {
        let t = new Be(e.alpha), r = new ht(e.mode);
        this._material.shadingAlpha = t, this._material.shadingBlend = r, this._layerNodes.push({
            id: e.id,
            type: "light",
            alpha: t,
            mode: r
        });
        let n = new $t(e.id, void 0, {
            type: "light",
            alpha: t,
            mode: r
        });
        if (this.head === void 0) this.head = n;
        else {
            let s = this.head;
            for(; s.next != null;)s = s.next;
            s.next = n;
        }
        return this.attachLightNodes(this.getLightLayer()), n;
    }
    rebuildLayerNodes(e, t, r = !1) {
        if (t.type === "light") {
            let n = r ? t.uniforms[`f${t.id}_alpha`] : new Be(t.uniforms[`f${t.id}_alpha`].value), s = r ? t.uniforms[`f${t.id}_mode`] : new ht(t.uniforms[`f${t.id}_mode`].value);
            this._material.shadingAlpha = n, this._material.shadingBlend = s, this._layerNodes.push({
                id: t.id,
                type: "light",
                alpha: n,
                mode: s
            }), this.head === void 0 ? this.head = new $t(t.id, t.uuid, {
                type: "light",
                alpha: n,
                mode: s
            }) : e && (e.next = new $t(t.id, t.uuid, {
                type: "light",
                alpha: n,
                mode: s
            })), this.attachLightNodes(t);
        } else {
            let n = {
                type: t.type,
                id: t.id
            };
            for(let s in t.uniforms){
                let o = t.getName(s);
                if (!o) continue;
                let a = `f${t.id}_${o}`;
                if (Array.isArray(t.uniforms[a].value)) n[o] = t.uniforms[a].value.map((l)=>l.clone && !r ? l.clone() : l
                );
                else {
                    let l = t.uniforms[a].value;
                    if (o === "transmissionDepthMap") {
                        n[o] = l;
                        continue;
                    }
                    l != null && (n[o] = l.clone && !r && !l.isRenderTargetTexture ? l.clone() : l);
                }
            }
            this.addLayer(n);
        }
    }
    attachLightNodes(e) {
        var n, s, o, a, l, c, h, u, f, d, p;
        let t = {}, r = this.getLightLayer();
        switch(this._material.userData.category){
            case "Lambert":
                t.emissive = new Ot((s = (n = e == null ? void 0 : e.getValue("emissive")) == null ? void 0 : n.clone()) != null ? s : 0);
                break;
            case "Phong":
                t.shininess = new Be((o = e == null ? void 0 : e.getValue("shininess")) != null ? o : 30), t.specular = new Ot((l = (a = e == null ? void 0 : e.getValue("specular")) == null ? void 0 : a.clone()) != null ? l : 1118481);
                break;
            case "Toon":
                t.shininess = new Be((c = e == null ? void 0 : e.getValue("shininess")) != null ? c : 30), t.specular = new Ot((u = (h = e == null ? void 0 : e.getValue("specular")) == null ? void 0 : h.clone()) != null ? u : 1118481);
                break;
            case "Physical":
                t.roughness = new Be((f = e == null ? void 0 : e.getValue("roughness")) != null ? f : .3), t.metalness = new Be((d = e == null ? void 0 : e.getValue("metalness")) != null ? d : 0), t.reflectivity = new Be((p = e == null ? void 0 : e.getValue("reflectivity")) != null ? p : .5);
                break;
            default:
                break;
        }
        Object.keys(t).forEach((m)=>{
            this._material[m] = t[m], r.uniforms[`f${r.id}_${m}`] = t[m];
        });
    }
    clone(e) {
        return new Zr(e).copy(this);
    }
    toJSON(e) {
        return {
            id: this.id,
            uuid: this.uuid,
            head: this.head.toJSON(e)
        };
    }
    fromJSON(e, t, r) {
        let n = new $t(e.head.id, void 0, {
            type: e.head.type
        }).fromJSON(e.head, t), s = e.head.next, o = n;
        for(; s != null;)o.next = new $t(s.id, void 0, {
            type: s.type
        }).fromJSON(s, t), s = s.next, o = o.next;
        this._layerNodes = [], this.head = void 0, this.rebuildLayerNodes(this.head, n, !0);
        let a = n;
        for(o = this.head; a.next != null;)this.rebuildLayerNodes(o, a.next, !0), o = o.next, a = a.next;
        return this._material = r, this.id = e.id, this.uuid = e.uuid, this.blendColors(), this.blendAfterColors(), this.blendPositions(), this;
    }
    getLightLayer() {
        var t;
        let e = this.head;
        for(; e !== void 0 && e.type !== "light";)e = (t = e.next) != null ? t : e;
        return e;
    }
    dispose() {
        let e = this.head;
        for(this._layerNodes = [], this.layerCount = 0; e !== void 0;)e.hasOwnProperty("dispose") === !0 && e.dispose(), e = e.next;
        this.head = void 0;
    }
    _createLayer(e) {
        var r, n, s, o, a, l, c, h, u, f, d, p, m, g, v, y, w, b, S, T, A, x, E, _, C, I, N, R, k, G, te, Q, Y, F, z, O, j, q, J, W, ge, oe, le, H, he, K, V, Z, ce, se, pe, ve, me, Pe, ke, L, D, re, ye, Se, Ie, Fe, ue, rt, st, Ee, U, Me, De, Ze, Oe, Qe, Te, $e, lt, dt, Ut, Ur, ia, Nn;
        let t = e.type;
        switch(t){
            case "color":
                {
                    let at = new Ot((r = e.color) != null ? r : 5855577), ut = new Be((n = e.alpha) != null ? n : 1), ft = new Gt("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
                    ft.keywords.alpha = ut;
                    let pt = new ht((s = e.mode) != null ? s : 0);
                    return at.alpha = ut, {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            color: at,
                            alpha: ut,
                            calpha: ft,
                            mode: pt
                        }),
                        color: at,
                        alpha: ft,
                        mode: pt
                    };
                }
            case "texture":
                {
                    let at = (o = e.texture) != null ? o : new Fi, ut = at.matrix;
                    e.mat && ut.copy(e.mat), at.needsUpdate = !0;
                    let ft = new Be((a = e.crop) != null ? a : 0), pt = new ht((l = e.projection) != null ? l : 0), xt = new ht((c = e.axis) != null ? c : 0), It = new ht((h = e.side) != null ? h : 0), P = new Nr(e.size ? new B(e.size[0], e.size[1]) : new B(100, 100)), X = new Be((u = e.alpha) != null ? u : 1), ne = new ht((f = e.mode) != null ? f : 0), ee = new jr(at), fe = new Or((d = e.textureSize) != null ? d : new M(at.image ? at.image.width : 0, at.image ? at.image.height : 0)), Ue = new $h(ee, fe, ft, pt, xt, It, P, X, ne), He = new Gt(Ue.calpha, "f");
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            texture: ee,
                            textureSize: fe,
                            crop: ft,
                            projection: pt,
                            axis: xt,
                            side: It,
                            size: P,
                            mat: Ue.mat,
                            alpha: X,
                            calpha: He,
                            mode: ne
                        }),
                        color: Ue,
                        alpha: He,
                        mode: ne
                    };
                }
            case "matcap":
                {
                    let at = (p = e.texture) != null ? p : new Fi;
                    at.needsUpdate = !0;
                    let ut = new Be((m = e.alpha) != null ? m : 1), ft = new jr(at), pt = new ht((g = e.mode) != null ? g : 0), xt = new hu(ft, ut, pt), It = new Gt(xt.calpha, "f");
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            texture: ft,
                            alpha: ut,
                            calpha: It,
                            mode: pt
                        }),
                        color: xt,
                        alpha: It,
                        mode: pt
                    };
                }
            case "fresnel":
                {
                    let at = new Ot((v = e.color) != null ? v : 16777215), ut = new Be((y = e.bias) != null ? y : .1), ft = new Be((w = e.scale) != null ? w : 1), pt = new Be((b = e.intensity) != null ? b : 2), xt = new Be((S = e.factor) != null ? S : 1), It = new Be((T = e.alpha) != null ? T : 1), P = new ht((A = e.mode) != null ? A : 0), X = new tu(at, ut, ft, pt, xt, It, P), ne = new Gt(X.calpha, "f");
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            color: at,
                            bias: ut,
                            scale: ft,
                            intensity: pt,
                            factor: xt,
                            alpha: It,
                            calpha: ne,
                            mode: P
                        }),
                        color: X,
                        alpha: ne,
                        mode: P
                    };
                }
            case "rainbow":
                {
                    let at = new Be((x = e.filmThickness) != null ? x : 30), ut = new Be((E = e.movement) != null ? E : 0), ft = new Or((_ = e.wavelengths) != null ? _ : new M(0, 0, 0)), pt = new Be((C = e.noiseStrength) != null ? C : 0), xt = new Be((I = e.noiseScale) != null ? I : 1), It = new Or((N = e.offset) != null ? N : new M(0, 0, 0)), P = new Be((R = e.alpha) != null ? R : 1), X = new nu(at, ut, ft, pt, xt, It, P), ne = new Gt(X.calpha, "f"), ee = new ht((k = e.mode) != null ? k : 0);
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            filmThickness: at,
                            movement: ut,
                            wavelengths: ft,
                            noiseStrength: pt,
                            noiseScale: xt,
                            offset: It,
                            alpha: P,
                            calpha: ne,
                            mode: ee
                        }),
                        color: X,
                        alpha: ne,
                        mode: ee
                    };
                }
            case "transmission":
                {
                    let at = new Be((G = e.thickness) != null ? G : 10), ut = new Be((te = e.ior) != null ? te : 1.5), ft = new Be((Q = e.roughness) != null ? Q : .5), pt = new Nr((Y = e.transmissionSamplerSize) != null ? Y : new B(2048, 2048)), xt = (F = e.transmissionSamplerMap) != null ? F : new Fi, It = (z = e.transmissionDepthMap) != null ? z : new Fi, P = new jr(xt), X = new jr(It), ne = window.innerWidth, ee = window.innerHeight, fe = ne >= ee ? new Nr(ee / ne, 1) : new Nr(1, ne / ee), Ue = new Be((O = e.alpha) != null ? O : 1), He = new iu(at, ut, ft, pt, P, X, fe, Ue), nt = new Gt(He.calpha, "f"), it = new ht((j = e.mode) != null ? j : 0);
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            thickness: at,
                            ior: ut,
                            roughness: ft,
                            transmissionSamplerSize: pt,
                            transmissionSamplerMap: P,
                            transmissionDepthMap: X,
                            aspectRatio: fe,
                            alpha: Ue,
                            calpha: nt,
                            mode: it
                        }),
                        color: He,
                        alpha: nt,
                        mode: it
                    };
                }
            case "depth":
                {
                    let at = new ht((q = e.gradientType) != null ? q : 0), ut = new Zh((J = e.smooth) != null ? J : !1), ft = new Be((W = e.near) != null ? W : 50), pt = new Be((ge = e.far) != null ? ge : 200), xt = new Be((oe = e.isVector) != null ? oe : 1), It = new Be((le = e.isWorldSpace) != null ? le : 0), P = new Or((H = e.origin) != null ? H : new M), X = new Or((he = e.direction) != null ? he : new M), ne = new ht((K = e.num) != null ? K : 0), ee;
                    e.colors ? ee = new ps(ne.value + 1, e.colors) : (ee = new ps(ne.value + 1, new Je(0, 0, 0, 1)), ee.value[1] = new Je(1, 1, 1, 1));
                    let fe;
                    e.steps ? fe = new Ko(e.steps.length, e.steps) : (fe = new Ko(10, 1), fe.value[0] = 0);
                    let Ue = new Be((V = e.alpha) != null ? V : 1), He = new ht((Z = e.mode) != null ? Z : 0), nt = new cu(at, ut, ft, pt, xt, It, P, X, ee, fe, ne, Ue), it = new Gt(nt.calpha, "f");
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            gradientType: at,
                            smooth: ut,
                            near: ft,
                            far: pt,
                            isVector: xt,
                            isWorldSpace: It,
                            origin: P,
                            direction: X,
                            colors: ee,
                            steps: fe,
                            num: ne,
                            alpha: Ue,
                            calpha: it,
                            mode: He
                        }),
                        color: nt,
                        alpha: it,
                        mode: He
                    };
                }
            case "noise":
                {
                    let at = new Be((ce = e.scale) != null ? ce : 1), ut = new Or((se = e.size) != null ? se : new M(100, 100, 100)), ft = new Be((pe = e.move) != null ? pe : 1), pt = new Nr((ve = e.fA) != null ? ve : new B(1.7, 9.2)), xt = new Nr((me = e.fB) != null ? me : new B(8.3, 2.8)), It = new Nr((Pe = e.distortion) != null ? Pe : new B(1, 1)), P = new fi(e.colorA), X = new fi(e.colorB), ne = new fi(e.colorC), ee = new fi(e.colorD), fe = new Be((ke = e.alpha) != null ? ke : 1), Ue = new ht((L = e.mode) != null ? L : 0), He = new ht((D = e.noiseType) != null ? D : 0), nt = new au(at, ut, ft, pt, xt, It, P, X, ne, ee, fe, He), it = new Gt(nt.calpha, "f");
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            scale: at,
                            size: ut,
                            move: ft,
                            fA: pt,
                            fB: xt,
                            distortion: It,
                            colorA: P,
                            colorB: X,
                            colorC: ne,
                            colorD: ee,
                            alpha: fe,
                            calpha: it,
                            mode: Ue,
                            noiseType: He
                        }),
                        color: nt,
                        alpha: it,
                        mode: Ue
                    };
                }
            case "normal":
                {
                    let at = new Or((re = e.cnormal) != null ? re : new M(1, 1, 1)), ut = new Be((ye = e.alpha) != null ? ye : 1), ft = new ht((Se = e.mode) != null ? Se : 0), pt = new su(at, ut), xt = new Gt("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
                    return xt.keywords.alpha = ut, {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            cnormal: at,
                            alpha: ut,
                            calpha: xt,
                            mode: ft
                        }),
                        color: pt,
                        alpha: xt,
                        mode: ft
                    };
                }
            case "gradient":
                {
                    let at = new ht((Ie = e.gradientType) != null ? Ie : 0), ut = new Zh((Fe = e.smooth) != null ? Fe : !1), ft;
                    e.colors ? ft = new ps(e.colors.length, e.colors) : (ft = new ps(10, new Je(0, 0, 0, 1)), ft.value[1] = new Je(1, 1, 1, 1));
                    let pt;
                    e.steps ? pt = new Ko(e.steps.length, e.steps) : (pt = new Ko(10, 1), pt.value[0] = 0);
                    let xt = new Nr((ue = e.offset) != null ? ue : new B(0, 0)), It = new Nr((rt = e.morph) != null ? rt : new B(0, 0)), P = new Be((st = e.angle) != null ? st : 0), X = new Be((Ee = e.alpha) != null ? Ee : 1), ne = new ht((U = e.mode) != null ? U : 0), ee = new ou(at, ut, ft, pt, xt, It, P, X), fe = new Gt(ee.calpha, "f");
                    return {
                        layer: new $t(e.id, e.uuid, {
                            type: t,
                            gradientType: at,
                            smooth: ut,
                            colors: ft,
                            steps: pt,
                            offset: xt,
                            morph: It,
                            angle: P,
                            alpha: X,
                            calpha: fe,
                            mode: ne
                        }),
                        color: ee,
                        alpha: fe,
                        mode: ne
                    };
                }
            case "displace":
                {
                    let at = new ht((Me = e.displacementType) != null ? Me : 0);
                    if (at.value === 0) {
                        let ut = new Or((De = e.offset) != null ? De : new M(0, 0, 0)), ft = new Be((Ze = e.scale) != null ? Ze : 10), pt = new Be((Oe = e.intensity) != null ? Oe : 8), xt = new Be((Qe = e.movement) != null ? Qe : 1), It = new Be((Te = e.alpha) != null ? Te : 1), P = new ht(($e = e.mode) != null ? $e : 0), X = new ht((lt = e.noiseType) != null ? lt : 0), ne = new Hl(at, pt, xt, ut, ft, X);
                        return {
                            layer: new $t(e.id, e.uuid, {
                                displacementType: at,
                                type: t,
                                offset: ut,
                                scale: ft,
                                intensity: pt,
                                movement: xt,
                                alpha: It,
                                mode: P,
                                noiseType: X
                            }),
                            position: ne
                        };
                    } else if (at.value === 1) {
                        let ut = (dt = e.texture) != null ? dt : new Fi, ft = ut.matrix;
                        e.mat && ft.copy(e.mat), ut.needsUpdate = !0;
                        let pt = new Be((Ut = e.intensity) != null ? Ut : 8), xt = new jr(ut), It = new Be((Ur = e.crop) != null ? Ur : 0), P = new Be((ia = e.alpha) != null ? ia : 1), X = new ht((Nn = e.mode) != null ? Nn : 0), ne = new Hl(at, pt, xt, It);
                        return {
                            layer: new $t(e.id, e.uuid, {
                                displacementType: at,
                                type: t,
                                intensity: pt,
                                texture: xt,
                                crop: It,
                                mat: ne.mat,
                                alpha: P,
                                mode: X
                            }),
                            position: ne
                        };
                    }
                    return {};
                }
        }
        return {};
    }
    blendColors() {
        let e = this._layerNodes.findIndex((r)=>r.type === "color"
        ), t = this._layerNodes.findIndex((r)=>r.type === "light"
        );
        if (e !== -1 && e < t) {
            let r = this._layerNodes[e].color;
            for(let n = e + 1; n < t; ++n){
                let s = this._layerNodes[n];
                s.type === "color" && (r = new lu(r, s.color, s.alpha, s.mode));
            }
            this._material.color = r;
        } else this._material.color = void 0;
    }
    blendAfterColors() {
        let e = new Gt("outgoingLight", "f"), t = this._layerNodes.findIndex((r)=>r.type === "light"
        );
        if (this._layerNodes.length > t + 1) {
            for(let r = t + 1; r < this._layerNodes.length; ++r){
                let n = this._layerNodes[r];
                n.type === "color" && (e = new lu(e, n.color, n.alpha, n.mode));
            }
            "afterColor" in this._material && (this._material.afterColor = e);
        } else "afterColor" in this._material && (this._material.afterColor = void 0);
    }
    blendPositions() {
        let e = this._layerNodes.filter((t)=>t.type === "position"
        );
        if (e.length > 0) {
            let t = e[0].position;
            for(let r = 1; r < e.length; ++r)e[r] && (t = new Mn(t, e[r].position, Mn.ADD), t = new Mn(t, new Be(.5).setReadonly(!0), Mn.MUL));
            this._material.position = t;
        } else this._material.position = void 0;
    }
    cleanupChangedLayer(e) {
        switch(this._layerNodes = this._layerNodes.filter((t)=>t.id !== e.id
        ), e.type){
            case "displace":
                this.blendPositions();
                break;
            default:
                this.blendColors(), this.blendAfterColors();
                break;
        }
    }
};
var Rn = class extends Mt {
    constructor(t, r, n){
        super(n);
        this.isNodeMaterial = !0;
        this.type = "NodeMaterial";
        this.wireframeLinecap = "";
        this.wireframeLinejoin = "";
        this.uniformsBackup = {};
        this.userData = {
            type: "",
            category: "",
            nodeType: ""
        };
        this.fog = !0, this.vertex = t != null ? t : new Kh(new qr(qr.PROJECTION)), this.fragment = r != null ? r : new Kh(new Ot(5855577)), this.updaters = [], this.isDetached = !0, this.dithering = !0, this.onBeforeCompile = this._onBeforeCompile;
    }
    getDefines() {
        return this.defines;
    }
    getUniforms() {
        return this.uniforms;
    }
    getVertexShader() {
        return this.vertexShader;
    }
    getFragmentShader() {
        return this.fragmentShader;
    }
    _onBeforeCompile(t, r) {
        this.build({
            renderer: r
        }), t.defines = this.defines, t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.extensionDerivatives = this.extensions.derivatives === !0, t.extensionFragDepth = this.extensions.fragDepth === !0, t.extensionDrawBuffers = this.extensions.drawBuffers === !0, t.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === !0;
    }
    _getLayerStack(t) {
        let r = new Zr(this);
        return t && (async ()=>{
            for(; t.image === void 0;)await new Promise((n)=>requestAnimationFrame(n)
            );
            r.addLayerAt(1, {
                type: "texture",
                texture: t
            }), this.dispose();
        })(), r;
    }
    clampUniformsForPreview(t, r) {
        let n = (s, o, a)=>Math.min(Math.max(s, o), a)
        ;
        if (this.userData.layers) {
            for (let s of this.userData.layers.getLayers())if (s.type == "displace") {
                this.uniformsBackup[`f${s.id}_intensity`] = s.uniforms[`f${s.id}_intensity`].value;
                let o = n(s.uniforms[`f${s.id}_intensity`].value, t, r);
                s.uniforms[`f${s.id}_intensity`].value = o;
            }
        }
    }
    restoreClampedUniforms() {
        if (this.userData.layers) for (let t of this.userData.layers.getLayers())t.type == "displace" && (t.uniforms[`f${t.id}_intensity`].value = this.uniformsBackup[`f${t.id}_intensity`]);
    }
    customProgramCacheKey() {
        return this.getHash();
    }
    updateFrame(t) {
        for(let r = 0; r < this.updaters.length; ++r)t.updateNode(this.updaters[r]);
    }
    build(t) {
        var n;
        t = t != null ? t : {};
        let r = (n = t.builder) != null ? n : new Mp;
        return r.setMaterial(this, t.renderer), r.build(this.vertex, this.fragment), this.vertexShader = r.getCode("vertex"), this.fragmentShader = r.getCode("fragment"), this.defines = r.defines, this.uniforms = r.uniforms, this.extensions = r.extensions, this.updaters = r.updaters, this.fog = r.requires.fog, this.lights = r.requires.lights, this.transparent = r.requires.transparent || this.blending > Ps, this;
    }
    getHash() {
        let t = "{";
        return t += '"vertex":' + this.vertex.getHash() + ",", t += '"fragment":' + this.fragment.getHash(), t += "}", t;
    }
    copy(t) {
        let r = this.uuid;
        for(let n in t)this[n] = t[n];
        return this.uuid = r, t.userData !== void 0 && (this.userData = JSON.parse(JSON.stringify(t.userData))), this;
    }
    toJSON(t) {
        let r = this.userData.layers;
        this.userData.layers = void 0;
        let n = super.toJSON(t);
        return n.type = "ShaderMaterial", n.userData = {
            type: this.userData.type,
            category: this.userData.category,
            nodeType: this.type,
            layers: r.toJSON(t)
        }, n.vertex = this.vertex.toJSON(t).uuid, n.fragment = this.fragment.toJSON(t).uuid, delete n.vertexShader, delete n.fragmentShader, delete n.color, delete n.shininess, delete n.specular, delete n.roughness, delete n.metalness, delete n.uniforms, t && !t.materials[this.uuid] && (t.materials[this.uuid] = n), this.userData.layers = r, n;
    }
    fromJSON(t, r) {
        var n;
        this.defines = (n = t.defines) != null ? n : {}, this.depthFunc = t.depthFunc, this.depthWrite = t.depthWrite, this.side = t.side !== void 0 ? t.side : ii, this.transparent = t.transparent, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.wireframe = t.wireframe, this.userData.layers.fromJSON(t.userData.layers, r, this);
    }
};
Object.defineProperties(Rn.prototype, {
    properties: {
        get: function() {
            return this.fragment.properties;
        }
    },
    needsUpdate: {
        set: function(i) {
            i === !0 && this.version++, this.needsCompile = i;
        },
        get: function() {
            return this.needsCompile;
        }
    }
});
var Ap = class extends We {
    constructor(){
        super("basic");
        this.nodeType = "Basic";
        this.color = new Ot(5855577);
    }
    generate(t) {
        let r;
        if (t.isShader("vertex")) {
            let n = this.position ? this.position.analyzeAndFlow(t, "v3", {
                cache: "position"
            }) : void 0;
            t.mergeUniform(li.merge([
                we.fog
            ])), t.addParsCode([
                "varying vec3 vViewPosition;",
                "#include <fog_pars_vertex>",
                "#include <normal_pars_vertex>"
            ].join(`
`));
            let s = [
                "#include <beginnormal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`
            ];
            n && s.push(n.code, n.result ? "displaced_position = " + n.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), s.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), r = s.join(`
`);
        } else {
            this.color === void 0 && (this.color = new Ot(5855577)), this.color.analyze(t, {
                slot: "color"
            }), this.alpha && this.alpha.analyze(t), this.afterColor && this.afterColor.analyze(t, {
                slot: "afterColor"
            });
            let n = this.color.flow(t, "c", {
                slot: "color"
            }), s = this.alpha ? this.alpha.flow(t, "f") : void 0, o = this.afterColor ? this.afterColor.flow(t, "c", {
                slot: "afterColor"
            }) : void 0;
            t.requires.transparent = s !== void 0, t.addParsCode([
                "#include <fog_pars_fragment>",
                "#include <dithering_pars_fragment>",
                "varying vec3 vViewPosition;",
                "#include <normal_pars_fragment>"
            ].join(`
`));
            let a = [
                "#include <normal_fragment_begin>",
                n.code
            ];
            s && a.push(s.code, "#ifdef ALPHATEST", " if ( " + s.result + " <= ALPHATEST ) discard;", "#endif"), o ? a.push(o.code, `vec3 outgoingLight = ${n.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${o.result}, 1.0, SPE_BLENDING_NORMAL);`) : a.push(`vec3 finalColor = ${n.result};`), s ? a.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${s.result} );`) : a.push("gl_FragColor = vec4(" + n.result + ", 1.0 );"), a.push("#include <fog_fragment>", "#include <dithering_fragment>"), r = a.join(`
`);
        }
        return r;
    }
    copy(t) {
        return super.copy(t), t.color && (this.color = t.color.clone()), t.position && (this.position = t.position.clone()), t.alpha && (this.alpha = t.alpha.clone()), t.afterColor && (this.afterColor = t.afterColor.clone()), t.shadingAlpha && (this.shadingAlpha = t.shadingAlpha.clone()), t.shadingBlend && (this.shadingBlend = t.shadingBlend.clone()), this;
    }
};
var Tp = class extends Rn {
    constructor(t = new Ap, r){
        super(t, t, r);
        this.type = "BasicNodeMaterial", this.fragment = t;
    }
    get color() {
        return this.fragment.color;
    }
    set color(t) {
        this.fragment.color = t;
    }
    get afterColor() {
        return this.fragment.afterColor;
    }
    set afterColor(t) {
        this.fragment.afterColor = t;
    }
    get alpha() {
        return this.fragment.alpha;
    }
    set alpha(t) {
        this.fragment.alpha = t;
    }
    get shadingAlpha() {
        return this.fragment.shadingAlpha;
    }
    set shadingAlpha(t) {
        this.fragment.shadingAlpha = t;
    }
    get shadingBlend() {
        return this.fragment.shadingBlend;
    }
    set shadingBlend(t) {
        this.fragment.shadingBlend = t;
    }
    get position() {
        return this.fragment.position;
    }
    set position(t) {
        this.fragment.position = t;
    }
};
var Yr = class extends Tp {
    constructor(e, t, r){
        super(t, e), this.userData.type = "BasicMaterial", this.userData.category = "Basic", this.userData.layers = r != null ? r : this._getLayerStack(e == null ? void 0 : e.map);
    }
    get layersList() {
        return this.userData.layers;
    }
    set layersList(e) {
        this.userData.layers = e;
    }
    equals(e) {
        return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
        if (e.userData.layers !== void 0 && e.userData.layers instanceof Zr) {
            let t = e.userData.layers, r = e.fragment;
            super.copy(e);
            let n = r.clone();
            this.fragment = n, this.vertex = n;
            let s = t.clone(this);
            this.userData.layers = s;
        } else super.copy(e);
        return this;
    }
    static fromJSON(e, t, r) {
        let n = r.getNode(t.vertex), s = new Yr(void 0, n);
        return s.fromJSON(t, r), s;
    }
    static fromMaterial(e) {
        let t = new Yr(e.map ? {
            map: e.map
        } : {}), r = t.fragment;
        return r.color.value.copy(e.color), r.alpha.value = e.opacity, t;
    }
    dispose() {
        super.dispose();
    }
};
var Ep = class extends We {
    constructor(){
        super("phong");
        this.nodeType = "Phong";
        this.color = new Ot(5855577), this.specular = new Ot(1118481), this.shininess = new Be(30), this.shadingAlpha = new Be(1), this.shadingBlend = new ht(0);
    }
    build(t) {
        let r;
        if (t.define("PHONG"), t.requires.lights = !0, t.extensions.derivatives = !0, t.isShader("vertex")) {
            let n = this.position ? this.position.analyzeAndFlow(t, "v3", {
                cache: "position"
            }) : void 0;
            t.mergeUniform(li.merge([
                we.fog,
                we.lights
            ])), t.addParsCode([
                "varying vec3 vViewPosition;",
                "#include <fog_pars_vertex>",
                "#include <normal_pars_vertex>",
                "#include <shadowmap_pars_vertex>",
                "#include <clipping_planes_pars_vertex>"
            ].join(`
`));
            let s = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`
            ];
            n && s.push(n.code, n.result ? "displaced_position = " + n.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), r = s.join(`
`);
        } else {
            this.color === void 0 && (this.color = new Ot(5855577)), this.color.analyze(t, {
                slot: "color"
            }), this.specular.analyze(t), this.shininess.analyze(t), this.shadingAlpha.analyze(t), this.shadingBlend.analyze(t), this.afterColor && this.afterColor.analyze(t, {
                slot: "afterColor"
            }), this.alpha && this.alpha.analyze(t);
            let n = this.color.flow(t, "c", {
                slot: "color"
            }), s = this.specular.flow(t, "c"), o = this.shininess.flow(t, "f"), a = this.shadingAlpha.flow(t, "f"), l = this.shadingBlend.flow(t, "i"), c = this.afterColor ? this.afterColor.flow(t, "c", {
                slot: "afterColor"
            }) : void 0, h = this.alpha ? this.alpha.flow(t, "f") : void 0;
            t.requires.transparent = h !== void 0, t.addParsCode([
                "uniform vec3 emissive;",
                "#include <normal_pars_fragment>",
                "#include <fog_pars_fragment>",
                "#include <bsdfs>",
                "#include <lights_pars_begin>",
                "#include <lights_phong_pars_fragment>",
                "#include <shadowmap_pars_fragment>",
                "#include <dithering_pars_fragment>"
            ].join(`
`));
            let u = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	BlinnPhongMaterial material;"
            ];
            u.push(n.code, "	vec3 diffuseColor = " + n.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", s.code, "	vec3 specular = " + s.result + ";", o.code, "	float shininess = max( 0.0001, " + o.result + " );", "	float specularStrength = 1.0;"), h && u.push(h.code, "#ifdef ALPHATEST", "if ( " + h.result + " <= ALPHATEST ) discard;", "#endif"), u.push("material.diffuseColor = diffuseColor;"), u.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), u.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"), u.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`), c && u.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), h ? u.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result} );`) : u.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), u.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), r = u.join(`
`);
        }
        return r;
    }
    copy(t) {
        return super.copy(t), t.color && (this.color = t.color.clone()), this.specular = t.specular.clone(), this.shininess = t.shininess.clone(), t.position && (this.position = t.position.clone()), t.afterColor && (this.afterColor = t.afterColor.clone()), t.alpha && (this.alpha = t.alpha.clone()), t.shadingAlpha && (this.shadingAlpha = t.shadingAlpha.clone()), t.shadingBlend && (this.shadingBlend = t.shadingBlend.clone()), this;
    }
};
var _p = class extends Rn {
    constructor(t = new Ep, r){
        super(t, t, r);
        this.type = "PhongNodeMaterial", this.fragment = t;
    }
    get color() {
        return this.fragment.color;
    }
    set color(t) {
        this.fragment.color = t;
    }
    get afterColor() {
        return this.fragment.afterColor;
    }
    set afterColor(t) {
        this.fragment.afterColor = t;
    }
    get alpha() {
        return this.fragment.alpha;
    }
    set alpha(t) {
        this.fragment.alpha = t;
    }
    get shadingAlpha() {
        return this.fragment.shadingAlpha;
    }
    set shadingAlpha(t) {
        this.fragment.shadingAlpha = t;
    }
    get shadingBlend() {
        return this.fragment.shadingBlend;
    }
    set shadingBlend(t) {
        this.fragment.shadingBlend = t;
    }
    get position() {
        return this.fragment.position;
    }
    set position(t) {
        this.fragment.position = t;
    }
    get specular() {
        return this.fragment.specular;
    }
    set specular(t) {
        this.fragment.specular = t;
    }
    get shininess() {
        return this.fragment.shininess;
    }
    set shininess(t) {
        this.fragment.shininess = t;
    }
};
var pn = class extends _p {
    constructor(e, t, r){
        super(t, e), this.userData.type = "PhongMaterial", this.userData.category = "Phong", this.userData.layers = r != null ? r : this._getLayerStack(e == null ? void 0 : e.map);
    }
    get layersList() {
        return this.userData.layers;
    }
    set layersList(e) {
        this.userData.layers = e;
    }
    equals(e) {
        return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
        if (e.userData.layers !== void 0 && e.userData.layers instanceof Zr) {
            let t = e.userData.layers, r = e.fragment;
            super.copy(e);
            let n = r.clone();
            this.fragment = n, this.vertex = n;
            let s = t.clone(this);
            this.userData.layers = s, n.shadingAlpha.value = r.shadingAlpha.value, n.shadingBlend.value = r.shadingBlend.value;
        } else super.copy(e);
        return this;
    }
    static fromJSON(e, t, r) {
        let n = r.getNode(t.vertex), s = new pn(void 0, n);
        return s.fromJSON(t, r), s;
    }
    static fromMaterial(e) {
        let t = new pn(e.map ? {
            map: e.map
        } : {}), r = t.fragment;
        return r.color.value.copy(e.color), r.alpha.value = e.opacity, t;
    }
    dispose() {
        super.dispose();
    }
};
var Cp = class extends We {
    constructor(){
        super("lambert");
        this.nodeType = "Lambert";
        this.color = new Ot(5855577), this.emissive = new Ot(0), this.emissiveIntensity = new Be(1), this.shadingAlpha = new Be(1), this.shadingBlend = new ht(0);
    }
    build(t) {
        let r;
        if (t.define("LAMBERT"), t.requires.lights = !0, t.extensions.derivatives = !0, t.isShader("vertex")) {
            let n = this.position ? this.position.analyzeAndFlow(t, "v3", {
                cache: "position"
            }) : void 0;
            t.mergeUniform(li.merge([
                we.fog,
                we.lights
            ])), t.addParsCode([
                "varying vec3 vViewPosition;",
                "varying vec3 vLightFront;",
                "varying vec3 vIndirectFront;",
                "#ifndef DOUBLE_SIDED",
                "   #define DOUBLE_SIDED",
                "#endif",
                "#ifdef DOUBLE_SIDED",
                "	varying vec3 vLightBack;",
                "	varying vec3 vIndirectBack;",
                "#endif",
                "#include <bsdfs>",
                "#include <lights_pars_begin>",
                "#include <color_pars_vertex>",
                "#include <fog_pars_vertex>",
                "#include <normal_pars_vertex>",
                "#include <shadowmap_pars_vertex>",
                "#include <clipping_planes_pars_vertex>"
            ].join(`
`));
            let s = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`
            ];
            n && s.push(n.code, n.result ? "displaced_position = " + n.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), r = s.join(`
`);
        } else {
            this.color === void 0 && (this.color = new Ot(5855577)), this.color.analyze(t, {
                slot: "color"
            }), this.shadingAlpha.analyze(t), this.shadingBlend.analyze(t), this.afterColor && this.afterColor.analyze(t, {
                slot: "afterColor"
            }), this.alpha && this.alpha.analyze(t);
            let n = this.color.flow(t, "c", {
                slot: "color"
            }), s = this.emissive.flow(t, "c", {
                slot: "emissive"
            }), o = this.emissiveIntensity.flow(t, "f", {
                slot: "emissive"
            }), a = this.shadingAlpha.flow(t, "f"), l = this.shadingBlend.flow(t, "i"), c = this.afterColor ? this.afterColor.flow(t, "c", {
                slot: "afterColor"
            }) : void 0, h = this.alpha ? this.alpha.flow(t, "f") : void 0;
            t.requires.transparent = h !== void 0, t.addParsCode([
                "varying vec3 vViewPosition;",
                "varying vec3 vLightFront;",
                "varying vec3 vIndirectFront;",
                "#ifndef DOUBLE_SIDED",
                "   #define DOUBLE_SIDED",
                "#endif",
                "#include <normal_pars_fragment>",
                "#ifdef DOUBLE_SIDED",
                "	varying vec3 vLightBack;",
                "	varying vec3 vIndirectBack;",
                "#endif",
                "#include <bsdfs>",
                "#include <lights_pars_begin>",
                "#include <fog_pars_fragment>",
                "#include <shadowmap_pars_fragment>",
                "#include <shadowmask_pars_fragment>",
                "#include <clipping_planes_pars_fragment>",
                "#include <dithering_pars_fragment>"
            ].join(`
`));
            let u = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,
                "#include <clipping_planes_fragment>"
            ];
            u.push(n.code, "vec3 diffuseColor = " + n.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"), h && u.push(h.code, "#ifdef ALPHATEST", "if ( " + h.result + " <= ALPHATEST ) discard;", "#endif"), u.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"), s && u.push(s.code, "reflectedLight.directDiffuse += " + s.result + " * " + o.result + ";"), u.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;"), u.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`), c && u.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), h ? u.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result} );`) : u.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), u.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), r = u.join(`
`);
        }
        return r;
    }
    copy(t) {
        return super.copy(t), this.emissiveIntensity = t.emissiveIntensity.clone(), t.color && (this.color = t.color.clone()), t.position && (this.position = t.position.clone()), t.afterColor && (this.afterColor = t.afterColor.clone()), t.alpha && (this.alpha = t.alpha.clone()), t.shadingAlpha && (this.shadingAlpha = t.shadingAlpha.clone()), t.shadingBlend && (this.shadingBlend = t.shadingBlend.clone()), t.emissive && (this.emissive = t.emissive.clone()), this;
    }
};
var Dp = class extends Rn {
    constructor(t = new Cp, r){
        super(t, t, r);
        this.type = "LambertNodeMaterial", this.fragment = t;
    }
    get color() {
        return this.fragment.color;
    }
    set color(t) {
        this.fragment.color = t;
    }
    get afterColor() {
        return this.fragment.afterColor;
    }
    set afterColor(t) {
        this.fragment.afterColor = t;
    }
    get alpha() {
        return this.fragment.alpha;
    }
    set alpha(t) {
        this.fragment.alpha = t;
    }
    get shadingAlpha() {
        return this.fragment.shadingAlpha;
    }
    set shadingAlpha(t) {
        this.fragment.shadingAlpha = t;
    }
    get shadingBlend() {
        return this.fragment.shadingBlend;
    }
    set shadingBlend(t) {
        this.fragment.shadingBlend = t;
    }
    get position() {
        return this.fragment.position;
    }
    set position(t) {
        this.fragment.position = t;
    }
    get emissive() {
        return this.fragment.emissive;
    }
    set emissive(t) {
        this.fragment.emissive = t;
    }
    get emissiveIntensity() {
        return this.fragment.emissiveIntensity;
    }
    set emissiveIntensity(t) {
        this.fragment.emissiveIntensity = t;
    }
};
var jl = class extends Dp {
    constructor(e, t, r){
        super(t, e), this.userData.type = "LambertMaterial", this.userData.category = "Lambert", this.userData.layers = r != null ? r : this._getLayerStack(e == null ? void 0 : e.map);
    }
    get layersList() {
        return this.userData.layers;
    }
    set layersList(e) {
        this.userData.layers = e;
    }
    equals(e) {
        return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
        if (e.userData.layers !== void 0 && e.userData.layers instanceof Zr) {
            let t = e.userData.layers, r = e.fragment;
            super.copy(e);
            let n = r.clone();
            this.fragment = n, this.vertex = n;
            let s = t.clone(this);
            this.userData.layers = s, n.shadingAlpha.value = r.shadingAlpha.value, n.shadingBlend.value = r.shadingBlend.value;
        } else super.copy(e);
        return this;
    }
    static fromJSON(e, t, r) {
        let n = r.getNode(t.vertex), s = new jl(void 0, n);
        return s.fromJSON(t, r), s;
    }
    dispose() {
        super.dispose();
    }
};
var Pp = class extends We {
    constructor(){
        super("toon");
        this.nodeType = "Toon";
        this.color = new Ot(5855577), this.specular = new Ot(1118481), this.shininess = new Be(30), this.shadingAlpha = new Be(1), this.shadingBlend = new ht(0);
    }
    build(t) {
        let r;
        if (t.define("TOON"), t.requires.lights = !0, t.extensions.derivatives = !0, t.isShader("vertex")) {
            let n = this.position ? this.position.analyzeAndFlow(t, "v3", {
                cache: "position"
            }) : void 0;
            t.mergeUniform(li.merge([
                we.fog,
                we.lights
            ])), t.addParsCode([
                "varying vec3 vViewPosition;",
                "#include <fog_pars_vertex>",
                "#include <normal_pars_vertex>",
                "#include <shadowmap_pars_vertex>",
                "#include <clipping_planes_pars_vertex>"
            ].join(`
`));
            let s = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`
            ];
            n && s.push(n.code, n.result ? "displaced_position = " + n.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("	#include <project_vertex>", "	#include <fog_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), r = s.join(`
`);
        } else {
            this.color === void 0 && (this.color = new Ot(5855577)), this.color.analyze(t, {
                slot: "color"
            }), this.specular.analyze(t), this.shininess.analyze(t), this.shadingAlpha.analyze(t), this.shadingBlend.analyze(t), this.afterColor && this.afterColor.analyze(t, {
                slot: "afterColor"
            }), this.alpha && this.alpha.analyze(t);
            let n = this.color.flow(t, "c", {
                slot: "color"
            }), s = this.specular.flow(t, "c"), o = this.shininess.flow(t, "f"), a = this.shadingAlpha.flow(t, "f"), l = this.shadingBlend.flow(t, "i"), c = this.afterColor ? this.afterColor.flow(t, "c", {
                slot: "afterColor"
            }) : void 0, h = this.alpha ? this.alpha.flow(t, "f") : void 0;
            t.requires.transparent = h !== void 0, t.addParsCode([
                "#include <normal_pars_fragment>",
                "#include <gradientmap_pars_fragment>",
                "#include <fog_pars_fragment>",
                "#include <bsdfs>",
                "#include <lights_pars_begin>",
                "#include <dithering_pars_fragment>",
                `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,
                "#include <shadowmap_pars_fragment>",
                "#include <bumpmap_pars_fragment>",
                "#include <normalmap_pars_fragment>"
            ].join(`
`));
            let u = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	ToonMaterial material;"
            ];
            u.push(n.code, "	vec3 diffuseColor = " + n.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", s.code, "	vec3 specular = " + s.result + ";", o.code, "	float shininess = max( 0.0001, " + o.result + " );", "	float specularStrength = 1.0;"), h && u.push(h.code, "#ifdef ALPHATEST", "if ( " + h.result + " <= ALPHATEST ) discard;", "#endif"), u.push("material.diffuseColor = diffuseColor;"), u.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), u.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"), u.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`), c && u.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), h ? u.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result} );`) : u.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), u.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), r = u.join(`
`);
        }
        return r;
    }
    copy(t) {
        return super.copy(t), t.color && (this.color = t.color.clone()), this.specular = t.specular.clone(), this.shininess = t.shininess.clone(), t.position && (this.position = t.position.clone()), t.afterColor && (this.afterColor = t.afterColor.clone()), t.alpha && (this.alpha = t.alpha.clone()), t.shadingAlpha && (this.shadingAlpha = t.shadingAlpha.clone()), t.shadingBlend && (this.shadingBlend = t.shadingBlend.clone()), this;
    }
};
var Lp = class extends Rn {
    constructor(t = new Pp, r){
        super(t, t, r);
        this.type = "ToonNodeMaterial", this.fragment = t;
    }
    get color() {
        return this.fragment.color;
    }
    set color(t) {
        this.fragment.color = t;
    }
    get afterColor() {
        return this.fragment.afterColor;
    }
    set afterColor(t) {
        this.fragment.afterColor = t;
    }
    get alpha() {
        return this.fragment.alpha;
    }
    set alpha(t) {
        this.fragment.alpha = t;
    }
    get shadingAlpha() {
        return this.fragment.shadingAlpha;
    }
    set shadingAlpha(t) {
        this.fragment.shadingAlpha = t;
    }
    get shadingBlend() {
        return this.fragment.shadingBlend;
    }
    set shadingBlend(t) {
        this.fragment.shadingBlend = t;
    }
    get position() {
        return this.fragment.position;
    }
    set position(t) {
        this.fragment.position = t;
    }
    get specular() {
        return this.fragment.specular;
    }
    set specular(t) {
        this.fragment.specular = t;
    }
    get shininess() {
        return this.fragment.shininess;
    }
    set shininess(t) {
        this.fragment.shininess = t;
    }
};
var ql = class extends Lp {
    constructor(e, t, r){
        super(t, e), this.userData.type = "ToonMaterial", this.userData.category = "Toon", this.userData.layers = r != null ? r : this._getLayerStack(e == null ? void 0 : e.map);
    }
    get layersList() {
        return this.userData.layers;
    }
    set layersList(e) {
        this.userData.layers = e;
    }
    equals(e) {
        return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
        if (e.userData.layers !== void 0 && e.userData.layers instanceof Zr) {
            let t = e.userData.layers, r = e.fragment;
            super.copy(e);
            let n = r.clone();
            this.fragment = n, this.vertex = n;
            let s = t.clone(this);
            this.userData.layers = s, n.shadingAlpha.value = r.shadingAlpha.value, n.shadingBlend.value = r.shadingBlend.value;
        } else super.copy(e);
        return this;
    }
    static fromJSON(e, t, r) {
        let n = r.getNode(t.vertex), s = new ql(void 0, n);
        return s.fromJSON(t, r), s;
    }
    dispose() {
        super.dispose();
    }
};
var Ip = class extends We {
    constructor(){
        super("standard");
        this.nodeType = "Standard";
        this.color = new Ot(5855577), this.roughness = new Be(.3), this.metalness = new Be(0), this.reflectivity = new Be(.5), this.shadingAlpha = new Be(1), this.shadingBlend = new ht(0);
    }
    build(t) {
        let r;
        if (t.define("STANDARD"), t.requires.lights = !0, t.extensions.derivatives = !0, t.extensions.shaderTextureLOD = !0, t.isShader("vertex")) {
            let n = this.position ? this.position.analyzeAndFlow(t, "v3", {
                cache: "position"
            }) : void 0;
            t.mergeUniform(li.merge([
                we.fog,
                we.lights
            ])), we.LTC_1 && (t.uniforms.ltc_1 = {
                value: void 0
            }, t.uniforms.ltc_2 = {
                value: void 0
            }), t.addParsCode([
                "varying vec3 vViewPosition;",
                "#include <fog_pars_vertex>",
                "#include <normal_pars_vertex>",
                "#include <shadowmap_pars_vertex>",
                "#include <clipping_planes_pars_vertex>"
            ].join(`
`));
            let s = [
                "#include <beginnormal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`
            ];
            n && s.push(n.code, n.result ? "displaced_position = " + n.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), r = s.join(`
`);
        } else {
            let n = {
                gamma: !0
            };
            this.color === void 0 && (this.color = new Ot(5855577)), this.color.analyze(t, {
                slot: "color",
                context: n
            }), this.roughness.analyze(t), this.metalness.analyze(t), this.shadingAlpha.analyze(t), this.shadingBlend.analyze(t), this.afterColor && this.afterColor.analyze(t, {
                slot: "afterColor"
            }), this.alpha && this.alpha.analyze(t), this.reflectivity && this.reflectivity.analyze(t);
            let s = this.color.flow(t, "c", {
                slot: "color",
                context: n
            }), o = this.roughness.flow(t, "f"), a = this.metalness.flow(t, "f"), l = this.shadingAlpha.flow(t, "f"), c = this.shadingBlend.flow(t, "i"), h = this.afterColor ? this.afterColor.flow(t, "c", {
                slot: "afterColor"
            }) : void 0, u = this.alpha ? this.alpha.flow(t, "f") : void 0, f = this.reflectivity ? this.reflectivity.flow(t, "f") : void 0;
            t.requires.transparent = u !== void 0, t.addParsCode([
                "varying vec3 vViewPosition;",
                "#include <normal_pars_fragment>",
                "#include <dithering_pars_fragment>",
                "#include <fog_pars_fragment>",
                "#include <bsdfs>",
                "#include <lights_pars_begin>",
                "#include <lights_physical_pars_fragment>",
                "#include <shadowmap_pars_fragment>"
            ].join(`
`));
            let d = [
                "#include <clipping_planes_fragment>",
                "	#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	PhysicalMaterial material;",
                "	material.diffuseColor = vec3( 1.0 );"
            ];
            d.push(s.code, "	vec3 diffuseColor = " + s.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", o.code, "	float roughnessFactor = " + o.result + ";", a.code, "	float metalnessFactor = " + a.result + ";"), u && d.push(u.code, "#ifdef ALPHATEST", "	if ( " + u.result + " <= ALPHATEST ) discard;", "#endif"), d.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), d.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );", "material.roughness = max( roughnessFactor, 0.0525 );", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"), f ? d.push(f.code, "material.specularColor = mix( vec3( 0.16 * pow2( " + f.result + " ) ), diffuseColor, metalnessFactor );") : d.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"), d.push("#include <lights_fragment_begin>"), d.push("#include <lights_fragment_end>"), d.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${c.result} );
				}
				`), h && d.push(h.code, `outgoingLight = spe_blend(outgoingLight, ${h.result}, 1.0, SPE_BLENDING_NORMAL);`), u ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), r = d.join(`
`);
        }
        return r;
    }
    copy(t) {
        return super.copy(t), t.color && (this.color = t.color.clone()), this.roughness = t.roughness.clone(), this.metalness = t.metalness.clone(), t.position && (this.position = t.position.clone()), t.afterColor && (this.afterColor = t.afterColor.clone()), t.alpha && (this.alpha = t.alpha.clone()), t.reflectivity && (this.reflectivity = t.reflectivity.clone()), t.shadingAlpha && (this.shadingAlpha = t.shadingAlpha.clone()), t.shadingBlend && (this.shadingBlend = t.shadingBlend.clone()), this;
    }
};
var Rp = class extends Rn {
    constructor(t = new Ip, r){
        super(t, t, r);
        this.type = "StandardNodeMaterial", this.fragment = t;
    }
    get color() {
        return this.fragment.color;
    }
    set color(t) {
        this.fragment.color = t;
    }
    get afterColor() {
        return this.fragment.afterColor;
    }
    set afterColor(t) {
        this.fragment.afterColor = t;
    }
    get alpha() {
        return this.fragment.alpha;
    }
    set alpha(t) {
        this.fragment.alpha = t;
    }
    get shadingAlpha() {
        return this.fragment.shadingAlpha;
    }
    set shadingAlpha(t) {
        this.fragment.shadingAlpha = t;
    }
    get shadingBlend() {
        return this.fragment.shadingBlend;
    }
    set shadingBlend(t) {
        this.fragment.shadingBlend = t;
    }
    get position() {
        return this.fragment.position;
    }
    set position(t) {
        this.fragment.position = t;
    }
    get roughness() {
        return this.fragment.roughness;
    }
    set roughness(t) {
        this.fragment.roughness = t;
    }
    get metalness() {
        return this.fragment.metalness;
    }
    set metalness(t) {
        this.fragment.metalness = t;
    }
    get reflectivity() {
        return this.fragment.reflectivity;
    }
    set reflectivity(t) {
        this.fragment.reflectivity = t;
    }
};
var Yl = class extends Rp {
    constructor(e, t, r){
        super(t, e), this.userData.type = "PhysicalMaterial", this.userData.category = "Physical", this.userData.layers = r != null ? r : this._getLayerStack(e == null ? void 0 : e.map);
    }
    get layersList() {
        return this.userData.layers;
    }
    set layersList(e) {
        this.userData.layers = e;
    }
    equals(e) {
        return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
        if (e.userData.layers !== void 0 && e.userData.layers instanceof Zr) {
            let t = e.userData.layers, r = e.fragment;
            super.copy(e);
            let n = r.clone();
            this.fragment = n, this.vertex = n;
            let s = t.clone(this);
            this.userData.layers = s, n.shadingAlpha.value = r.shadingAlpha.value, n.shadingBlend.value = r.shadingBlend.value;
        } else super.copy(e);
        return this;
    }
    static fromJSON(e, t, r) {
        let n = r.getNode(t.vertex), s = new Yl(void 0, n);
        return s.fromJSON(t, r), s;
    }
    dispose() {
        super.dispose();
    }
};
function pr(i, e) {
    let t;
    if (typeof i == "string") {
        let r = e == null ? void 0 : e.getColor(i);
        r ? t = r : (console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"), t = new Wr(0, 0, 0, 0));
    } else return "a" in i ? new Wr(i.r, i.g, i.b, i.a) : new Wr(i.r, i.g, i.b, 1);
    return t;
}
function Bp(i, e) {
    switch(i.data.type){
        case "light":
            return mi(i);
        case "fresnel":
            return AF(i, e);
        case "gradient":
            return TF(i);
        case "depth":
            return EF(i);
        case "normal":
            return _F(i);
        case "noise":
            return CF(i, e);
        case "texture":
            return DF(i, e);
        case "rainbow":
            return PF(i);
        case "transmission":
            return LF(i, e);
        case "matcap":
            return IF(i, e);
        case "displace":
            return RF(i);
        case "color":
        default:
            return MF(i, e);
    }
}
function L1(i) {
    return {
        type: i.data.type
    };
}
function mi(i) {
    let { alpha: e , mode: t  } = i.data;
    return xe(ie({}, L1(i)), {
        alpha: e,
        mode: t
    });
}
function MF(i, e) {
    return xe(ie({}, mi(i)), {
        color: pr(i.data.color, e)
    });
}
function AF(i, e) {
    let { bias: t , scale: r , intensity: n , factor: s , color: o  } = i.data;
    return xe(ie({}, mi(i)), {
        color: pr(o, e),
        bias: t,
        scale: r,
        intensity: n,
        factor: s
    });
}
function TF(i) {
    let { gradientType: e , smooth: t , colors: r , steps: n , angle: s , offset: o , morph: a  } = i.data;
    return xe(ie({}, mi(i)), {
        gradientType: e,
        smooth: t,
        colors: r.map((l)=>new Je(l[0], l[1], l[2], l[3])
        ),
        num: r.length,
        steps: n,
        offset: new B(...o),
        morph: new B(...a),
        angle: s
    });
}
function EF(i) {
    let { gradientType: e , near: t , far: r , isVector: n , isWorldSpace: s , origin: o , direction: a , colors: l , steps: c , smooth: h , num: u  } = i.data;
    return xe(ie({}, mi(i)), {
        gradientType: e,
        near: t,
        far: r,
        isVector: n,
        isWorldSpace: s,
        origin: new M(...o),
        direction: a ? new M(...a) : new M(1, 0, 0),
        num: u,
        colors: l.map((f)=>new Je(f[0], f[1], f[2], f[3])
        ),
        steps: c,
        smooth: h
    });
}
function _F(i) {
    let { cnormal: e  } = i.data;
    return xe(ie({}, mi(i)), {
        cnormal: new M(e[0], e[1], e[2])
    });
}
function CF(i, e) {
    let { data: t  } = i;
    return xe(ie({}, mi(i)), {
        scale: t.scale,
        move: t.move,
        fA: new B(...t.fA),
        fB: new B(...t.fB),
        size: new M(...t.size),
        distortion: new B(...t.distortion),
        colorA: pr(t.colorA, e),
        colorB: pr(t.colorB, e),
        colorC: pr(t.colorC, e),
        colorD: pr(t.colorD, e),
        noiseType: t.noiseType
    });
}
function DF(i, e) {
    let { projection: t , axis: r , side: n , crop: s , size: o  } = i.data, { image: a , wrapping: l , repeat: c , offset: h  } = i.data.texture, u = new Dt, f;
    if (typeof a == "string") f = e == null ? void 0 : e.getImage(a);
    else {
        let d = new Image;
        d.src = co(a.data), d.onload = ()=>{
            e != null && e.onImageLoad && (e == null || e.onImageLoad());
        }, f = d;
    }
    return u.image = f, u.repeat.set(c[0], c[1]), u.offset.set(h[0], h[1]), u.wrapS = u.wrapT = l, xe(ie({}, mi(i)), {
        texture: u,
        mat: new Ft().setUvTransform(h[0], h[1], c[0], c[1], 0, 0, 0),
        crop: s,
        projection: t,
        axis: [
            "x",
            "y",
            "z"
        ].indexOf(r),
        side: [
            2,
            0,
            1
        ].indexOf(n),
        size: o
    });
}
function PF(i) {
    let { data: e  } = i;
    return xe(ie({}, mi(i)), {
        filmThickness: e.filmThickness,
        movement: e.movement,
        wavelengths: new M(...e.wavelengths),
        noiseStrength: e.noiseStrength,
        noiseScale: e.noiseScale,
        offset: new M(...e.offset)
    });
}
function LF(i, e) {
    let { data: t  } = i;
    return xe(ie({}, mi(i)), {
        thickness: t.thickness,
        ior: t.ior,
        roughness: t.roughness,
        transmissionSamplerMap: e.transmissionSamplerMap,
        transmissionDepthMap: e.transmissionDepthMap
    });
}
function IF(i, e) {
    let t = new Dt, { image: r  } = i.data.texture, n;
    if (typeof r == "string") n = e == null ? void 0 : e.getImage(r);
    else {
        let o = new Image;
        o.src = co(r.data), o.onload = ()=>{
            e != null && e.onImageLoad && (e == null || e.onImageLoad());
        }, n = o;
    }
    t.image = n;
    let s = 16777215;
    return xe(ie({}, mi(i)), {
        color: s,
        texture: t
    });
}
function RF(i) {
    let { data: e  } = i, t = xe(ie({}, L1(i)), {
        intensity: e.intensity
    });
    if (e.displacementType === "noise") return xe(ie({}, t), {
        offset: new M(...e.offset),
        scale: e.scale,
        movement: e.movement,
        noiseType: e.noiseType
    });
    {
        let r = new Dt, n = new Ft().setUvTransform(0, 0, 1, 1, 0, 0, 0);
        return xe(ie({}, t), {
            texture: r,
            mat: n,
            crop: e.crop
        });
    }
}
function Np(i, e, t) {
    if (t.type === "displace" && (i === "intensity" || i === "visible")) {
        let r = e.uniforms[`f${e.id}_intensity`];
        return r ? (r.value = t.intensity * (t.visible ? 1 : 0), r) : void 0;
    }
    if (t.type !== "displace" && (i === "alpha" || i === "visible")) {
        let r = e.uniforms[`f${e.id}_alpha`];
        return r ? (r.value = t.alpha * (t.visible ? 1 : 0), r) : void 0;
    }
}
var Xl;
((e)=>{
    function i(t) {
        return new be(t.x, t.y, t.z).getHex();
    }
    e.getHex = i;
})(Xl || (Xl = {}));
var I1;
((e)=>{
    function i(t) {
        return new Je(t.r, t.g, t.b, t.a);
    }
    e.getThreeVector4 = i;
})(I1 || (I1 = {}));
var R1;
((t)=>{
    function i(r, n) {
        r.setRGB(n.r, n.g, n.b);
    }
    t.setThreeColor = i;
    function e(r) {
        return new be(r.r, r.g, r.b).getHex();
    }
    t.getHex = e;
})(R1 || (R1 = {}));
function uu(i, e) {
    return typeof i == "string" ? e.getMaterialOrDeletedPlaceholder(i) : Tv(i, e);
}
function B1(i, e) {
    return i.map((t)=>uu(t, e)
    );
}
function Tv(i, e) {
    var o, a;
    let t = (o = i.layers) != null ? o : hi.defaultTwoLayerData("phong").layers, r = BF(t), n;
    switch(r.category){
        case "basic":
            n = new Yr;
            break;
        case "lambert":
            n = new jl;
            break;
        case "toon":
            n = new ql;
            break;
        case "physical":
            n = new Yl;
            break;
        case "phong":
        default:
            n = new pn;
            break;
    }
    n.name = (a = i.name) != null ? a : "Untitled Material";
    let s = n.userData.layers;
    NF(s);
    for(let l = t.length - 1; l >= 0; l--)OF(s, t[l], e);
    switch(r.category){
        case "basic":
            break;
        case "lambert":
            {
                let h = n, f = pr(r.emissive, e);
                f instanceof be ? h.emissive.value = f : h.emissive.value.setHex(Xl.getHex(f));
                break;
            }
        case "toon":
            {
                let h = n, u = r;
                h.shininess.value = u.shininess;
                let f = pr(u.specular, e);
                f instanceof be ? h.specular.value = f : h.specular.value.setHex(Xl.getHex(f));
                break;
            }
        case "physical":
            let l15 = n, c = r;
            l15.metalness.value = c.metalness, l15.roughness.value = c.roughness, l15.reflectivity.value = c.reflectivity;
            break;
        case "phong":
        default:
            {
                let h = n, u = r;
                h.shininess.value = u.shininess;
                let f = pr(u.specular, e);
                f instanceof be ? h.specular.value = f : h.specular.value.setHex(Xl.getHex(f));
                break;
            }
    }
    return s.blendColors(), s.blendAfterColors(), s.blendPositions(), n;
}
function BF(i) {
    for (let e of i)if (e.data.type === "light") return e.data;
    return {
        type: "light",
        category: "basic",
        visible: !0,
        alpha: 1,
        mode: 0
    };
}
function NF(i) {
    for (let e of i.getLayers())i.removeLayer(e.id);
}
function OF(i, e, t) {
    let r = Bp(e, t);
    r.type === "transmission" && (r.transmissionSamplerMap = t == null ? void 0 : t.transmissionSamplerMap, r.transmissionDepthMap = t == null ? void 0 : t.transmissionDepthMap);
    let n = i.addLayer(r);
    n.uuid = e.id;
    for(let s in e.data)Np(s, n, e.data);
}
var Zo = (i)=>"isEntity" in i
, er = (i)=>"isAbstractMesh" in i
, Lt = (i)=>i !== null && i.isBooleanMesh
, N1 = (i)=>i.objectType === "CombinedCamera"
, O1 = (i)=>Zo(i) && (i.objectType === "LightDirectional" || i.objectType === "LightSpot" || i.objectType === "LightPoint")
;
var ms = (i)=>"objectHelper" in i
;
function Ev(i, e) {
    var r;
    let t = !1;
    e.position && (i.position.fromArray(e.position), t = !0), e.rotation && (i.rotation.fromArray(e.rotation), t = !0), e.scale && (t = !0, i.scale.fromArray(e.scale)), e.hiddenMatrix !== void 0 && "hiddenMatrix" in i && (t = !0, i.hiddenMatrix.fromArray((r = e.hiddenMatrix) != null ? r : Pi.identity)), t && (i.updateMatrix(), Lt(i.parent) && er(i) && i.invalidateDownstreamBooleanData(!0).recomputeBoolean()), e.position && e.rotation && e.scale && e.hiddenMatrix !== void 0 && i.updateWorldMatrix(!1, !0), i.objectType === "CombinedCamera" && (e.isUpVectorFlipped !== void 0 && (i.isUpVectorFlipped = e.isUpVectorFlipped), i.updateUp());
}
function FF(i, e) {
    Ev(i, e), e.name !== void 0 && (i.name = e.name), e.visible !== void 0 && (i.isEntity ? i.visibility = e.visible : i.visible = e.visible);
}
function F1(i, e, t) {
    FF(i, e), e.color !== void 0 && (i.color = pr(e.color, t)), e.intensity !== void 0 && (i.intensity = e.intensity), e.shadows !== void 0 && !(i instanceof Hs) && (i.castShadow = e.shadows), i.shadow && !(i instanceof Hs) && e.depth !== void 0 && (i.shadow.camera.far = e.depth, i.shadow.needsUpdate = !0), e.helper !== void 0 && ms(i) && (i.enableHelper = e.helper, i.gizmos.shadowmap.visible = e.helper);
}
function U1(i, e) {
    i.shadow.camera.right = e / 2, i.shadow.camera.left = -e / 2, i.shadow.camera.top = e / 2, i.shadow.camera.bottom = -e / 2, i.shadow.needsUpdate = !0;
}
var Ql = new Kt, Xr = new M, Ge = new M, wr = new Ae;
function UF(i, e, t = 0, r = e.count) {
    let n = 1 / 0, s = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0, c = -1 / 0;
    for(let h = t; h < r; h++){
        let u = e.getX(h), f = e.getY(h), d = e.getZ(h);
        u < n && (n = u), f < s && (s = f), d < o && (o = d), u > a && (a = u), f > l && (l = f), d > c && (c = d);
    }
    return i.min.set(n, s, o), i.max.set(a, l, c), i;
}
var z1 = (i, e, t, r)=>{
    var n;
    if (er(i)) {
        let s = i.geometry.userData.parameters, o = i.geometry.getAttribute("position");
        i.geometry.userData.type === "SubdivGeometry" ? Xr.copy(i.originalGeometry.boundingSphere.center) : o !== void 0 && (UF(Ql, o, i.geometry.drawRange.start, i.geometry.drawRange.count < 1 / 0 ? i.geometry.drawRange.count : o.count), Ql.getCenter(Xr)), i.forceComputeSize ? Ql.getSize(Ge).multiplyScalar(.5) : Ge.set(s.width, s.height, (n = s.depth) != null ? n : 0).multiplyScalar(.5);
    } else if (ms(i) && r === !0) {
        let s = i.geometryHelper.getAttribute("position");
        Ql.setFromArray(s.array), Ql.getCenter(Xr), Ql.getSize(Ge).multiplyScalar(.5);
    } else Xr.setScalar(0), Ge.setScalar(0);
    wr.copy(e).multiply(i.matrixWorld), Ge.x === 0 && Ge.y === 0 && Ge.z === 0 ? t.push(new M(Xr.x, Xr.y, Xr.z).applyMatrix4(wr)) : t.push(new M(-Ge.x, Ge.y, Ge.z).add(Xr).applyMatrix4(wr), new M(-Ge.x, -Ge.y, Ge.z).add(Xr).applyMatrix4(wr), new M(Ge.x, -Ge.y, Ge.z).add(Xr).applyMatrix4(wr), new M(Ge.x, Ge.y, Ge.z).add(Xr).applyMatrix4(wr), new M(-Ge.x, Ge.y, -Ge.z).add(Xr).applyMatrix4(wr), new M(-Ge.x, -Ge.y, -Ge.z).add(Xr).applyMatrix4(wr), new M(Ge.x, -Ge.y, -Ge.z).add(Xr).applyMatrix4(wr), new M(Ge.x, Ge.y, -Ge.z).add(Xr).applyMatrix4(wr));
}, fu = class extends Kt {
    constructor(){
        super(...arguments);
        this.matrix = new Ae;
        this.vertices = [];
        this.faces = [];
        this.edges = [];
        this.centerEdges = [];
    }
    copy(t) {
        return super.copy(t), this.matrix.copy(t.matrix), this.vertices = t.vertices.map((r)=>r.clone()
        ), this.faces = t.faces.map((r)=>r.clone()
        ), this.edges = t.edges.map((r)=>r.clone()
        ), this.centerEdges = t.centerEdges.map((r)=>r.clone()
        ), this;
    }
    setFromObjectSize(t, r = !1) {
        t.updateWorldMatrix(!1, r), this.makeEmpty(), this.matrix.copy(t.matrixWorld);
        let n = new Ae().copy(t.matrixWorld).invert();
        return this.expandByObjectSize(t, n, r);
    }
    expandByObjectSize(t, r, n = !1) {
        let s = [];
        return n === !0 ? t.traverseEntity((o)=>{
            o.visible && z1(o, r, s, t.enableHelper === !0);
        }) : z1(t, r, s, t.enableHelper === !0), this.setFromPoints(s);
    }
    getCenter(t) {
        return t = super.getCenter(t), t.applyMatrix4(this.matrix), t;
    }
    getPositionToCenter(t) {
        return t = super.getCenter(t), t.applyMatrix4(wr.copy(this.matrix).setPosition(0, 0, 0)), t;
    }
    computeVertices() {
        this.getSize(Ge).multiplyScalar(.5), this.getCenter(Xr), wr.copy(this.matrix).setPosition(Xr), this.vertices = [
            new M(-Ge.x, Ge.y, Ge.z).applyMatrix4(wr),
            new M(-Ge.x, -Ge.y, Ge.z).applyMatrix4(wr),
            new M(Ge.x, -Ge.y, Ge.z).applyMatrix4(wr),
            new M(Ge.x, Ge.y, Ge.z).applyMatrix4(wr),
            new M(-Ge.x, Ge.y, -Ge.z).applyMatrix4(wr),
            new M(-Ge.x, -Ge.y, -Ge.z).applyMatrix4(wr),
            new M(Ge.x, -Ge.y, -Ge.z).applyMatrix4(wr),
            new M(Ge.x, Ge.y, -Ge.z).applyMatrix4(wr)
        ];
    }
    computeEdges() {
        this.vertices.length > 0 && this.computeVertices(), this.edges = [
            new Jr(this.vertices[0], this.vertices[3]),
            new Jr(this.vertices[1], this.vertices[2]),
            new Jr(this.vertices[5], this.vertices[6]),
            new Jr(this.vertices[4], this.vertices[7]),
            new Jr(this.vertices[0], this.vertices[1]),
            new Jr(this.vertices[3], this.vertices[2]),
            new Jr(this.vertices[7], this.vertices[6]),
            new Jr(this.vertices[4], this.vertices[5]),
            new Jr(this.vertices[0], this.vertices[4]),
            new Jr(this.vertices[1], this.vertices[5]),
            new Jr(this.vertices[2], this.vertices[6]),
            new Jr(this.vertices[3], this.vertices[7])
        ], this.centerEdges = this.edges.map((t)=>t.getCenter(new M)
        );
    }
    computeFaces() {
        this.vertices.length > 0 && this.computeVertices(), this.faces = [
            new M().copy(this.vertices[0]).sub(this.vertices[2]).multiplyScalar(.5).add(this.vertices[2]),
            new M().copy(this.vertices[7]).sub(this.vertices[5]).multiplyScalar(.5).add(this.vertices[5]),
            new M().copy(this.vertices[4]).sub(this.vertices[1]).multiplyScalar(.5).add(this.vertices[1]),
            new M().copy(this.vertices[3]).sub(this.vertices[6]).multiplyScalar(.5).add(this.vertices[6]),
            new M().copy(this.vertices[4]).sub(this.vertices[3]).multiplyScalar(.5).add(this.vertices[3]),
            new M().copy(this.vertices[1]).sub(this.vertices[6]).multiplyScalar(.5).add(this.vertices[6])
        ];
    }
};
function du(i) {
    let e = [];
    for(let t in i){
        let r = i[t];
        delete r.metadata, e.push(r);
    }
    return e;
}
function zF(i) {
    let e = [];
    for(let t in i)e.push(i[t]);
    return e;
}
var Op = (i)=>class extends i {
        hasEntityChild() {
            return this.children.some((t)=>Zo(t)
            );
        }
        isDescendantOf(t) {
            t instanceof ot && (t = t.uuid);
            let r = this;
            for(; r.parent;){
                if (r.parent.uuid === t) return !0;
                r = r.parent;
            }
            return !1;
        }
        attach(t, r) {
            this.updateWorldMatrix(!0, !1);
            let n = new Ae().copy(this.matrixWorld).invert();
            return t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), n.multiply(t.parent.matrixWorld)), Zo(t) ? t.hiddenMatrix.premultiply(n) : t.applyMatrix4(n), t.updateWorldMatrix(!1, !1), this.add(t), r !== void 0 && (this.children.pop(), this.children.splice(r, 0, t)), this;
        }
        copy(t, r = !0) {
            if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), r === !0) for(let n = 0; n < t.children.length; n++){
                let s = t.children[n];
                this.add(s.clone());
            }
            return this;
        }
        toJSON(t) {
            let r = t === void 0, n = {
                object: {
                    uuid: "",
                    objectType: ""
                }
            };
            t === void 0 && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                interactionStates: {},
                nodes: {}
            }, n.metadata = {
                version: 1.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            let s = {
                uuid: this.uuid,
                objectType: this.type
            };
            if (this.name !== "" && (s.name = this.name), s.matrix = this.matrix.toArray(), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), s.layers = this.layers.mask, JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), this.children.length > 0) {
                s.children = [];
                for (let o of this.children)(Zo(o) || o instanceof bn) && s.children.push(o.toJSON(t).object);
            }
            if (r) {
                let o = du(t.geometries), a = du(t.materials), l = du(t.textures), c = du(t.images), h = du(t.interactionStates), u = zF(t.nodes);
                o.length > 0 && (n.geometries = o), a.length > 0 && (n.materials = a), l.length > 0 && (n.textures = l), c.length > 0 && (n.images = c), h.length > 0 && (n.interactionStates = h), u.length > 0 && (n.nodes = u);
            }
            return n.object = s, n;
        }
        fromJSON(t) {
            return this.uuid = t.uuid, t.name !== void 0 && (this.name = t.name), t.matrix !== void 0 ? (this.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (this.matrixAutoUpdate = t.matrixAutoUpdate), this.matrixAutoUpdate && this.matrix.decompose(this.position, this.quaternion, this.scale)) : (t.position !== void 0 && this.position.fromArray(t.position), t.rotation !== void 0 && this.rotation.fromArray(t.rotation), t.quaternion !== void 0 && this.quaternion.fromArray(t.quaternion), t.scale !== void 0 && this.scale.fromArray(t.scale)), this.castShadow = t.castShadow !== void 0, this.receiveShadow = t.receiveShadow !== void 0, t.visible !== void 0 && (this.visible = t.visible), t.frustumCulled !== void 0 && (this.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (this.renderOrder = t.renderOrder), t.layers !== void 0 && (this.layers.mask = t.layers), t.userData !== void 0 && (this.userData = t.userData), this;
        }
    }
;
var Xn = (i)=>"isEntity" in i
, G1 = (i)=>"isAbstractMesh" in i
, Qn = (i)=>class extends Op(i) {
        constructor(){
            super(...arguments);
            this.objectType = "";
            this.isEntity = !0;
            this.raycastLock = !1;
            this.scaleLock = !1;
            this.hiddenMatrix = new Ae;
            this._singleBBox = new fu;
            this._recursiveBBox = new fu;
            this.singleBBoxNeedsUpdate = !0;
            this.recursiveBBoxNeedsUpdate = !0;
            this.forceComputeSize = !1;
        }
        set visibility(r) {
            this.visible = r;
            for (let n of this.children)Xn(n) && n.traverseEntity((s)=>{
                ms(s) && s.visible && (s.objectHelper.visible = r);
            });
        }
        get visibility() {
            return this.visible;
        }
        get singleBBox() {
            return this.singleBBoxNeedsUpdate && (this.singleBBoxNeedsUpdate = !1, this._singleBBox.setFromObjectSize(this, !1), this._singleBBox.computeVertices(), this._singleBBox.computeEdges(), this._singleBBox.computeFaces()), this._singleBBox;
        }
        get recursiveBBox() {
            return this.recursiveBBoxNeedsUpdate && (this.recursiveBBoxNeedsUpdate = !1, this._recursiveBBox.setFromObjectSize(this, !0), this._recursiveBBox.computeVertices(), this._recursiveBBox.computeEdges(), this._recursiveBBox.computeFaces()), this._recursiveBBox;
        }
        resetBBoxNeedsUpdate() {
            this.singleBBoxNeedsUpdate = !0, this.recursiveBBoxNeedsUpdate = !0, this.traverseAncestors((r)=>{
                Xn(r) && (r.singleBBoxNeedsUpdate = !0, r.recursiveBBoxNeedsUpdate = !0);
            }), this.traverseEntity((r)=>{
                r.singleBBoxNeedsUpdate = !0, r.recursiveBBoxNeedsUpdate = !0;
            });
        }
        traverseEntity(r) {
            r(this);
            for (let n of this.children)Xn(n) && n.traverseEntity(r);
        }
        updateMatrixWorld(r) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || r) && (this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, r = !0);
            for (let n of this.children)n.updateMatrixWorld(r);
        }
        updateWorldMatrix(r, n) {
            let s = this.parent;
            if (r && s !== null && s.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), n) for (let o of this.children)o.updateWorldMatrix(!1, !0);
        }
        shallowClone(r) {
            return new this.constructor().shallowCopy(this, r);
        }
        shallowCopy(r, n = !0) {
            if (super.copy(r, !1), this.raycastLock = r.raycastLock, this.scaleLock = r.scaleLock, this.hiddenMatrix.copy(r.hiddenMatrix), n === !0) for (let s of r.children)Xn(s) && this.add(s.shallowClone());
            return this;
        }
        clone(r) {
            return new this.constructor().copy(this, r);
        }
        copy(r, n = !0) {
            if (super.copy(r, !1), this.raycastLock = r.raycastLock, this.scaleLock = r.scaleLock, this.hiddenMatrix.copy(r.hiddenMatrix), n === !0) for (let s of r.children)Xn(s) && this.add(s.clone());
            return this;
        }
        keepChildrenMatrixWorld() {
            let r = new Ae, n = this.matrixWorld.clone();
            this.updateWorldMatrix(!1, !1), r.copy(this.matrixWorld).invert(), r.multiply(n);
            for (let s of this.children)Xn(s) && s.hiddenMatrix.premultiply(r);
        }
        toJSON(r) {
            let n = super.toJSON(r), s = n.object;
            return this.raycastLock === !0 && (s.raycastLock = !0), this.scaleLock === !0 && (s.scaleLock = !0), s.hiddenMatrix = this.hiddenMatrix.toArray(), n;
        }
        fromJSON(r) {
            return super.fromJSON(r), r.raycastLock !== void 0 && (this.raycastLock = r.raycastLock), r.scaleLock !== void 0 && (this.scaleLock = r.scaleLock), this.hiddenMatrix.fromArray(r.hiddenMatrix), this;
        }
        fromObject3D(r) {
            let n = r.children;
            return r.children = [], Object.assign(r, {
                raycastLock: !1,
                scaleLock: !1,
                hiddenMatrix: new Ae
            }), this.copy(r), r.children = n, this;
        }
        toObjectTransformState(r = []) {
            this.updateWorldMatrix(!0, !1);
            let n = {
                position: this.position.toArray(),
                rotation: [
                    this.rotation.x,
                    this.rotation.y,
                    this.rotation.z
                ],
                scale: this.scale.toArray(),
                hiddenMatrix: this.hiddenMatrix.toArray()
            };
            return wl(n, r);
        }
        fromObjectTransformState(r) {
            return r.position && this.position.fromArray(r.position), r.rotation && this.rotation.fromArray(r.rotation), r.scale && this.scale.fromArray(r.scale), r.hiddenMatrix && this.hiddenMatrix.fromArray(r.hiddenMatrix), this.updateMatrix(), this;
        }
        toState(r = []) {
            let n = ie({
                name: this.name,
                visible: this.visible,
                raycastLock: this.raycastLock
            }, this.toObjectTransformState(r));
            return wl(n, r);
        }
        fromState(r, n) {
            return r.name && (this.name = r.name), r.raycastLock !== void 0 && (this.raycastLock = r.raycastLock), r.type !== "OrthographicCamera" && r.type !== "PerspectiveCamera" && (this.matrixAutoUpdate = !1), r.visible !== void 0 && (this.visibility = r.visible), this.fromObjectTransformState(r), this;
        }
    }
;
var pu = class extends ot {
    constructor(t, r = {}){
        super();
        this.object = t;
        let n = t.recursiveBBox.getSize(new M), s = .1;
        this.parameters = Ud.defaultData(n.toArray(), s), Vo(this.parameters, r), this.update(), this.setHideBase(this.parameters.hideBase);
    }
    refreshMaterial() {
        if ("material" in this.object) for (let t of this.children)t.material = this.object.material;
    }
    setHideBase(t) {
        if ("material" in this.object) {
            if (Array.isArray(this.object.material)) {
                if (this.children.length > 0) {
                    for (let r of this.object.material)r.visible = !0;
                    if (t) {
                        let r = this.object.material.map((n)=>n.clone()
                        );
                        for (let n12 of this.children)n12.material = r;
                    } else for (let r14 of this.children)r14.material = this.object.material;
                }
                for (let r of this.object.material)r.visible = !t;
            } else {
                if (this.children.length > 0) {
                    if (this.object.material.visible = !0, t) {
                        let r = this.object.material.clone();
                        for (let n of this.children)n.material = r;
                    } else for (let r of this.children)r.material = this.object.material;
                }
                this.object.material.visible = !t;
            }
            this.parameters.hideBase = t;
        }
    }
    update() {
        switch(this._updateCount(), this.parameters.type){
            case "radial":
                this._updateRadial(this.parameters);
                break;
            case "linear":
                this._updateLinear(this.parameters);
                break;
            case "grid":
                this._updateGrid(this.parameters);
        }
        this.children.forEach((t)=>t.updateMatrix()
        );
    }
    _updateCount() {
        let t = this.parameters.type === "grid" ? this.parameters.grid.count[0] * this.parameters.grid.count[1] * this.parameters.grid.count[2] : this.parameters.count;
        if (this.children.length !== t) {
            if (this.children.length < t) for(let r = 0, n = t - this.children.length; r < n; ++r){
                let s = this.object.shallowClone(!1);
                s.visible = !0, this.add(s), this.parameters.hideBase && this.setHideBase(!0);
            }
            else for(let r15 = 0, n17 = this.children.length - t; r15 < n17; ++r15)this.remove(this.children[0]);
        }
    }
    _updateRadial(t) {
        let r = t.radial, n = r.start * et.DEG2RAD, s = r.end * et.DEG2RAD, o = n - s, a = new yn(r.rotation[0] * et.DEG2RAD, r.rotation[1] * et.DEG2RAD, r.rotation[2] * et.DEG2RAD), l;
        switch(r.axis){
            case "z":
                l = new M(0, 0, 1);
                break;
            case "y":
                l = new M(0, 1, 0);
                break;
            default:
            case "x":
                l = new M(1, 0, 0);
                break;
        }
        for (let [c, h] of this.children.entries()){
            h.hiddenMatrix.identity(), h.scale.x = r.scale[0], h.scale.y = r.scale[1], h.scale.z = r.scale[2], h.position.setScalar(0);
            let u = o / t.count * c - n;
            switch(r.axis){
                case "x":
                    h.rotation.set(0, u, 0);
                    break;
                case "y":
                    h.rotation.set(0, 0, u);
                    break;
                case "z":
                    h.rotation.set(u, 0, 0);
                    break;
            }
            h.translateOnAxis(l, r.radius), h.position.x += r.position[0], h.position.y += r.position[1], h.position.z += r.position[2], r.alignment === !0 ? (h.rotation.x += a.x, h.rotation.y += a.y, h.rotation.z += a.z) : h.rotation.copy(a);
        }
    }
    _updateLinear(t) {
        if (t.type !== "linear") throw new Error;
        let r = t.linear, n = new yn(r.rotation[0] * et.DEG2RAD, r.rotation[1] * et.DEG2RAD, r.rotation[2] * et.DEG2RAD);
        for (let [s, o] of this.children.entries())o.hiddenMatrix.identity(), o.scale.x = 1 + (r.scale[0] - 1) * s, o.scale.y = 1 + (r.scale[1] - 1) * s, o.scale.z = 1 + (r.scale[2] - 1) * s, o.rotation.x = n.x * s, o.rotation.y = n.y * s, o.rotation.z = n.z * s, o.position.x = r.position[0] * s, o.position.y = r.position[1] * s, o.position.z = r.position[2] * s;
    }
    _updateGrid(t) {
        let r = 0, n = t.grid;
        if (n.useCenter === !0) {
            let s = {
                x: n.count[0] % 2 === 0 ? 2 : 1,
                y: n.count[1] % 2 === 0 ? 2 : 1,
                z: n.count[2] % 2 === 0 ? 2 : 1
            }, o = new M(n.size[0] * (n.count[0] - s.x) * .5, n.size[1] * (n.count[1] - s.y) * .5, n.size[2] * (n.count[2] - s.z) * .5);
            for(let a = 0; a < n.count[0]; a++)for(let l = 0; l < n.count[1]; l++)for(let c = 0; c < n.count[2]; c++){
                let h = this.children[r++];
                h.hiddenMatrix.identity(), h.scale.setScalar(1), h.rotation.set(0, 0, 0), h.position.x = n.size[0] * a - o.x, h.position.y = n.size[1] * l - o.y, h.position.z = n.size[2] * c - o.z;
            }
        } else for(let s = 0; s < n.count[0]; s++)for(let o = 0; o < n.count[1]; o++)for(let a = 0; a < n.count[2]; a++){
            let l = this.children[r++];
            l.hiddenMatrix.identity(), l.scale.setScalar(1), l.rotation.set(0, 0, 0), l.position.x = n.size[0] * s, l.position.y = -n.size[1] * o, l.position.z = -n.size[2] * a;
        }
    }
    fromJSON(t) {
        return this;
    }
    toJSON() {
        return {};
    }
    fromClonerState(t) {
        return t.hideBase !== void 0 && this.setHideBase(t.hideBase), Vo(this.parameters, t), this.update(), this;
    }
};
var kt = class extends Qn(Vt) {
    constructor(t, r){
        super(t, r);
        this.isAbstractMesh = !0;
        this.isBooleanMesh = !1;
        this.booleanMeshSetAddress = -1;
        this.booleanWasTransformed = !1;
        this.booleanMatrixInvOld = new Ae;
        this.booleanExclude = null;
        Array.isArray(r) && (this.selectedMaterial = 0, t.groups.length === 0 && t.addGroup(0, t.getAttribute("position").count, 0));
    }
    get cloner() {
        return this._cloner;
    }
    set cloner(t) {
        this._cloner && this.remove(this._cloner), t && this.add(t), this._cloner = t;
    }
    getSelectedMaterial(t) {
        return Array.isArray(this.material) ? (this.selectedMaterial === void 0 && (this.selectedMaterial = t != null ? t : 0), this.material[t != null ? t : this.selectedMaterial]) : this.material;
    }
    setSelectedMaterial(t, r) {
        Array.isArray(this.material) ? (this.selectedMaterial === void 0 && (this.selectedMaterial = r != null ? r : 0), r = r != null ? r : this.selectedMaterial, this.material[r].dispose(), this.material[r] = t) : (this.material.dispose(), this.material = t);
    }
    updateGeometry(t) {
        let r = this.geometry, n = _v[r.userData.type], s = this.objectType === "NonParametric" ? Object.assign({}, r.userData, {
            geometry: r
        }) : r.userData, o = n.build(n.normalizeInputs(t, s)), a = r.uuid;
        if (this.geometry.dispose(), this.geometry = o, this.geometry.uuid = a, this.geometry.computeBoundingSphere(), this.cloner) for (let l of this.cloner.children)l.geometry = this.geometry;
    }
    resizeGeometry(t, r, n) {
        Xh.resizeGeometry(this.geometry, {
            width: t,
            height: r,
            depth: n
        });
    }
    shallowClone(t) {
        return new this.constructor(this.geometry, this.material).shallowCopy(this, t);
    }
    clone(t) {
        let r = this.objectType === "NonParametric" ? Object.assign({}, this.geometry.userData, {
            geometry: this.geometry.clone()
        }) : this.geometry.userData, n = mu(r), s = Array.isArray(this.material) ? this.material.map((o)=>o.clone()
        ) : this.material.clone();
        return new this.constructor(n, s).copy(this, t);
    }
    copy(t, r = !0) {
        return super.copy(t, r), t.cloner && (this.cloner = new pu(t, t.cloner.parameters), this.add(this.cloner)), this;
    }
    setFromClonerState(t) {
        t === null ? this.cloner = void 0 : (this.cloner === void 0 && (this.cloner = new pu(this)), this.cloner.fromClonerState(t));
    }
    fromState(t, r) {
        var n, s, o;
        return super.fromState(t), t.type === "Mesh" && (this.setFromClonerState(t.cloner), this.castShadow = (n = t.castShadow) != null ? n : !0, this.receiveShadow = (s = t.receiveShadow) != null ? s : !0, this.booleanExclude = (o = t.booleanExclude) != null ? o : null), this;
    }
    freeBooleanPointer() {
        this.booleanMeshSetAddress !== -1 && (Jn.freeMeshSet(this.booleanMeshSetAddress), this.booleanMeshSetAddress = -1);
    }
    invalidateDownstreamBooleanData(t = !1) {
        return t ? this.booleanWasTransformed = !0 : this.freeBooleanPointer(), Lt(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this;
    }
    invalidateUpstreamBooleanData() {
        this.freeBooleanPointer();
        for (let t of this.children)er(t) && (t.freeBooleanPointer(), Lt(t) && t.invalidateUpstreamBooleanData());
    }
};
var GF = new M(0, 0, 1), k1 = new M, V1 = new M, H1 = new Ft, ho = class extends kt {
    constructor(t = Hr.create({}), r = new Yr({
        side: or
    })){
        var n;
        super(t, r);
        this.recursiveSelection = !1;
        this.objectType = "VectorObject";
        this.eventDispatcher = new Yt;
        this._onShapeUpdate = ()=>{
            this.updateGeometry({}), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
        };
        this.castShadow = !0, this.receiveShadow = !0, this.forceComputeSize = !0, this.shape = t.userData.shape, (n = this.shape.eventDispatcher) == null || n.addEventListener("update", this._onShapeUpdate);
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "VectorObject", r;
    }
    fromState(t) {
        return super.fromState(t), this.shape.update(), this;
    }
    setHelperVisibility() {}
    updateGeometry(t) {
        if (super.updateGeometry(t), "userData" in this.geometry) {
            let r = this.geometry.userData.parameters;
            this.eventDispatcher.dispatchEvent({
                type: "geometryUpdate",
                parameters: r
            });
        }
    }
    setShape(t) {
        var r, n;
        this.shape && ((r = this.shape.eventDispatcher) == null || r.removeEventListener("update", this._onShapeUpdate)), this.shape = t, (n = this.shape.eventDispatcher) == null || n.addEventListener("update", this._onShapeUpdate);
    }
    updateWorldMatrix(t, r) {
        super.updateWorldMatrix(t, r), H1.getNormalMatrix(this.matrixWorld), k1.copy(GF).applyMatrix3(H1).normalize(), V1.setFromMatrixPosition(this.matrixWorld), this.shape.plane.setFromNormalAndCoplanarPoint(k1, V1);
    }
    clone(t) {
        let r = this.shape.clone(), n = this.material.clone(), s = this.geometry.userData, o = Hr.create(Object.assign({}, s, {
            shape: r
        })), a = new ho(o, n).copy(this, t);
        return a.shape = r, r.update(), a;
    }
    raycast(t, r) {
        kt.prototype.raycast.call(this, t, r);
    }
};
function Fp(i, e) {
    return kF(i);
}
function kF(i) {
    let e = {
        parameters: i,
        type: i.type
    };
    if (i.type === "VectorGeometry") {
        let r = Tt.createFromState(i.shape, i.width, i.height);
        e.shape = r;
    } else i.type === "NonParametricGeometry" && (i.data.groups && i.data.groups.forEach((r)=>{
        var n;
        return r.materialIndex = Math.max((n = r.materialIndex) != null ? n : 0, 0);
    }), e.geometry = new Ws().parse(i));
    let t;
    try {
        t = mu(e);
    } catch (r) {
        console.error(r);
    }
    if (!t) {
        let r = Tt.createFromState(_l.defaultData(), 100, 100);
        e.shape = r, t = mu(e);
    }
    return t;
}
var Ke;
bp.then((i)=>{
    Ke = i;
});
var W1 = new Float32Array([
    10,
    10,
    0,
    -10,
    10,
    0,
    -10,
    -10,
    0,
    10,
    -10,
    0
]), j1 = new Uint32Array([
    0,
    1,
    2,
    3
]), q1 = new Uint8Array([
    4
]), gi = class {
    static build(i, e, t, r) {
        let n, s, o;
        if ((i == null ? void 0 : i.positionWASM) !== void 0) {
            e && e !== 0 && (Ke.free_bvh(e), Ke.free_subdivision_surface(e));
            try {
                n = gi.allocate(i, r);
            } catch (a) {
                console.error(a, i), n = gi.allocate({
                    positionWASM: W1,
                    indexWASM: j1,
                    verticesPerFaceWASM: q1
                }, r);
            }
            Ke.set_destination_refinement_level(n, 0), s = gi.buildLevel(n, !0, t);
        } else n = e;
        if (i !== void 0 && i.subdivisions !== void 0) {
            let a = VF(i.subdivisions, i.positionWASM.length);
            Ke.set_destination_refinement_level(n, a), a > 0 ? o = gi.buildLevel(n, !1, t) : o = null;
        }
        return {
            subdivPointer: n,
            originalGeometry: s,
            subdividedGeometry: o
        };
    }
    static primitiveToQuads(i, e) {
        i.widthSegments > 16 && (i.widthSegments = 16), i.heightSegments > 16 && (i.heightSegments = 16), i.depthSegments > 16 && (i.depthSegments = 16), i.radialSegments > 16 && (i.radialSegments = 16), i.type === "DodecahedronGeometry" && (i.detail = 0);
        let t = i.shape !== void 0 ? e.geometry : Fp(i), r, n, s, o;
        return { positions: r , triIndices: o  } = Lv(t.getAttribute("position"), t.getIndex()), { indices: n , verticesPerFace: s  } = Iv(r, o, t), {
            positions: r,
            indices: n,
            verticesPerFace: s
        };
    }
    static allocate(i, e) {
        var b;
        let t, r, n, s = [], o = [];
        i.positionWASM && i.positionWASM.length > 0 ? (t = i.positionWASM, r = i.indexWASM, n = i.verticesPerFaceWASM) : (t = W1, r = j1, n = q1);
        let a = t.length, l = r.length, c = n.length, h = t.length + s.length + o.length, u = r.length + n.length, f = h * Float32Array.BYTES_PER_ELEMENT + u * Uint32Array.BYTES_PER_ELEMENT, d = h * Float32Array.BYTES_PER_ELEMENT, p = u * Uint32Array.BYTES_PER_ELEMENT, m = Ke._malloc(f), g = new Float32Array(Ke.HEAPF32.buffer, m, h), v = new Uint32Array(Ke.HEAPU32.buffer, m + d, u);
        g.set(t, 0), g.set(s, t.length), g.set(o, t.length + s.length), v.set(r, 0), v.set(n, r.length);
        let y;
        (b = i == null ? void 0 : i.scaleBaked) != null && b.some((S)=>S !== 1
        ) && (y = new Ae().makeScale(...i.scaleBaked)), e && (y ? y.premultiply(e) : y = e);
        let w = y ? Ke.alloc_subdivision_surface2(m, a, m + d, l, m + d + r.length * Uint32Array.BYTES_PER_ELEMENT, c, y.elements) : Ke.alloc_subdivision_surface(m, a, m + d, l, m + d + r.length * Uint32Array.BYTES_PER_ELEMENT, c);
        return Ke._free(m), w;
    }
    static buildLevel(i, e, t, r, n) {
        let s = n ? Ke.get_mesh_data2(i, e ? Ke.Level.CONTROL : Ke.Level.REFINED, t != null ? t : !e, n.elements) : Ke.get_mesh_data(i, e ? Ke.Level.CONTROL : Ke.Level.REFINED, t != null ? t : !e), o = 8, a = Ke.HEAPU32.subarray(s >> 2, (s >> 2) + o), l = a.subarray(4, 8), c = 0, h = Ke.HEAPU32[a[c] >> 2], u = Ke.HEAPF32.subarray(h >> 2, (h >> 2) + l[c]);
        c++;
        let f = Ke.HEAPU32[a[c] >> 2], d = Ke.HEAPF32.subarray(f >> 2, (f >> 2) + l[c]);
        c++;
        let p = Ke.HEAPU32[a[c] >> 2], m = Ke.HEAPU32.subarray(p >> 2, (p >> 2) + l[c]);
        c++;
        let g = Ke.HEAPU32[a[c] >> 2], v = Ke.HEAPU32.subarray(g >> 2, (g >> 2) + l[c]);
        if (c++, r === void 0) {
            let y = new Le;
            if (y.setIndex(new Os(v, 1)), y.setAttribute("position", new Ce(u, 3)), y.setAttribute("normal", new Ce(d, 3)), e) {
                y.setAttribute("faceMap", new Os(m, 1));
                let w = new Float32Array(d.length / 3 * 4).fill(0);
                y.setAttribute("color", new Ve(w, 4));
            }
            return Ke.free_mesh_data(s), y.userData.type = "SubdivGeometry", y;
        }
        r.getAttribute("position").copyArray(u), r.getAttribute("normal").copyArray(d), r.attributes.position.needsUpdate = !0, r.attributes.normal.needsUpdate = !0, Ke.free_mesh_data(s);
    }
    static buildControlCageWireframe(i, e, t) {
        let r = Ke.get_wireframe_data_for_base_level(i), n = 4, s = Ke.HEAPU32.subarray(r >> 2, (r >> 2) + n), o = s.subarray(2, 4), a = 0, l = Ke.HEAPU32[s[a] >> 2], c = Ke.HEAPF32.subarray(l >> 2, (l >> 2) + o[a]);
        a++;
        let h = Ke.HEAPU32[s[a] >> 2], u = Ke.HEAPU32.subarray(h >> 2, (h >> 2) + o[a]);
        if (e === void 0) {
            let f = new Le;
            f.setAttribute("position", new Ce(c, 3));
            let d = new Float32Array(c.length);
            for(let p = 0, m = c.length; p < m;)d[p++] = t.r, d[p++] = t.g, d[p++] = t.b;
            return f.setAttribute("color", new Ve(d, 3)), f.setIndex(new Os(u, 1)), Ke.free_wireframe_data_for_base_level(r), f;
        }
        e.getAttribute("position").copyArray(c), e.attributes.position.needsUpdate = !0, Ke.free_wireframe_data_for_base_level(r);
    }
    static updateCollabMesh(i, e, t) {
        e || Ke.set_destination_refinement_level(i, 1);
        let r = t ? Ke.get_topological_data2(i, e ? Ke.Level.CONTROL : Ke.Level.REFINED, t.elements) : Ke.get_topological_data(i, e ? Ke.Level.CONTROL : Ke.Level.REFINED), n = 6, s = Ke.HEAPU32.subarray(r >> 2, (r >> 2) + n), o = s.subarray(3, 6), a = 0, l = Ke.HEAPU32[s[a] >> 2], c = new Float32Array(Ke.HEAPF32.subarray(l >> 2, (l >> 2) + o[a]));
        a++;
        let h = Ke.HEAPU32[s[a] >> 2], u = new Uint32Array(Ke.HEAPU32.subarray(h >> 2, (h >> 2) + o[a]));
        a++;
        let f = Ke.HEAPU32[s[a] >> 2], d = new Uint8Array(Ke.HEAPU32.subarray(f >> 2, (f >> 2) + o[a]));
        return Ke.free_topological_data(r), {
            positions: c,
            indices: u,
            verticesPerFace: d
        };
    }
};
function VF(i, e) {
    let t = i;
    return t = Math.min(t, 3 - Math.ceil(Math.log(e / 172e3) / Math.log(4))), Math.max(t, 0);
}
var Y1 = [
    "getX",
    "getY",
    "getZ"
];
function Lv(i, e) {
    let t = {}, r = e ? e.count : i.count, n = 0, s = [], o = [], a = 1e4;
    for(let c = 0; c < r; c++){
        let h = e ? e.getX(c) : c, u = "";
        for(let f = 0; f < 3; f++)u += `${~~(i[Y1[f]](h) * a)},`;
        if (u in t) s.push(t[u]);
        else {
            for(let f = 0; f < 3; f++)o.push(i[Y1[f]](h));
            t[u] = n, s.push(n), n++;
        }
    }
    let l = [];
    for(let c11 = 0; c11 < s.length; c11 += 3)s[c11] === s[c11 + 1] || s[c11] === s[c11 + 2] || s[c11 + 1] === s[c11 + 2] || l.push(s[c11], s[c11 + 1], s[c11 + 2]);
    return {
        positions: o,
        triIndices: l
    };
}
var Up = new M, Cv = new M, Dv = new M, Pv = new M;
function Iv(i, e, t) {
    var s;
    let r = [], n = [];
    if (t.userData.shape !== void 0 && t.userData.parameters.depth === 0) {
        let o = t.userData.shape.extractShapePointsToFlatArray([]), a = 0;
        for(let c = 0; c < o.length; c += 2)a += (o[c] - o[(c === 0 ? o.length : c) - 2]) * (o[c + 1] + o[(c === 0 ? o.length : c) - 1]);
        i.length = 0;
        let l = 0;
        if (a < 0) for(let c12 = 0; c12 < o.length; c12 += 2)i.push(o[c12], o[c12 + 1], 0), r.push(l++);
        else for(let c13 = o.length - 2; c13 >= 0; c13 -= 2)i.push(o[c13], o[c13 + 1], 0), r.push(l++);
        return n.push(l), {
            indices: r,
            verticesPerFace: n
        };
    }
    for(let o = 0, a = (s = t.capStartIndex) != null ? s : e.length; o < a;)if (e[o + 1] === e[o + 3] && e[o + 2] === e[o + 5] || e[o + 0] === e[o + 3] && e[o + 2] === e[o + 4]) {
        Up.set(i[e[o] * 3], i[e[o] * 3 + 1], i[e[o] * 3 + 2]), Cv.set(i[e[o + 1] * 3], i[e[o + 1] * 3 + 1], i[e[o + 1] * 3 + 2]), Dv.set(i[e[o + 4] * 3], i[e[o + 4] * 3 + 1], i[e[o + 4] * 3 + 2]), Pv.set(i[e[o + 5] * 3], i[e[o + 5] * 3 + 1], i[e[o + 5] * 3 + 2]), Cv.sub(Up).normalize(), Dv.sub(Up).normalize(), Pv.sub(Up).normalize();
        let l = Cv.cross(Dv).dot(Pv);
        Math.abs(l) > .005 ? (r.push(e[o], e[o + 1], e[o + 2]), n.push(3), o += 3) : (r.push(e[o], e[o + 1], e[o + 4], e[o + 5]), n.push(4), o += 6);
    } else r.push(e[o], e[o + 1], e[o + 2]), n.push(3), o += 3;
    if (t.capStartIndex !== void 0) {
        let o = [], a = [], l = 0;
        for(let c = 0, h = 0; c < i.length; c += 3, h++)i[c + 2] === 0 && (o.push(h), l++), i[c + 2] === t.userData.parameters.depth && a.push(h);
        if (t.userData.parameters.extrudeBevelSize === 0) {
            let c = a[0];
            a[0] = a[1], a[1] = c;
        }
        o.reverse(), r.push(...o, ...a), n.push(l, l);
    }
    return {
        indices: r,
        verticesPerFace: n
    };
}
var Jn = {};
Tx(Jn, {
    calcBoolean: ()=>jF
    ,
    calcBooleanTopological: ()=>WF
    ,
    freeMeshSet: ()=>XF
    ,
    getMeshSet: ()=>qF
    ,
    transformMeshSet: ()=>YF
});
var Q1, J1 = new Promise((i)=>{
    Q1 = i;
}), X1 = !1;
async function K1() {
    if (X1) return;
    let e = "https://unpkg.com/@splinetool/boolean-wasm@0.9.52/build", [t, r] = await Promise.all([
        require("c4f428a88e5bff21"),
        fetch(`${e}/boolean.wasm`).then((o)=>o.arrayBuffer()
        )
    ]), s = await t.default({
        wasmBinary: r
    });
    Q1(s), X1 = !0;
}
var gt, Jl;
J1.then((i)=>gt = i
);
function HF(i, e) {
    let t, { positions: r , triIndices: n  } = Lv(i.getAttribute("position"), i.getIndex()), s;
    if (e) {
        let { indices: o , verticesPerFace: a  } = Iv(r, n, i);
        s = a.length, t = [];
        for(let l = 0, c = 0; l < s; l++){
            t.push(a[l]);
            for(let h = 0; h < a[l]; h++)t.push(o[c++]);
        }
    } else {
        let o = n.length;
        t = Array(o + o / 3), s = 0;
        for(let a = 0, l = 0; l < t.length;)t[l++] = 3, s++, t[l++] = n[a++], t[l++] = n[a++], t[l++] = n[a++];
    }
    return {
        positions: r,
        faceIndices: t,
        nFaces: s
    };
}
function Z1(i) {
    let e = i.length, t = e * Uint32Array.BYTES_PER_ELEMENT, r = e * Float32Array.BYTES_PER_ELEMENT, n = Number.isInteger(i[0]) ? t : r, s = gt._malloc(n);
    return (Number.isInteger(i[0]) ? new Uint32Array(gt.HEAPU32.buffer, s, e) : new Float32Array(gt.HEAPF32.buffer, s, e)).set(i, 0), s;
}
function $1(i) {
    switch(i){
        case 0:
            return gt.OP.UNION;
        case 1:
            return gt.OP.INTERSECTION;
        case 2:
            return gt.OP.A_MINUS_B;
        case 3:
            return gt.OP.B_MINUS_A;
        case 4:
            return gt.OP.SYMMETRIC_DIFFERENCE;
        case 5:
            return gt.OP.ALL;
        default:
            throw new Error("Unknown boolean operation " + i);
    }
}
function WF(i, e) {
    Jl === void 0 && (Jl = gt.init_csg());
    let t = Z1(i), r = gt.csg_calc_topological(Jl, t, i.length, $1(e));
    gt._free(t);
    let n = 6, s = gt.HEAPU32.subarray(r >> 2, (r >> 2) + n), o = s.subarray(3, 6), a = 0, l = gt.HEAPU32[s[a] >> 2], c = new Float32Array(gt.HEAPF32.subarray(l >> 2, (l >> 2) + o[a]));
    a++;
    let h = gt.HEAPU32[s[a] >> 2], u = new Uint32Array(gt.HEAPU32.subarray(h >> 2, (h >> 2) + o[a]));
    a++;
    let f = gt.HEAPU32[s[a] >> 2], d = new Uint8Array(gt.HEAPU32.subarray(f >> 2, (f >> 2) + o[a]));
    return gt.free_mesh_data(r), {
        positions: c,
        indices: u,
        verticesPerFace: d
    };
}
function jF(i, e, t) {
    Jl === void 0 && (Jl = gt.init_csg());
    let r = Z1(i), n = gt.csg_calc(Jl, r, i.length, $1(e));
    gt._free(r);
    let s = 5, o = gt.HEAPU32.subarray(n >> 2, (n >> 2) + s), a = o.subarray(2, 5), l = 0, c = gt.HEAPU32[o[l] >> 2], h = gt.HEAPF32.subarray(c >> 2, (c >> 2) + a[l]);
    l++;
    let u = gt.HEAPU32[o[l] >> 2], f = gt.HEAPF32.subarray(u >> 2, (u >> 2) + a[l]);
    l++;
    let d = a[l];
    t.setAttribute("position", new Ce(h, 3)), t.setAttribute("normal", new Ce(f, 3));
    let p = gt.HEAPF32.subarray((n >> 2) + 5, (n >> 2) + 5 + 6);
    return t.boundingSphere === null && (t.boundingSphere = new Lr), t.boundingSphere.center.set(p[0], p[1], p[2]), t.boundingSphere.radius = (p[3] ** 2 + p[4] ** 2 + p[5] ** 2) ** .5, t.userData.parameters = {
        width: p[3] * 2,
        height: p[4] * 2,
        depth: p[5] * 2
    }, gt.free_mesh_data(n), d;
}
function qF(i, e) {
    if (gt === void 0) return -1;
    let t, r, n;
    if (e && i.userData.positions !== void 0) {
        let m = i.userData;
        n = m.verticesPerFace.length, t = m.positions, r = Array(m.verticesPerFace.reduce((g, v)=>g + v
        , 0) + n);
        for(let g7 = 0, v12 = 0, y = 0; g7 < m.verticesPerFace.length; g7++){
            r[y++] = m.verticesPerFace[g7];
            for(let w = 0; w < m.verticesPerFace[g7]; w++)r[y++] = m.indices[v12++];
        }
    } else ({ positions: t , faceIndices: r , nFaces: n  } = HF(i, e));
    let s = t.length, o = r.length, a = t.length, l = r.length, c = a * Float32Array.BYTES_PER_ELEMENT + l * Uint32Array.BYTES_PER_ELEMENT, h = a * Float32Array.BYTES_PER_ELEMENT, u = l * Uint32Array.BYTES_PER_ELEMENT, f = gt._malloc(c), d = new Float32Array(gt.HEAPF32.buffer, f, a), p = new Uint32Array(gt.HEAPU32.buffer, f + h, l);
    return d.set(t, 0), p.set(r, 0), gt.get_csg_mesh(f, s, f + h, o, n);
}
function YF(i, e) {
    gt.transform_csg_mesh(i, e.elements);
}
function XF(i) {
    gt.free_csg_mesh(i);
}
var _v = {
    ConeGeometry: VM,
    CubeGeometry: HM,
    CylinderGeometry: kM,
    DodecahedronGeometry: WM,
    EllipseGeometry: c1,
    HelixGeometry: d1,
    IcosahedronGeometry: p1,
    LatheGeometry: m1,
    NonParametricGeometry: g1,
    PolygonGeometry: y1,
    PyramidGeometry: v1,
    RectangleGeometry: vp,
    SphereGeometry: x1,
    PlaneGeometry: b1,
    StarGeometry: w1,
    TextFrameGeometry: xp,
    TorusGeometry: S1,
    TorusKnotGeometry: M1,
    TriangleGeometry: A1,
    VectorGeometry: Hr
}, mu = (i)=>_v[i.type].create(i)
;
var eA = new Ae;
function Rv(i) {
    let e = !1;
    return i.scene.objects.traverse((t, r)=>{
        var n;
        ((n = r.geometry) == null ? void 0 : n.type) === "BooleanGeometry" && (e = !0);
    }), e;
}
var zp = class extends kt {
    constructor(t = new Le, r = new pn){
        super(t, r);
        this.booleanOp = 2;
        this.meshSetAddresses = [];
        this.needsTransformForDownstream = !1;
        this.isBooleanMesh = !0, this.castShadow = !0, this.receiveShadow = !0, this.geometry.userData.parameters = {
            width: 0,
            height: 0,
            depth: 0
        }, this.onAfterRender = this.recomputeBoolean.bind(this);
    }
    reInit() {
        this.isBooleanMesh = !0, this.meshSetAddresses = [], this.needsTransformForDownstream = !1, this.geometry.userData.parameters = {
            width: 0,
            height: 0,
            depth: 0
        }, this.onAfterRender = this.recomputeBoolean.bind(this);
    }
    recomputeBoolean(t) {
        if (this.booleanMeshSetAddress !== -1) return;
        for(let n = 0; n < this.children.length; n++){
            let s = this.children[n];
            Lt(s) && s.recomputeBoolean(t === !0);
        }
        this.meshSetAddresses = [];
        for(let n18 = 0; n18 < this.children.length; n18++){
            let s = this.children[n18];
            if (G1(s) && s.booleanExclude === !1 && s.geometry.drawRange.count > 0) {
                if (s.booleanMeshSetAddress === -1) {
                    if (s.booleanMeshSetAddress = Jn.getMeshSet(s.geometry, t === !0), s.booleanMeshSetAddress === -1) return;
                    Jn.transformMeshSet(s.booleanMeshSetAddress, s.matrix), s.booleanMatrixInvOld.copy(s.matrix).invert(), s.booleanWasTransformed = !1;
                } else Lt(s) && s.needsTransformForDownstream === !0 ? (Jn.transformMeshSet(s.booleanMeshSetAddress, s.matrix), s.needsTransformForDownstream = !1) : s.booleanWasTransformed === !0 && (eA.multiplyMatrices(s.matrix, s.booleanMatrixInvOld), Jn.transformMeshSet(s.booleanMeshSetAddress, eA), s.booleanMatrixInvOld.copy(s.matrix).invert(), s.booleanWasTransformed = !1);
                this.meshSetAddresses.push(s.booleanMeshSetAddress);
            }
        }
        if (this.meshSetAddresses.length === 0) {
            this.geometry.setDrawRange(0, 0);
            return;
        }
        if (t === !0) return Jn.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
        let r = this.geometry;
        r.dispose(), this.geometry = new Le, this.geometry.userData = r.userData, this.geometry.boundingSphere = r.boundingSphere, this.booleanMeshSetAddress = Jn.calcBoolean(this.meshSetAddresses, this.booleanOp, this.geometry), this.booleanMatrixInvOld.copy(this.matrix).invert(), this.needsTransformForDownstream = !0;
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "Mesh3D", r;
    }
    updateGeometry(t) {
        this.booleanOp = t.parameters.operation, this.invalidateDownstreamBooleanData().recomputeBoolean();
    }
};
var Gi = (i)=>{
    var e;
    return e = class extends i {
        constructor(){
            super(...arguments);
            this.isObjectHelper = !0;
        }
    }, e.geometryHelper = new vn(30, 30, 30), e;
};
var Gp = new si, Bv = new Lr, tA = new Ae, ki = (i, e, t, r, n = !1)=>{
    let s = e, o = i.matrixWorld;
    if (s.boundingSphere === null && s.computeBoundingSphere(), Bv.copy(s.boundingSphere), Bv.applyMatrix4(o), t.ray.intersectsSphere(Bv) === !1 || (tA.copy(o).invert(), Gp.copy(t.ray).applyMatrix4(tA), s.boundingBox !== null && Gp.intersectsBox(s.boundingBox) === !1)) return;
    let a, l, c, h, u = s.index, f = s.attributes.position, d = s.drawRange, p, m;
    if (n === !1) {
        let v = Math.max(0, d.start), y = Math.min(u.count, d.start + d.count);
        for(p = v, m = y; p < m; p += 3)if (l = u.getX(p), c = u.getX(p + 1), h = u.getX(p + 2), a = g(i, t, Gp, f, l, c, h), a) {
            a.faceIndex = Math.floor(p / 3), r.push(a);
            return;
        }
    } else {
        let y = s.attributes.position, w = new M, b = new M, S = new M, T = new M, A = 2, E = 1 / ((i.scale.x + i.scale.y + i.scale.z) / 3), _ = E * E, C = Math.max(0, d.start), I = Math.min(y.count, d.start + d.count);
        for(let N = C, R = I - 1; N < R; N += A){
            if (w.fromBufferAttribute(y, N), b.fromBufferAttribute(y, N + 1), Gp.distanceSqToSegment(w, b, T, S) > _) continue;
            T.applyMatrix4(i.matrixWorld);
            let G = t.ray.origin.distanceTo(T);
            G < t.near || G > t.far || r.push({
                distance: G,
                point: S.clone().applyMatrix4(i.matrixWorld),
                object: i
            });
        }
    }
    function g(v, y, w, b, S, T, A) {
        let x = new M, E = new M, _ = new M, C = new M, I = new M;
        if (x.fromBufferAttribute(b, S), E.fromBufferAttribute(b, T), _.fromBufferAttribute(b, A), w.intersectTriangle(x, E, _, !1, C) === null) return null;
        I.copy(C), I.applyMatrix4(v.matrixWorld);
        let R = y.ray.origin.distanceTo(I);
        return R < y.near || R > y.far ? null : {
            faceIndex: 1,
            distance: R,
            point: I.clone(),
            object: v
        };
    }
};
var kp = new M, Kn = new Gn, Nv = class extends ai {
    constructor(t){
        let r = new Le, n = new kr({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        }), s = [], o = [], a = {}, l = new be(15711266), c = new be(15711266), h = new be(2857471);
        u("n1", "n2", l), u("n2", "n4", l), u("n4", "n3", l), u("n3", "n1", l), u("f1", "f2", l), u("f2", "f4", l), u("f4", "f3", l), u("f3", "f1", l), u("n1", "f1", l), u("n2", "f2", l), u("n3", "f3", l), u("n4", "f4", l), u("p", "n1", c), u("p", "n2", c), u("p", "n3", c), u("p", "n4", c), u("u1", "u2", h), u("u2", "u3", h), u("u3", "u1", h);
        function u(d, p, m) {
            f(d, m), f(p, m);
        }
        function f(d, p) {
            s.push(0, 0, 0), o.push(p.r, p.g, p.b), a[d] === void 0 && (a[d] = []), a[d].push(s.length / 3 - 1);
        }
        r.setAttribute("position", new Ce(s, 3)), r.setAttribute("color", new Ce(o, 3));
        super(r, n);
        this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
    }
    update() {
        let t = this.geometry, r = this.pointMap, n = !0;
        Kn.projectionMatrixInverse.elements = [
            .5112609807824982,
            -0,
            -0,
            -0,
            -0,
            .41421356237309503,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0.099999,
            -0,
            -0,
            -1.0000000000000002,
            .100001
        ];
        let s = 1, o = 1, a = n ? .8 : 1e-4;
        yi("n1", r, t, Kn, -s, -o, a), yi("n2", r, t, Kn, s, -o, a), yi("n3", r, t, Kn, -s, o, a), yi("n4", r, t, Kn, s, o, a);
        let l = a;
        yi("f1", r, t, Kn, -s, -o, l), yi("f2", r, t, Kn, s, -o, l), yi("f3", r, t, Kn, -s, o, l), yi("f4", r, t, Kn, s, o, l);
        let c = l, h = .5;
        yi("u1", r, t, Kn, s * .7 * h, o * 1.1, c), yi("u2", r, t, Kn, -s * .7 * h, o * 1.1, c), yi("u3", r, t, Kn, 0, o * (1.1 + .9 * h), c), t.getAttribute("position").needsUpdate = !0;
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose();
    }
};
function yi(i, e, t, r, n, s, o) {
    kp.set(n, s, o).unproject(r);
    let a = e[i];
    if (a !== void 0) {
        let l = t.getAttribute("position");
        for(let c = 0, h = a.length; c < h; c++)l.setXYZ(a[c], kp.x, kp.y, kp.z);
    }
}
var Vp = class extends Gi(Nv) {
    constructor(t){
        super(t);
        this.object = t;
        this.object = t, this.name = `CombinedCameraHelper: ${t.uuid}`;
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.updateTarget();
    }
    updateTarget() {
        let t = this.object.getTarget();
        this.updateWorldMatrix(!0, !1), this.worldToLocal(t);
    }
    raycast(t, r) {
        ki(this.object, this.geometry, t, r, !0);
    }
};
var Kl = class extends Gi(Qf) {
    constructor(t, r = 15, n = 10066329){
        super(t, r, n);
        this.object = t;
        this.name = `DirectionalLightHelper: ${t.uuid}`;
    }
    raycast(t, r) {
        ki(this.object, Kl.geometryHelper, t, r);
    }
};
var Zl = class extends Gi(Jf) {
    constructor(t, r = 15){
        super(r);
        this.object = t;
        this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${t.uuid}`, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
    }
    raycast(t, r) {
        ki(this.object, Zl.geometryHelper, t, r);
    }
    update() {}
};
var $l = class extends Gi(Xf) {
    constructor(t, r = 15, n = 6710886){
        super(t, r, n);
        this.object = t;
        this.name = `PointLightHelper: ${t.uuid}`;
    }
    raycast(t, r) {
        ki(this.object, $l.geometryHelper, t, r);
    }
};
var Hp = class extends Gi(Yf) {
    constructor(t, r = 6710886){
        super(t, r);
        this.object = t;
        this.name = `SpotLightHelper: ${t.uuid}`;
    }
    raycast(t, r) {
        ki(this.object, Hp.geometryHelper, t, r);
    }
    update() {
        if (this.object !== void 0) {
            let t = Hp._vector, r = this.object.distance ? this.object.distance : 1e3, n = r * Math.tan(this.object.angle);
            this.cone.scale.set(n, n, r), t.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(t);
            let s = this.color !== void 0 ? this.color : this.light.color;
            if (this.cone.material instanceof Array) for(let o = 0, a = this.cone.material.length; o < a; o++)this.cone.material[o].color.set(s);
            else this.cone.material.color.set(s);
        }
    }
}, gu = Hp;
gu._vector = new M;
var Vi = (i, e)=>class extends i {
        constructor(){
            super(...arguments);
            this.objectHelper = new e(this);
            this.enableHelper = !1;
        }
        set visibility(n) {
            this.visible = n, this.setHelperVisibility(n), this.setHelperChildrenVisibility(n);
        }
        get visibility() {
            return this.visible;
        }
        get geometryHelper() {
            return e.geometryHelper;
        }
        setHelperVisibility(n) {
            this.objectHelper.visible = n;
        }
        setHelperChildrenVisibility(n) {
            for (let s of this.children)Xn(s) && s.traverseEntity((o)=>{
                ms(o) && o.visible && (o.objectHelper.visible = n);
            });
        }
        raycast(n, s) {
            this.objectHelper.raycast(n, s);
        }
        copy(n, s = !0) {
            return super.copy(n, s), n.enableHelper !== void 0 && (this.enableHelper = n.enableHelper), n.objectHelper !== void 0 && (this.objectHelper.visible = n.objectHelper.visible), this;
        }
        toJSON(n) {
            let s = super.toJSON(n), o = s.object;
            return o.enableHelper = this.enableHelper, s;
        }
        fromJSON(n) {
            return super.fromJSON(n), n.enableHelper !== void 0 && (this.enableHelper = !0), this;
        }
        fromLightState(n, s) {
            if (this.objectType === "LightDirectional" || this.objectType === "LightPoint" || this.objectType === "LightSpot") {
                let o = this;
                n.color !== void 0 && (o.color = pr(n.color, s)), n.intensity !== void 0 && (o.intensity = n.intensity), n.depth !== void 0 && (o.shadow.camera.far = n.depth, o.shadow.needsUpdate = !0), n.shadows !== void 0 && (this.castShadow = n.shadows), n.helper !== void 0 && (this.enableHelper = n.helper, o.gizmos.shadowmap.visible = n.helper);
            }
            return this;
        }
    }
;
var ec = new M, Ov = new M, Bn = class extends Vi(Qn(Gn), Vp) {
    constructor(t = window.innerWidth, r = window.innerHeight, n = 45, s, o = 1e5){
        super();
        this.objectType = "CombinedCamera";
        this._cameraType = "OrthographicCamera";
        this.targetOffset = Wo.DefaultTargetOffset;
        this.isUpVectorFlipped = !1;
        this.angleOffsetFromUp = 0;
        this.width = t, this.height = r, this.orthoCamera = new Co(t * -0.5, t * .5, r * .5, r * -0.5, s != null ? s : -50000, o), this.perspCamera = new sr(n, t / r, s != null ? s : 50, o), this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.fov = this.perspCamera.fov, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.toOrthographic(!0);
    }
    static createFromState(t, r) {
        let n = new Bn().fromState(r);
        return n.enableHelper = !0, n.objectHelper.update(), n.uuid = t, n;
    }
    get isPerspectiveCamera() {
        return this.cameraType === "PerspectiveCamera";
    }
    get isOrthographicCamera() {
        return !this.isPerspectiveCamera;
    }
    get cameraType() {
        return this._cameraType;
    }
    setNear(t, r) {
        t === "PerspectiveCamera" ? this.perspCamera.near = r : this.orthoCamera.near = r;
    }
    setZoom(t, r) {
        r >= 0 && (t === "PerspectiveCamera" ? this.perspCamera.zoom = r : this.orthoCamera.zoom = r);
    }
    set cameraType(t) {
        t === "PerspectiveCamera" ? this.toPerspective() : t === "OrthographicCamera" && this.toOrthographic();
    }
    get near() {
        return this._cameraType === "PerspectiveCamera" ? this.perspCamera.near : this.orthoCamera.near;
    }
    set near(t) {
        this._cameraType === "PerspectiveCamera" ? this.perspCamera.near = t : this.orthoCamera.near = t;
    }
    get zoom() {
        return this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom : this.orthoCamera.zoom;
    }
    set zoom(t) {
        t >= 0 && (this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom = t : this.orthoCamera.zoom = t);
    }
    lookAt(t) {
        super.lookAt(t), this.getWorldPosition(ec), this.targetOffset = ec.distanceTo(t);
    }
    getTarget(t = new M) {
        return this.getWorldDirection(Ov), this.getWorldPosition(ec), Ov.multiplyScalar(this.targetOffset), t.copy(ec).add(Ov), t;
    }
    getDistanceToTarget() {
        let t = this.getTarget();
        return this.getWorldPosition(ec), ec.distanceTo(t);
    }
    updateUp() {
        let t = this.getWorldQuaternion(new zt), r = new M(0, 0, 1).applyQuaternion(t), n = new M().copy(ot.DefaultUp);
        this.isUpVectorFlipped && n.negate(), n.applyQuaternion(t);
        let s = new M().copy(ot.DefaultUp).projectOnPlane(r), o = new M().crossVectors(s, n).dot(r) >= 0 ? 1 : -1;
        this.angleOffsetFromUp = s.angleTo(n) * o;
    }
    getViewFrontToObject(t) {
        let r = t.getWorldPosition(new M), s = t.getWorldDirection(new M).multiplyScalar(this.targetOffset);
        return {
            position: r.clone().add(s),
            target: r
        };
    }
    getViewToObject(t) {
        let r = t.getWorldPosition(new M), s = this.getWorldDirection(new M).multiplyScalar(this.targetOffset);
        return {
            position: r.clone().sub(s),
            target: r
        };
    }
    setViewplaneSize(t, r) {
        this.left = -t * .5, this.right = t * .5, this.top = r * .5, this.bottom = -r * .5, this.aspect = t / r, this.updateProjectionMatrix();
    }
    toOrthographic(t) {
        this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", (this.enableHelper === !0 || t === !0) && this.objectHelper.update();
    }
    toPerspective(t) {
        this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", (this.enableHelper === !0 || t === !0) && this.objectHelper.update();
    }
    setFocalLength(t) {
        this.perspCamera.setFocalLength(t), this.toPerspective();
    }
    getFocalLength() {
        return this.perspCamera.getFocalLength();
    }
    getEffectiveFOV() {
        return this.perspCamera.getEffectiveFOV();
    }
    getFilmWidth() {
        return this.perspCamera.getFilmWidth();
    }
    getFilmHeight() {
        return this.perspCamera.getFilmHeight();
    }
    setViewOffset(t, r, n, s, o, a) {
        this._cameraType === "PerspectiveCamera" ? this.perspCamera.setViewOffset(t, r, n, s, o, a) : this.orthoCamera.setViewOffset(t, r, n, s, o, a);
    }
    clearViewOffset() {
        this._cameraType === "PerspectiveCamera" ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
    }
    updateProjectionMatrix(t) {
        this._cameraType === "PerspectiveCamera" ? this.toPerspective(t) : this._cameraType === "OrthographicCamera" && this.toOrthographic(t);
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, r) {
        super.updateWorldMatrix(t, r), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    copy(t, r) {
        return super.copy(t, r), this.orthoCamera.copy(t.orthoCamera), this.perspCamera.copy(t.perspCamera), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.far = t.far, this.view = t.view === null ? null : Object.assign({}, t.view), this._cameraType = t._cameraType, this.aspect = t.aspect, this.fov = t.fov, this.focus = t.focus, this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this.targetOffset = t.targetOffset, this.updateProjectionMatrix(), this;
    }
    fromCameraRender(t) {
        let r = {
            near: this.orthoCamera.near,
            far: this.orthoCamera.far
        }, n = {
            near: this.perspCamera.near,
            far: this.perspCamera.far
        };
        return this.copy(t), this.name = "", this.enableHelper = !0, this.objectHelper.visible = !0, this.orthoCamera.near = r.near, this.orthoCamera.far = r.far, this.perspCamera.near = n.near, this.perspCamera.far = n.far, this.updateProjectionMatrix(), this;
    }
    toJSON(t) {
        let r = super.toJSON(t), n = r.object;
        return n.objectType = "CombinedCamera", n.cameraType = this.cameraType, n.targetOffset = this.targetOffset, n.isUpVectorFlipped = this.isUpVectorFlipped, n.angleOffsetFromUp = this.angleOffsetFromUp, n.left = this.left, n.right = this.right, n.top = this.top, n.bottom = this.bottom, this.view !== null && (n.view = Object.assign({}, this.view)), n.zoomOrtho = this.orthoCamera.zoom, n.nearOrtho = this.orthoCamera.near, n.far = this.far, n.aspect = this.aspect, n.fov = this.fov, n.focus = this.focus, n.filmGauge = this.filmGauge, n.filmOffset = this.filmOffset, n.zoomPersp = this.perspCamera.zoom, n.nearPersp = this.perspCamera.near, r;
    }
    fromJSON(t) {
        var r;
        if (super.fromJSON(t), this.cameraType = t.cameraType, t.targetOffset !== void 0 && (this.targetOffset = t.targetOffset), t.orbitControlsTarget !== void 0) {
            let n = this.getWorldPosition(new M), s = new M().fromArray(t.orbitControlsTarget);
            this.targetOffset = s.distanceTo(n);
        } else t.targetOffset !== void 0 && (this.targetOffset = t.targetOffset);
        return this.isUpVectorFlipped = !1, this.angleOffsetFromUp = (r = t.angleOffsetFromUp) != null ? r : 0, t.left !== void 0 && (this.left = t.left), t.right !== void 0 && (this.right = t.right), t.top !== void 0 && (this.top = t.top), t.bottom !== void 0 && (this.bottom = t.bottom), t.view !== void 0 && (this.view = Object.assign({}, t.view)), t.zoomOrtho !== void 0 && (this.orthoCamera.zoom = t.zoomOrtho), t.nearOrtho !== void 0 && (this.orthoCamera.near = t.nearOrtho), t.far !== void 0 && (this.far = t.far), t.aspect !== void 0 && (this.aspect = t.aspect), t.fov !== void 0 && (this.fov = t.fov), t.focus !== void 0 && (this.focus = t.focus), t.filmGauge !== void 0 && (this.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (this.filmOffset = t.filmOffset), t.zoomPersp !== void 0 && (this.perspCamera.zoom = t.zoomPersp), t.nearPersp !== void 0 && (this.perspCamera.near = t.nearPersp), this.updateProjectionMatrix(), this;
    }
    toCameraState(t = []) {
        let r = {
            type: this.cameraType,
            far: this.far,
            orthographic: {
                near: this.orthoCamera.near,
                zoom: this.orthoCamera.zoom
            },
            perspective: {
                near: this.perspCamera.near,
                fov: this.perspCamera.fov,
                zoom: this.perspCamera.zoom
            },
            up: this.up.toArray(),
            targetOffset: this.targetOffset,
            isUpVectorFlipped: this.isUpVectorFlipped
        };
        return wl(r, t);
    }
    fromCameraState(t) {
        let { orthographic: r , perspective: n  } = t;
        return t.type !== void 0 && (this.cameraType = t.type), t.far !== void 0 && (this.far = t.far), r !== void 0 && (r.near !== void 0 && (this.orthoCamera.near = r.near), r.zoom !== void 0 && (this.orthoCamera.zoom = r.zoom)), n !== void 0 && (n.near !== void 0 && (this.perspCamera.near = n.near), n.fov !== void 0 && (this.perspCamera.fov = n.fov), n.zoom !== void 0 && (this.perspCamera.zoom = n.zoom)), t.up !== void 0 && this.up.fromArray(t.up), t.targetOffset !== void 0 && (this.targetOffset = t.targetOffset), t.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = t.isUpVectorFlipped), this.updateProjectionMatrix(), this;
    }
    toState(t) {
        return xe(ie(ie({}, super.toState(t)), this.toCameraState(t)), {
            type: this.cameraType
        });
    }
    fromState(t) {
        return super.fromState(t), this.fromCameraState(t), this;
    }
};
var gs = class extends Vi(Qn(ts), Zl) {
    constructor(){
        super(...arguments);
        this.objectType = "EmptyObject";
    }
    static createFromState(t, r) {
        let n = new gs().fromState(r);
        return n.uuid = t, n.enableHelper = !0, n.objectHelper.update(), n;
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "EmptyObject", r;
    }
};
var tc = class extends Vi(Qn(ch), Kl) {
    constructor(...t){
        super(...t);
        this.objectType = "LightDirectional";
        this._gizmos = {};
        this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024;
        let n = this.shadow.camera;
        n.top = 1250, n.bottom = -1250, n.right = 1250, n.left = -1250, n.near = 1, n.far = 2500;
        let s = new Hn(this.shadow.camera);
        s.visible = !1, this._gizmos.shadowmap = s, this.update();
    }
    static createFromState(t, r, n) {
        let s = new tc().fromState(r, n);
        return s.uuid = t, s;
    }
    get gizmos() {
        return this._gizmos;
    }
    showGizmos() {
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Hn && (r.visible = !0);
        }
    }
    hideGizmos() {
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Hn && (r.visible = !1);
        }
    }
    update() {
        this.shadow.camera.updateProjectionMatrix();
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Hn && r.update();
        }
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.enableHelper === !0 && this.objectHelper.visible === !0 && this.objectHelper.update();
    }
    copy(t, r = !0) {
        return super.copy(t, r), this.color.copy(t.color), this.intensity = t.intensity, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
    toJSON(t) {
        let r = super.toJSON(t), n = r.object;
        return n.objectType = "LightDirectional", n.color = this.color.getHex(), n.intensity = this.intensity, n.shadow = this.shadow.toJSON(), r;
    }
    fromJSON(t) {
        var s;
        super.fromJSON(t), this.color.set(t.color), this.intensity = t.intensity, this.shadow.normalBias = (s = t.shadow.normalBias) != null ? s : 0, this.shadow.radius = t.shadow.radius, this.shadow.mapSize.fromArray(t.shadow.mapSize);
        let r = this.shadow.camera, n = t.shadow.camera;
        return r.near = n.near, r.far = n.far, r.zoom = n.zoom, r.left = n.left, r.right = n.right, r.top = n.top, r.bottom = n.bottom, n.view !== void 0 && (r.view = Object.assign({}, n.view)), this;
    }
    fromDirectionalLightState(t, r) {
        let n = t.depth !== void 0 && t.depth !== this.shadow.camera.far || t.size !== void 0 && t.size / 2 !== this.shadow.camera.right;
        return super.fromLightState(t, r), t.size !== void 0 && U1(this, t.size), n && this.update(), this;
    }
    fromState(t, r) {
        return super.fromState(t), this.fromDirectionalLightState(t, r), this;
    }
};
var rc = class extends Vi(Qn(lh), $l) {
    constructor(...t){
        super(...t);
        this.objectType = "LightPoint";
        this._gizmos = {};
        this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024;
        let n = this.shadow.camera;
        n.fov = 90, n.aspect = 1, n.near = 100, n.far = 2500;
        let s = new M(-n.far + this.position.x, -n.far + this.position.y, -n.far + this.position.z), o = new M(n.far + this.position.x, n.far + this.position.y, n.far + this.position.z), a = new Kt(s, o), l = new Fo(a, new be(16755200));
        l.visible = !1, this._gizmos.shadowmap = l, this.update();
    }
    static createFromState(t, r, n) {
        let s = new rc().fromState(r, n);
        return s.uuid = t, s;
    }
    get gizmos() {
        return this._gizmos;
    }
    showGizmos() {
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Fo && (r.visible = !0);
        }
    }
    hideGizmos() {
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Fo && (r.visible = !1);
        }
    }
    update() {
        if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this._gizmos)) for(let t in this._gizmos){
            let r = this._gizmos[t];
            if (r instanceof Fo) {
                let n = this.shadow.camera, s = new M(-n.far + this.position.x, -n.far + this.position.y, -n.far + this.position.z), o = new M(n.far + this.position.x, n.far + this.position.y, n.far + this.position.z);
                r.box.set(s, o), r.updateMatrixWorld(!0);
            }
        }
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.enableHelper === !0 && this.objectHelper.visible === !0 && this.objectHelper.update();
    }
    copy(t, r = !0) {
        return super.copy(t, r), this.color.copy(t.color), this.intensity = t.intensity, this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
    toJSON(t) {
        let r = super.toJSON(t), n = r.object;
        return n.objectType = "LightPoint", n.color = this.color.getHex(), n.intensity = this.intensity, n.distance = this.distance, n.decay = this.decay, n.shadow = this.shadow.toJSON(), r;
    }
    fromJSON(t) {
        var s, o;
        super.fromJSON(t), this.color.set(t.color), this.intensity = t.intensity, this.distance = t.distance, this.decay = t.decay, this.shadow.normalBias = (s = t.shadow.normalBias) != null ? s : 0, this.shadow.radius = t.shadow.radius, this.shadow.mapSize.fromArray((o = t.shadow.mapSize) != null ? o : [
            512,
            512
        ]), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null);
        let r = this.shadow.camera, n = t.shadow.camera;
        return r.near = n.near, r.far = n.far, r.zoom = n.zoom, r.fov = n.fov, r.focus = n.focus, r.aspect = n.aspect, r.filmGauge = n.filmGauge, r.filmOffset = n.filmOffset, n.view !== void 0 && (r.view = Object.assign({}, n.view)), this;
    }
    fromPointLightState(t, r) {
        return super.fromLightState(t, r), t.distance !== void 0 && (this.distance = t.distance), t.decay !== void 0 && (this.decay = t.decay), t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius), t.shadowResolution !== void 0 && (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), this;
    }
    fromState(t, r) {
        return super.fromState(t), this.fromPointLightState(t, r), this;
    }
};
var rA = new M, nA = new M, iA = new zt, nc = class extends Vi(Qn(ah), gu) {
    constructor(...t){
        super(...t);
        this.objectType = "LightSpot";
        this._gizmos = {};
        this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024;
        let n = this.shadow.camera;
        n.fov = et.RAD2DEG * 2 * this.angle, n.aspect = 1, n.near = 100, n.far = 2500;
        let s = new Hn(this.shadow.camera);
        s.visible = !1, this._gizmos.shadowmap = s, this.update();
    }
    static createFromState(t, r, n) {
        let s = new nc().fromState(r, n);
        return s.uuid = t, s;
    }
    get gizmos() {
        return this._gizmos;
    }
    showGizmos() {
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Hn && (r.visible = !0);
        }
    }
    hideGizmos() {
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Hn && (r.visible = !1);
        }
    }
    update() {
        this.shadow.camera.updateProjectionMatrix();
        for(let t in this._gizmos){
            let r = this._gizmos[t];
            r instanceof Hn && r.update();
        }
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), nA.setFromMatrixPosition(this.matrixWorld), iA.setFromRotationMatrix(this.matrixWorld), rA.copy(this.up).applyQuaternion(iA).negate().multiplyScalar(this.distance), this.target.position.copy(nA).add(rA), this.target.updateMatrixWorld(), this.enableHelper === !0 && this.objectHelper.visible === !0 && this.objectHelper.update();
    }
    copy(t, r = !0) {
        return super.copy(t, r), this.color.copy(t.color), this.intensity = t.intensity, this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
    toJSON(t) {
        let r = super.toJSON(t), n = r.object;
        return n.objectType = "LightSpot", n.color = this.color.getHex(), n.intensity = this.intensity, n.distance = this.distance, n.angle = this.angle, n.decay = this.decay, n.penumbra = this.penumbra, n.shadow = this.shadow.toJSON(), r;
    }
    fromJSON(t) {
        var s;
        super.fromJSON(t), this.color.set(t.color), this.intensity = t.intensity, this.distance = t.distance, this.angle = t.angle, this.decay = t.decay, this.penumbra = t.penumbra, this.shadow.normalBias = (s = t.shadow.normalBias) != null ? s : 0, this.shadow.radius = t.shadow.radius, this.shadow.mapSize.fromArray(t.shadow.mapSize);
        let r = this.shadow.camera, n = t.shadow.camera;
        return r.near = n.near, r.far = n.far, r.zoom = n.zoom, r.fov = n.fov, r.focus = n.focus, r.aspect = n.aspect, r.filmGauge = n.filmGauge, r.filmOffset = n.filmOffset, n.view !== void 0 && (r.view = Object.assign({}, n.view)), this;
    }
    fromSpotLightState(t, r) {
        return super.fromLightState(t, r), t.distance !== void 0 && (this.distance = t.distance), t.decay !== void 0 && (this.decay = t.decay), t.angle !== void 0 && (this.angle = t.angle), t.penumbra !== void 0 && (this.penumbra = t.penumbra), this;
    }
    fromState(t, r) {
        return super.fromState(t), this.fromSpotLightState(t, r), this;
    }
};
var sA = (i)=>i.tagName === "VIDEO"
, $o = class {
    static resize(e, t, r) {
        let n = e / t, s;
        if (!r.image) return;
        let o = r.image;
        sA(o) ? s = o.videoWidth / o.videoHeight : s = o.width / o.height, n > s && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1 * s / n) : r.repeat.set(1, 1 * s / n)), n < s && (r.imageType == "WEBCAM" ? r.repeat.set(1 * n / s * -1, 1) : r.repeat.set(1 * n / s, 1)), n == s && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1) : r.repeat.set(1, 1));
    }
    static resizeTextureLayer(e, t, r) {
        let n = e / t, s = r.image !== void 0 ? r.image.width / r.image.height : 1, o;
        n > s ? o = {
            x: 1,
            y: s / n
        } : n < s ? o = {
            x: n / s,
            y: 1
        } : o = {
            x: 1,
            y: 1
        }, r.repeat.set(o.x, o.y), r.updateMatrix();
    }
    static resizeTextureLayers(e, t, r) {
        let n = r.userData.layers, s = n.getLayers();
        for(let o = 0; o < s.length; o++){
            let a = s[o];
            D1(a) && ($o.resizeTextureLayer(e, t, a.uniforms[`f${a.id}_texture`].value), n.updateLayerUniform());
        }
    }
    static resizeComplex(e, t, r, n) {
        let s = e / t, o, a = r.image;
        sA(a) ? o = a.videoWidth / a.videoHeight : o = a.width / a.height, n.geometry.type.includes("Shape") ? (s > o && (r.imageType == "WEBCAM" ? r.repeat.set(1 / e * -1, 1 / t * o / s) : r.repeat.set(1 / e, 1 / t * o / s)), s < o && (r.imageType == "WEBCAM" ? r.repeat.set(1 / e * s / o * -1, 1 / t) : r.repeat.set(1 / e * s / o, 1 / t)), s == o && (r.imageType == "WEBCAM" ? r.repeat.set(1 / e * -1, 1 / t) : r.repeat.set(1 / e, 1 / t))) : (s > o && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1 * o / s) : r.repeat.set(1, 1 * o / s)), s < o && (r.imageType == "WEBCAM" ? r.repeat.set(1 * s / o * -1, 1) : r.repeat.set(1 * s / o, 1)), s == o && (r.imageType == "WEBCAM" ? r.repeat.set(-1, 1) : r.repeat.set(1, 1)));
    }
};
var ic = class extends kt {
    constructor(t, r = new Yr){
        super(t, r);
        this.objectType = "Mesh2D";
        this.castShadow = !0, this.receiveShadow = !0;
    }
    updateGeometry(t) {
        super.updateGeometry(t), this.material.userData.layers && $o.resizeTextureLayers(this.geometry.userData.parameters.width, this.geometry.userData.parameters.height, this.material);
    }
    resizeGeometry(t, r) {
        super.resizeGeometry(t, r, 0), this.material.userData.layers && $o.resizeTextureLayers(this.geometry.userData.parameters.width, this.geometry.userData.parameters.height, this.material);
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "Mesh2D", r;
    }
    clone() {
        let t = super.clone();
        return t.updateGeometry({}), t;
    }
    static fromTexture(t) {
        let r, n;
        if (t instanceof eh) {
            let a = t.image;
            r = a.videoWidth * .5, n = a.videoHeight * .5;
        } else {
            let a = t.image;
            r = a.width * .5, n = a.height * .5;
        }
        let s = vp.create({
            parameters: {
                width: r,
                height: n
            }
        }), o = new Yr;
        return o.layersList.changeLayer(0, {
            type: "texture",
            texture: t
        }), o.layersList.moveLayer(0, 1), o.dispose(), new ic(s, o);
    }
};
var sc = class extends kt {
    constructor(t, r = new pn){
        super(t, r);
        this.objectType = "Mesh3D";
        this.castShadow = !0, this.receiveShadow = !0;
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "Mesh3D", r;
    }
};
var oc = class extends sc {
    constructor(t, r = new pn){
        super(t, r);
        this.objectType = "NonParametric";
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "NonParametric", r;
    }
};
var Wp = class extends cn {
    constructor(e){
        super(e);
    }
    load(e, t, r, n) {
        let s = this, o = new as(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            let l;
            try {
                l = JSON.parse(a);
            } catch  {
                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), l = JSON.parse(a.substring(65, a.length - 2));
            }
            let c = s.parse(l);
            t && t(c);
        }, r, n);
    }
    parse(e) {
        return new jp(e);
    }
}, jp = class {
    constructor(e){
        this.type = "Font", this.data = e;
    }
    generateShapes(e, t = 100) {
        let r = [], n = JF(e, t, this.data);
        for(let s = 0, o = n.length; s < o; s++)Array.prototype.push.apply(r, n[s].toShapes());
        return r;
    }
};
function JF(i, e, t) {
    let r = Array.from(i), n = e / t.resolution, s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n, o = [], a = 0, l = 0;
    for(let c = 0; c < r.length; c++){
        let h = r[c];
        if (h === `
`) a = 0, l -= s;
        else {
            let u = KF(h, n, a, l, t);
            a += u.offsetX, o.push(u.path);
        }
    }
    return o;
}
function KF(i, e, t, r, n) {
    let s = n.glyphs[i] || n.glyphs["?"];
    if (!s) {
        console.error('THREE.Font: character "' + i + '" does not exists in font family ' + n.familyName + ".");
        return;
    }
    let o = new Kf, a, l, c, h, u, f, d, p;
    if (s.o) {
        let m = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for(let g = 0, v = m.length; g < v;)switch(m[g++]){
            case "m":
                a = m[g++] * e + t, l = m[g++] * e + r, o.moveTo(a, l);
                break;
            case "l":
                a = m[g++] * e + t, l = m[g++] * e + r, o.lineTo(a, l);
                break;
            case "q":
                c = m[g++] * e + t, h = m[g++] * e + r, u = m[g++] * e + t, f = m[g++] * e + r, o.quadraticCurveTo(u, f, c, h);
                break;
            case "b":
                c = m[g++] * e + t, h = m[g++] * e + r, u = m[g++] * e + t, f = m[g++] * e + r, d = m[g++] * e + t, p = m[g++] * e + r, o.bezierCurveTo(u, f, d, p, c, h);
                break;
        }
    }
    return {
        offsetX: s.ha * e,
        path: o
    };
}
jp.prototype.isFont = !0;
var mr = class extends Vt {
    constructor({ char: t , originalChar: r , fontFamily: n , letterSpacing: s , fontSize: o , LOD: a = 16  }, l = new zn({
        color: 0,
        opacity: 1,
        visible: !0,
        transparent: !0,
        side: or
    })){
        let c = mr.loadChar(t, n, a);
        super(c.geometry, l);
        this.char = t, this.originalChar = r != null ? r : t, this.fontFamily = n, this.letterSpacing = s, this.fontSize = o, this.LOD = a, this.resolution = c.resolution, this.glyphsHa = c.glyphsHa, this.localPosition = new B, this.charSize = 0, this.geometry.userData = {
            type: "CharacterGeometry",
            parameters: {
                char: this.char,
                fontFamily: this.fontFamily,
                letterSpacing: this.letterSpacing,
                fontSize: this.fontSize,
                lod: this.LOD,
                resolution: this.resolution,
                charSize: this.charSize,
                localPosition: this.localPosition
            }
        }, this.updateFontSize(this.fontSize);
    }
    static get FONTS_PATH() {
        return mr._fontPath;
    }
    static set FONTS_PATH(t) {
        mr._fontPath = t;
    }
    updatePosition(t, r) {
        this.localPosition.copy(t);
        let n = new M(this.localPosition.x, -this.localPosition.y, 0);
        this.position.copy(n).add(r);
    }
    updateFontSize(t) {
        let r = t / this.resolution;
        this.fontSize = t, this.scale.set(this.fontSize, this.fontSize, 1), this.charSize = this.glyphsHa * r * this.letterSpacing;
    }
    updateFontFamily(t) {
        if (this.fontFamily === t) return;
        this.fontFamily = t;
        let r = mr.loadChar(this.char, t, this.LOD);
        this.geometry = r.geometry, this.resolution = r.resolution, this.glyphsHa = r.glyphsHa, this.geometry.userData = {
            type: "CharacterGeometry",
            parameters: {
                char: this.char,
                fontFamily: this.fontFamily,
                letterSpacing: this.letterSpacing,
                fontSize: this.fontSize,
                lod: this.LOD,
                resolution: this.resolution,
                charSize: this.charSize,
                localPosition: this.localPosition
            }
        }, this.updateFontSize(this.fontSize);
    }
    updateChar(t) {
        if (this.char === t) return;
        this.char = t;
        let r = mr.loadChar(t, this.fontFamily, this.LOD);
        this.geometry = r.geometry, this.resolution = r.resolution, this.glyphsHa = r.glyphsHa, this.geometry.userData = {
            type: "CharacterGeometry",
            parameters: {
                char: this.char,
                fontFamily: this.fontFamily,
                letterSpacing: this.letterSpacing,
                fontSize: this.fontSize,
                lod: this.LOD,
                resolution: this.resolution,
                charSize: this.charSize,
                localPosition: this.localPosition
            }
        }, this.updateFontSize(this.fontSize);
    }
    updateLetterSpacing(t) {
        this.letterSpacing !== t && (this.letterSpacing = t, this.updateFontSize(this.fontSize));
    }
    updateLOD(t) {
        if (this.LOD === t) return;
        this.LOD = t;
        let r = mr.loadChar(this.char, this.fontFamily, this.LOD);
        this.geometry = r.geometry, this.resolution = r.resolution, this.glyphsHa = r.glyphsHa, this.geometry.userData = {
            type: "CharacterGeometry",
            parameters: {
                char: this.char,
                fontFamily: this.fontFamily,
                letterSpacing: this.letterSpacing,
                fontSize: this.fontSize,
                lod: this.LOD,
                resolution: this.resolution,
                charSize: this.charSize,
                localPosition: this.localPosition
            }
        }, this.updateFontSize(this.fontSize);
    }
    clone() {
        let t = {
            char: this.char,
            originalChar: this.originalChar,
            fontFamily: this.fontFamily,
            letterSpacing: this.letterSpacing,
            fontSize: this.fontSize,
            LOD: this.LOD
        };
        return new mr(t).copy(this);
    }
    static loadFont(t) {
        return new Promise(function(r, n) {
            mr.fontCache[t] ? r(mr.fontCache[t]) : new Wp().load(mr.FONTS_PATH + t + ".json", (o)=>{
                mr.fontCache[t] = o, r(o);
            }, void 0, n);
        });
    }
    static loadChar(t, r, n) {
        if (mr.charCache[t]) {
            if (mr.charCache[t][n] && mr.charCache[t][n].fontFamily === r) return mr.charCache[t][n];
        } else mr.charCache[t] = {};
        let s = mr.fontCache[r], o = s.generateShapes(t, 1);
        return mr.charCache[t][n] = {
            geometry: new Io(o, n),
            fontFamily: r,
            resolution: s.data.resolution,
            glyphsHa: s.data.glyphs[t].ha
        }, mr.charCache[t][n];
    }
}, mn = mr;
mn.charCache = {}, mn.fontCache = {}, mn._fontPath = "/_assets/_fonts/";
var qp = new B, uo = class {
    constructor(e, t, r){
        this.message = [];
        this.endLine = !0;
        this.yLinePos = e, this.lineHeight = t, this.maxCharSize = r, this.nextChar3DPos = new B(0, this.yLinePos + this.maxCharSize * this.lineHeight), this.align = 1;
    }
    addChar3D(e, t, r = this.message.length) {
        this.message.splice(r, 0, e), e.fontSize > this.maxCharSize ? (this.maxCharSize = e.fontSize, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight, this.fullUpdate(t)) : (e.updatePosition(this.nextChar3DPos, t), this.nextChar3DPos.x += e.charSize);
    }
    deleteChar3D(e = this.message.length - 1) {
        let t = this.message[e];
        if (t) return this.message.splice(e, 1), this.nextChar3DPos.x -= t.charSize, t;
    }
    isEndLine(e) {
        this.endLine = e;
    }
    fullUpdate(e, t = 0) {
        this.nextChar3DPos.x = 0;
        for(let r = t, n = this.message.length; r < n; r += 1)this.message[r].updatePosition(this.nextChar3DPos, e), this.nextChar3DPos.x += this.message[r].charSize;
    }
    checkOverFlow(e) {
        let t, r = this.message.length - 1;
        if (r <= 0) return !1;
        for(; r >= 0;){
            if (this.message[r].char !== " ") {
                t = this.message[r];
                break;
            }
            r -= 1;
        }
        return !!(r >= 0 && t && t.localPosition.x + t.charSize > e);
    }
    containSpaceOverFlow(e = this.message.length - 1) {
        for(let t = e; t >= 0; t -= 1)if (this.message[t].char === " ") return !0;
        return !1;
    }
    containSpace(e = this.message.length - 1) {
        if (this.endLine) return !0;
        for(let t = e; t >= 0; t -= 1)if (this.message[t].char === " ") return !0;
        return !1;
    }
    popWord(e = this.message.length - 1) {
        let t = [], r = !0, n;
        for(n = e; n >= 0; n -= 1)if (this.message[n].char === " ") {
            r = !1, t.length === 0 && (n -= 1, t.splice(0, 0, this.message[n]));
            break;
        } else t.splice(0, 0, this.message[n]);
        return r ? t = [] : this.message.splice(n + 1, t.length), t;
    }
    getWord(e = 0, t = 1) {
        let r = [], n = e;
        for(n = e;; n += t){
            if (!this.message[n] || this.message[n].char === " ") {
                r.length === 0 && this.message[n] && (r.push(this.message[n]), this.message.splice(n, 1));
                break;
            }
            t > 0 ? (r.push(this.message[n]), this.message.splice(n, 1), n -= t) : (r.splice(0, 0, this.message[n]), this.message.splice(n, 1));
        }
        return r;
    }
    getWordAtIndex(e) {
        let t = [];
        for(let r = e; r < this.message.length && this.message[r].char !== " "; r++)t.push(this.message[r]);
        for(let r16 = e - 1; r16 >= 0 && this.message[r16].char !== " "; r16--)t.splice(0, 0, this.message[r16]);
        return t;
    }
    wordSize(e = 0, t = -1) {
        let r = 0, n = e;
        for(; n >= 0 && n < this.message.length;){
            if (this.message[n].char === " ") {
                r === 0 && (r = this.message[n].charSize);
                break;
            }
            r += this.message[n].charSize, n += t;
        }
        return (n < 0 || n >= this.message.length) && !this.endLine ? this.message[e] ? this.message[e].charSize : 999999999 : r === 0 ? 999999999 : r;
    }
    spaceLeft(e) {
        return e - this.nextChar3DPos.x;
    }
    popChar(e = this.message.length - 1) {
        return this.nextChar3DPos.x -= this.message[e].charSize, this.message.splice(e, 1);
    }
    isEmpty() {
        return !this.message.length;
    }
    updateNextCharPosY() {
        this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight;
    }
    updateYLinePos(e) {
        this.yLinePos = e, this.updateNextCharPosY();
    }
    updatelineHeight(e) {
        this.lineHeight = e, this.updateNextCharPosY();
    }
    updateFontSize(e, t = 0, r = this.message.length - 1) {
        for(let n = t; n <= r; n += 1)this.message[n].updateFontSize(e);
        this.maxCharSize = e, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight;
    }
    countSpaces() {
        let e = 0;
        for(let t = 0; t < this.message.length; t++)this.message[t].char === " " && (e += 1);
        return e;
    }
    alignText(e, t, r, n, s) {
        switch(r){
            case 1:
                this.leftAlign(e, s);
                break;
            case 3:
                this.centerAlign(this.spaceLeft(t), e, s);
                break;
            case 2:
                this.rightAlign(this.spaceLeft(t), e, s);
                break;
            case 4:
                this.justifyAlign(this.spaceLeft(t), e, s);
                break;
        }
    }
    offsetCharacters(e, t, r) {
        qp.set(t, r);
        let n = this.message.length;
        for(let s = 0; s < n; s++)this.message[s].updatePosition(this.message[s].localPosition.add(qp), e);
    }
    leftAlign(e, t) {
        this.align = 1, this.offsetCharacters(e, 0, t);
    }
    centerAlign(e, t, r) {
        this.align = 3, this.offsetCharacters(t, e / 2, r);
    }
    rightAlign(e, t, r) {
        this.align = 2, this.offsetCharacters(t, e, r);
    }
    justifyAlign(e, t, r) {
        if (this.align = 4, this.endLine) {
            this.offsetCharacters(t, 0, r);
            return;
        }
        let n = this.countSpaces();
        if (n === 0) {
            this.offsetCharacters(t, 0, r);
            return;
        }
        let s = e / n, o = 0;
        for(let a = 0; a < this.message.length; a++)this.message[a].char === " " && (o += s), qp.set(o, r), this.message[a].updatePosition(this.message[a].localPosition.add(qp), t);
    }
    clone() {
        let e = new uo(this.yLinePos, this.lineHeight, this.maxCharSize);
        e.nextChar3DPos = this.nextChar3DPos.clone(), e.align = this.align, e.endLine = this.endLine;
        for(let t = 0; t < this.message.length; t++)e.message.push(this.message[t].clone());
        return e;
    }
};
var Fv = class extends kt {
    constructor(t, r = new Yr({
        transparent: !0,
        opacity: 1,
        visible: !1,
        side: or
    })){
        super(t, r);
        this.objectType = "TextFrame";
        this.charContainer = new ot, this.add(this.charContainer), this.material.visible = !1, this._geometryUserData = t.userData, this.userData.textFrame = {
            hexColor: null,
            opacity: 1,
            visible: !0,
            text: "",
            fontSize: 16,
            lineHeight: 1.5,
            letterSpacing: 1,
            fontFamily: "roboto_regular",
            textTransform: 1,
            horizontalAlignment: 1,
            verticalAlignment: 1,
            LOD: 16,
            maxLineSize: this._geometryUserData.parameters.width,
            textOrigin: new M(this._geometryUserData.parameters.width * -0.5, this._geometryUserData.parameters.height * .5, 0),
            textLines: []
        }, this.createTextLine();
    }
    static createFromState(t, r, n) {
        let s = xp.create({
            parameters: {
                width: r.width,
                height: r.height
            }
        }), o = new Fv(s).fromState(r, n);
        return o.uuid = t, o;
    }
    async updateText(t) {
        this.clearText();
        let r = this.userData.textFrame, n = r.fontFamily;
        await mn.loadFont(n), r.text = t;
        let s = r.textOrigin, o = new zn({
            visible: r.visible,
            transparent: !0,
            side: or
        }), a = t.split(`
`), l = 0;
        this.userData.textFrame.textLines = a.map((c, h)=>{
            let u = new uo(l, r.lineHeight, r.fontSize);
            return u.message = c.split("").map((f)=>{
                let d = {
                    char: f,
                    fontFamily: n,
                    letterSpacing: r.letterSpacing,
                    fontSize: r.fontSize,
                    LOD: 16
                }, p = o.clone();
                p.color = r.hexColor, p.opacity = r.opacity;
                let m = new mn(d, p);
                return u.addChar3D(m, s), this.charContainer.add(m), m;
            }), l += u.maxCharSize * u.lineHeight, u;
        }), this.textFullUpdate(), this.checkOverFlow();
    }
    clearText() {
        let t = this.userData.textFrame.textLines;
        for(; this.charContainer.children.length;){
            let r = this.charContainer.children[0];
            this.charContainer.remove(r);
        }
        for(; t.length;)t.pop();
    }
    raycast(t, r) {
        let n = [];
        if (super.raycast(t, n), n.length > 0) {
            r.push(n[0]);
            return;
        }
        let s = [];
        for(let o = 0, a = this.charContainer.children.length; o < a; ++o)if (this.charContainer.children[o] instanceof mn && (t.intersectObject(this.charContainer.children[o], !1, s), s.length > 0)) {
            s[0].object = this, r.push(s[0]);
            return;
        }
    }
    updateGeometry(t) {
        var h, u, f, d;
        let r = this.userData, n = this.geometry.userData, s = n.parameters.width, o = n.parameters.height, a = (u = (h = t.parameters) == null ? void 0 : h.width) != null ? u : s, l = (d = (f = t.parameters) == null ? void 0 : f.height) != null ? d : o, c = r.textFrame;
        super.updateGeometry(t), c.maxLineSize = a, c.textOrigin.set(-0.5 * a, .5 * l, 0), l !== o ? (this.checkOverFlow(), this.checkCapacity()) : a !== s && (s < a ? this.checkCapacity() : s > a && this.checkOverFlow());
    }
    checkOverFlow(t = 0) {
        let r = this.userData, n = r.textFrame.textOrigin, s = r.textFrame.textLines;
        for(let o = t; o < s.length; o++){
            s[o].updateYLinePos(this.getNewLinePosition(o)), s[o].fullUpdate(n);
            let a = [];
            for(; s[o].checkOverFlow(r.textFrame.maxLineSize);)s[o].containSpaceOverFlow() ? a.unshift(s[o].getWord(s[o].message.length - 1, -1)) : a.unshift(s[o].popChar());
            if (a.length > 0) {
                s[o + 1] === void 0 ? (s[o].isEndLine(!1), this.createTextLine()) : s[o].endLine && (this.createTextLine(o + 1), s[o].isEndLine(!1), s[o + 1].isEndLine(!0));
                let l = 0;
                for(let c = 0; c < a.length; c += 1)for(let h = 0; h < a[c].length; h += 1)s[o + 1].addChar3D(a[c][h], n, l), l += 1;
                s[o + 1].fullUpdate(n);
            }
            s[o].fullUpdate(n);
        }
        this.textFullUpdate(t);
    }
    checkCapacity(t = 0) {
        let r = this.userData, n = r.textFrame.textOrigin, s = r.textFrame.maxLineSize, o = r.textFrame.textLines;
        for(let a = t; a < o.length; a += 1)if (o[a].updateYLinePos(this.getNewLinePosition(a)), o[a].fullUpdate(n), !!o[a - 1]) for(; !o[a - 1].endLine;){
            let l, c = o[a - 1].spaceLeft(s);
            if (o[a].wordSize(0, 1) <= c) {
                o[a].containSpace() ? l = o[a].getWord(0, 1) : l = o[a].popChar(0);
                for(let h = 0; h < l.length; h += 1)l[h] && o[a - 1].addChar3D(l[h], n);
            } else {
                o[a].isEmpty() ? (o[a].endLine && o[a - 1].isEndLine(!0), o.splice(a, 1), a -= 1) : (o[a].updateYLinePos(this.getNewLinePosition(a)), o[a].fullUpdate(n));
                break;
            }
        }
        this.textFullUpdate(t);
    }
    createTextLine(t = this.userData.textFrame.textLines.length) {
        let n = this.userData.textFrame;
        n.textLines.splice(t, 0, new uo(this.getNewLinePosition(t), n.lineHeight, n.fontSize));
    }
    textFullUpdate(t = 0) {
        let n = this.userData.textFrame, s = n.textLines, o = this.getVerticalAlignmentOffSet();
        for(let a = t; a < s.length; a++)s[a].updateYLinePos(this.getNewLinePosition(a)), s[a].fullUpdate(n.textOrigin), s[a].alignText(n.textOrigin, n.maxLineSize, n.horizontalAlignment, n.verticalAlignment, o);
    }
    getVerticalAlignmentOffSet() {
        switch(this.userData.textFrame.verticalAlignment){
            case 1:
                return 0;
            case 2:
                return this.getRemainingVerticalSpace() / 2;
            case 3:
                return this.getRemainingVerticalSpace();
            default:
                return 0;
        }
    }
    getRemainingVerticalSpace() {
        let r = this.userData.textFrame.textLines;
        return this.geometry.userData.parameters.height - this.getNewLinePosition(r.length);
    }
    getNewLinePosition(t) {
        let n = this.userData.textFrame.textLines, s = 0;
        for(let o = 0; o < t; o += 1)s += n[o].maxCharSize * n[o].lineHeight;
        return s;
    }
    updateColor(t) {
        var s;
        let r = this.userData;
        r.textFrame.hexColor = t;
        let n = r.textFrame.textLines;
        for(let o = 0; o < n.length; o++){
            let a = n[o].message;
            for(let l = 0; l < a.length; l++){
                let c = a[l].material;
                (s = c.color) != null && s.isColor && (c.color = t);
            }
        }
    }
    updateOpacity(t) {
        let r = this.userData;
        r.textFrame.opacity = t;
        let n = r.textFrame.textLines;
        for(let s = 0; s < n.length; s++){
            let o = n[s].message;
            for(let a = 0; a < o.length; a++){
                let l = o[a].material;
                l.opacity = t;
            }
        }
    }
    updateVisible(t) {
        let r = this.userData;
        r.textFrame.visible = t;
        let n = r.textFrame.textLines;
        for(let s = 0; s < n.length; s++){
            let o = n[s].message;
            for(let a = 0; a < o.length; a++){
                let l = o[a].material;
                l.visible = t;
            }
        }
    }
    async updateFontFamily(t) {
        await mn.loadFont(t);
        let n = this.userData.textFrame, s = n.textLines;
        n.fontFamily = t;
        for(let o = 0; o < s.length; o++){
            let a = s[o].message;
            for(let l = 0; l < a.length; l++)a[l].updateFontFamily(t);
        }
        this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
    }
    updateFontSize(t) {
        let n = this.userData.textFrame, s = n.textLines, o = n.fontSize;
        n.fontSize = t;
        for(let a = 0; a < s.length; a++)s[a].updateFontSize(t);
        this.textFullUpdate(), t > o ? this.checkOverFlow() : t < o && this.checkCapacity();
    }
    async updateTextTransform(t) {
        let n = this.userData.textFrame;
        await mn.loadFont(n.fontFamily);
        let s = n.textLines;
        switch(n.textTransform = t, t){
            case 2:
                for(let o = 0; o < s.length; o++){
                    let a = s[o].message;
                    for(let l = 0; l < a.length; l++)s[o].message[l].updateChar(a[l].char.toUpperCase());
                }
                break;
            case 3:
                for(let o8 = 0; o8 < s.length; o8++){
                    let a = s[o8].message;
                    for(let l = 0; l < a.length; l++)s[o8].message[l].updateChar(a[l].char.toLowerCase());
                }
                break;
            default:
                for(let o9 = 0; o9 < s.length; o9++){
                    let a = s[o9].message;
                    for(let l = 0; l < a.length; l++)s[o9].message[l].updateChar(a[l].originalChar);
                }
        }
        this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
    }
    updateLetterSpacing(t) {
        let r = this.userData, n = r.textFrame.textLines;
        r.textFrame.letterSpacing = t;
        for(let s = 0; s < n.length; s++){
            let o = n[s].message;
            for(let a = 0; a < o.length; a++)o[a].updateLetterSpacing(t);
        }
        this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
    }
    updateLOD(t) {
        let r = this.userData;
        r.textFrame.LOD = t;
        let n = r.textFrame.textLines;
        for(let s = 0; s < n.length; s++);
        this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
    }
    updateLineHeight(t) {
        let r = this.userData, n = r.textFrame.textLines;
        r.textFrame.lineHeight = t;
        for(let s = 0; s < n.length; s++)n[s].updatelineHeight(t);
        this.textFullUpdate();
    }
    updateVerticalAlignment(t) {
        let r = this.userData;
        r.textFrame.verticalAlignment = t, this.textFullUpdate();
    }
    updateHorizontalAlignment(t) {
        let r = this.userData;
        r.textFrame.horizontalAlignment = t, this.textFullUpdate();
    }
    toJSON(t) {
        let r = super.toJSON(t), n = r.object;
        n.objectType = "TextFrame";
        let o = this.userData.textFrame.textLines.map((a)=>{
            let l = a.message.map((c)=>({
                    char: c.char,
                    originalChar: c.originalChar,
                    fontFamily: c.fontFamily,
                    letterSpacing: c.letterSpacing,
                    fontSize: c.fontSize,
                    LOD: c.LOD
                })
            );
            return {
                align: a.align,
                endLine: a.endLine,
                lineHeight: a.lineHeight,
                maxCharSize: a.maxCharSize,
                yLinePos: a.yLinePos,
                message: l
            };
        });
        return n.userData.textFrame.textLinesData = o, r;
    }
    async fromJSONasync(t) {
        if (super.fromJSON(t), t.userData !== void 0) {
            let r = t.userData.textFrame;
            await mn.loadFont(r.fontFamily), r.textOrigin = new M(r.textOrigin.x, r.textOrigin.y, r.textOrigin.z);
            let n = new zn({
                color: r.hexColor,
                opacity: r.opacity,
                visible: r.visible,
                transparent: !0,
                side: or
            });
            r.textLinesData && (r.textLines = r.textLinesData.map((s, o)=>{
                let a = new uo(Number(s.yLinePos), Number(s.lineHeight), Number(s.maxCharSize)), l = s.message.map((c, h)=>{
                    if (c.char === void 0) {
                        let d = r.textLines[o].message[h];
                        if ("geometries" in d) {
                            let p = d.geometries[0].userData.parameters;
                            Object.assign(c, {
                                LOD: p.lod,
                                char: p.char,
                                fontFamily: p.fontFamily,
                                fontSize: p.fontSize,
                                letterSpacing: p.letterSpacing,
                                originalChar: p.char
                            });
                        }
                    }
                    let u = {
                        char: c.char,
                        fontFamily: c.fontFamily,
                        letterSpacing: Number(c.letterSpacing),
                        fontSize: Number(c.fontSize),
                        LOD: c.LOD
                    }, f = new mn(u, n.clone());
                    return a.addChar3D(f, r.textOrigin), this.charContainer.add(f), f;
                });
                return a.message = l, a;
            }), this.userData.textFrame = r), this.textFullUpdate();
        }
        return this;
    }
    fromTextFrameData(t, r) {
        if (t.color !== void 0) {
            let n = pr(t.color, r);
            this.updateColor(n), this.updateOpacity(n.a);
        }
        t.alpha !== void 0 && this.updateOpacity(t.alpha), t.font !== void 0 && this.updateFontFamily(t.font), t.horizontalAlign !== void 0 && this.updateHorizontalAlignment(t.horizontalAlign), t.verticalAlign !== void 0 && this.updateVerticalAlignment(t.verticalAlign), t.textTransform !== void 0 && this.updateTextTransform(t.textTransform), t.fontSize !== void 0 && this.updateFontSize(t.fontSize), t.lineHeight !== void 0 && this.updateLineHeight(t.lineHeight), t.letterSpacing !== void 0 && this.updateLetterSpacing(t.letterSpacing), t.text !== void 0 && t.text !== "" && this.updateText(t.text), (t.width !== void 0 || t.height !== void 0) && this.updateGeometry({
            parameters: {
                width: t.width,
                height: t.height
            }
        });
    }
    fromState(t, r) {
        return super.fromState(t), this.fromTextFrameData(t, r), this;
    }
    convertToVector() {
        let { fontFamily: t , hexColor: r  } = this.userData.textFrame, n = new gs;
        n.name = "Text Shape";
        let s = mn.fontCache[t];
        for (let o of this.charContainer.children)o instanceof mn && s.generateShapes(o.char, 1).forEach((a)=>{
            let l = new Tt().fromShape(a);
            l.applyScale(o.scale.x, o.scale.y);
            let c = Hr.create({
                shape: l
            }), h = new Yr({
                side: or
            });
            h.color = r;
            let u = new ho(c, h);
            u.name = o.char, u.position.copy(o.position), u.rotation.copy(o.rotation), n.attach(u);
        });
        return n;
    }
}, ea = Fv;
ea.VerticalAlign = ky, ea.HorizontalAlign = Gy, ea.TextTransform = Vy;
var cA = FT(aA());
var Uv;
bp.then((i)=>{
    Uv = i;
});
var hA = new Ae, ZF = new Ae, $F = new Ae, vi = new Kt, fo = new M, eU = new Ae, tU = new Ae, po = class extends kt {
    constructor(t, r, n, s = new pn){
        super(n != null ? n : r, s);
        this.subdivPointer = t;
        this.originalGeometry = r;
        this.subdividedGeometry = n;
        this.objectType = "SubdivObject";
        this.hiddenMatrixOld = new Ae;
        this.smoothShading = !0;
        this.matrixWorldRigid = new Ae;
        this.castShadow = !0, this.receiveShadow = !0, this.forceComputeSize = !1;
    }
    static createFromState(t, r, n) {
        let { subdivPointer: s , originalGeometry: o , subdividedGeometry: a  } = gi.build(r.geometry, void 0, !r.flatShading), l = uu(r.material, n), c = new po(s, o, a || void 0, l);
        return c.calcBoundingBox(), c.freeSubdivPointer(), c.uuid = t, c.fromState(r), c;
    }
    shallowClone(t) {
        return new oc(this.geometry, this.material).shallowCopy(this, t);
    }
    toJSON(t) {
        let r = super.toJSON(t);
        return r.object.objectType = "SubdivObject", r;
    }
    buildFromStore(t) {
        var o, a, l;
        let { originalGeometry: r , subdividedGeometry: n , subdivPointer: s  } = gi.build(t, this.subdivPointer, this.smoothShading, this.shearScale);
        if (this.subdivPointer = s, r !== void 0 && ((o = this.originalGeometry) == null || o.dispose(), this.originalGeometry = r), n !== void 0 && ((a = this.subdividedGeometry) == null || a.dispose(), this.subdividedGeometry = n != null ? n : void 0), this.geometry = (l = this.subdividedGeometry) != null ? l : this.originalGeometry, this.cloner) for (let c of this.cloner.children)c.geometry = this.geometry;
        t.width && (this.geometry.userData.parameters = {
            width: t.width,
            height: t.height,
            depth: t.depth
        });
    }
    updateMesh(t = !1) {
        gi.buildLevel(this.subdivPointer, !0, this.smoothShading, this.originalGeometry, t ? this.shearScaleInv : void 0), this.subdividedGeometry && gi.buildLevel(this.subdivPointer, !1, this.smoothShading, this.subdividedGeometry, t ? this.shearScaleInv : void 0);
    }
    updateTopology() {
        var t;
        this.originalGeometry.dispose(), this.originalGeometry = gi.buildLevel(this.subdivPointer, !0, this.smoothShading), this.subdividedGeometry && (this.subdividedGeometry.dispose(), this.subdividedGeometry = gi.buildLevel(this.subdivPointer, !1, this.smoothShading)), this.geometry = (t = this.subdividedGeometry) != null ? t : this.originalGeometry;
    }
    raycast(t, r) {
        var n;
        this.geometry = this.originalGeometry, kt.prototype.raycast.call(this, t, r), this.geometry = (n = this.subdividedGeometry) != null ? n : this.originalGeometry;
    }
    updateMatrixWorldSVD() {
        let t = this.matrixWorld.elements, r = [
            [
                t[0],
                t[4],
                t[8]
            ],
            [
                t[1],
                t[5],
                t[9]
            ],
            [
                t[2],
                t[6],
                t[10]
            ]
        ], { u: n , v: s , q: o  } = (0, cA.SVD)(r), a = hA.set(n[0][0], n[0][1], n[0][2], 0, n[1][0], n[1][1], n[1][2], 0, n[2][0], n[2][1], n[2][2], 0, 0, 0, 0, 1), l = ZF.set(s[0][0], s[0][1], s[0][2], 0, s[1][0], s[1][1], s[1][2], 0, s[2][0], s[2][1], s[2][2], 0, 0, 0, 0, 1), c = $F.copy(l).transpose();
        this.shearScale = eU.makeScale(o[0], o[1], o[2]).multiply(c).premultiply(l), this.shearScaleInv = tU.copy(this.shearScale).invert(), this.matrixWorldRigid.multiplyMatrices(a, c), o.every((h)=>Math.abs(o[0] - h) < .01
        ) && (this.shearScale = void 0, this.shearScaleInv = void 0);
    }
    activateSVDCompensation() {
        this.shearScale !== void 0 && (this.matrixAutoUpdate = !1, this.matrix.copy(this.matrixWorldRigid).copyPosition(this.matrixWorld), this.hiddenMatrixOld.copy(this.hiddenMatrix), this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
    }
    deactivateSVDCompensation() {
        this.shearScale !== void 0 && (this.shearScale = void 0, this.shearScaleInv = void 0, this.matrixAutoUpdate = !0, this.hiddenMatrix.copy(this.hiddenMatrixOld));
    }
    calcBoundingBox() {
        let t = this.originalGeometry;
        t.boundingSphere === null && (t.boundingSphere = new Lr);
        let r = t.attributes.position, n = t.boundingSphere.center;
        vi.setFromBufferAttribute(r), vi.getCenter(n), t.boundingSphere.radius = n.distanceTo(vi.max), isNaN(t.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), vi.getSize(fo);
        let s = {
            width: fo.x,
            height: fo.y,
            depth: fo.z
        };
        return this.geometry.userData.parameters = s, s;
    }
    updateBoundingBox(t) {
        let r = this.originalGeometry;
        vi.min.set(t[0], t[2], t[4]), vi.max.set(t[1], t[3], t[5]), this.shearScaleInv && (vi.min.applyMatrix4(this.shearScaleInv), vi.max.applyMatrix4(this.shearScaleInv)), r.boundingSphere === null && (r.boundingSphere = new Lr);
        let n = r.boundingSphere.center;
        vi.getCenter(n), r.boundingSphere.radius = n.distanceTo(vi.max), isNaN(r.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), vi.getSize(fo);
        let s = {
            width: fo.x,
            height: fo.y,
            depth: fo.z
        };
        return this.geometry.userData.parameters = s, s;
    }
    freeSubdivPointer() {
        this.subdivPointer && (Uv.free_bvh(this.subdivPointer), Uv.free_subdivision_surface(this.subdivPointer), this.subdivPointer = 0);
    }
    updateGeometry(t) {
        this.geometry.userData.scale || (this.geometry.userData.scale = Array(3)), this.geometry.userData.scale[0] = this.geometry.userData.parameters.width === 0 ? 1 : t.parameters.width / this.geometry.userData.parameters.width, this.geometry.userData.scale[1] = this.geometry.userData.parameters.height === 0 ? 1 : t.parameters.height / this.geometry.userData.parameters.height, this.geometry.userData.scale[2] = this.geometry.userData.parameters.depth === 0 ? 1 : t.parameters.depth / this.geometry.userData.parameters.depth, lA(this.originalGeometry.attributes, ...this.geometry.userData.scale), this.originalGeometry.attributes.position.needsUpdate = !0, this.originalGeometry.attributes.normal.needsUpdate = !0, this.subdividedGeometry && (lA(this.subdividedGeometry.attributes, ...this.subdividedGeometry.userData.scale), this.subdividedGeometry.attributes.position.needsUpdate = !0, this.subdividedGeometry.attributes.normal.needsUpdate = !0), this.geometry.userData.parameters = ie({}, t.parameters);
    }
};
function lA(i, e, t, r) {
    let n = i.position.array, s = i.normal.array, o = hA.makeScale(e, t, r).invert().elements, a, l, c;
    for(var h = 0, u = n.length; h < u; h += 3)n[h] *= e, n[h + 1] *= t, n[h + 2] *= r, a = s[h], l = s[h + 1], c = s[h + 2], s[h] = o[0] * a + o[4] * l + o[8] * c, s[h + 1] = o[1] * a + o[5] * l + o[9] * c, s[h + 2] = o[2] * a + o[6] * l + o[10] * c;
}
function uA(i, e) {
    e.flatShading !== void 0 && (i.flatShading = e.flatShading, i.needsUpdate = !0), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.side !== void 0 && (e.side === 0 ? i.side = ii : e.side === 1 ? i.side = Pr : i.side = or);
}
function rU(i, e) {
    if (Array.isArray(i.material)) for (let t of i.material)uA(t, e);
    else {
        let t = i.material;
        uA(t, e);
    }
    i.objectType === "SubdivObject" && e.flatShading !== void 0 && (i.material.flatShading = !1, i.smoothShading = !e.flatShading, i.updateMesh());
}
function fA(i, e, t) {
    let r;
    if (e.geometry.type === "SubdivGeometry") r = po.createFromState(i, e, t);
    else {
        let n = e.geometry.type === "BooleanGeometry" ? new Le : Fp(e.geometry, t), s = "materials" in e ? B1(e.materials, t) : uu(e.material, t);
        op.is2DParametricMesh(n.userData.type) ? r = new ic(n, s) : (n == null ? void 0 : n.userData.type) === "VectorGeometry" ? r = new ho(n, s) : e.geometry.type === "NonParametricGeometry" ? r = new oc(n, s) : e.geometry.type === "BooleanGeometry" ? (r = new zp(void 0, s), r.booleanOp = e.geometry.operation) : r = new sc(n, s), r.uuid = i, r.fromState(e);
    }
    return rU(r, e), r;
}
function dA(i, e, t) {
    return e.type === "Mesh" ? fA(i, e, t) : e.type === "TextFrame" ? ea.createFromState(i, e, t) : e.type === "Empty" ? gs.createFromState(i, e) : e.type === "PointLight" ? rc.createFromState(i, e, t) : e.type === "SpotLight" ? nc.createFromState(i, e, t) : e.type === "DirectionalLight" ? tc.createFromState(i, e, t) : eo.is(e.type) ? Bn.createFromState(i, e) : (console.error(e), new gs);
}
function nU(i, e) {
    e.uniforms[`f${e.id}_transmissionSamplerMap`].value = i.texture, e.uniforms[`f${e.id}_transmissionDepthMap`].value = i.depthTexture;
}
function pA(i, e, t) {
    if (!t.userData.layers) return !1;
    let r = !1, n = t.userData.layers.getLayersOfType("transmission");
    return n.length > 0 ? (e.layers.set(3), r = !0, i !== void 0 && n.forEach((s)=>nU(i, s)
    )) : e.layers.set(0), r;
}
function mA(i, e) {
    let t = !1;
    return e.traverseEntity((r)=>{
        if (r instanceof kt) {
            if (Array.isArray(r.material)) for(let n = 0; n < r.material.length; n++)pA(i, r, r.material[n]) && (t = !0);
            else pA(i, r, r.material) && (t = !0);
        }
    }), t;
}
function gA(i, e) {
    "material" in i && iU(i.material, e), "geometry" in i && i.geometry.dispose();
}
function iU(i, e) {
    ZS(i).forEach((t)=>{
        e.isSharedMaterial(t) || t.dispose();
    });
}
var yA = new M, zv = class extends Op(on) {
    constructor(t, r){
        super();
        this.objectType = "Scene";
        this.alpha = 1;
        this.backupFog = new Do(16777215, .1, 2e3);
        this.fogUseBGColor = !1;
        this.wireframeState = !1;
        this.needsTransmissionDirty = !0;
        this._needsTransmission = !1;
        this._color = new be(1, 0, 0);
        this.bgColor = new be(1, 1, 1);
        this.entityByUuid = {};
        this.ambientLight = new Hs(13882323, 8553090, .75), this.ambientLight.name = "Default Ambient Light", this.personalCamera = this.createPersonalCamera(), this.activeCamera = this.personalCamera, this.sharedAssetManager = r, this.init(t, r);
    }
    needsTransmission(t) {
        return this.needsTransmissionDirty && (this._needsTransmission = mA(t, this), t !== void 0 && (this.needsTransmissionDirty = !1)), this._needsTransmission;
    }
    find(t) {
        if (t === "" || t === void 0) return;
        let r = this.entityByUuid[t];
        return r === void 0 ? this.getObjectByProperty("uuid", t) : r;
    }
    get color() {
        return this._color;
    }
    set color(t) {
        this.fogUseBGColor === !0 && this.backupFog.color.copy(t), this._color.copy(t);
    }
    get enableFog() {
        return this.fog !== null;
    }
    set enableFog(t) {
        this.fog = t === !0 ? this.backupFog : null;
    }
    init(t, r) {
        if (this.createChildrenObjects(t.objects, this, r), this.personalCamera.removeFromParent(), this.add(this.personalCamera), this.ambientLight.removeFromParent(), this.add(this.ambientLight), this.setBackgroundColor(pr(t.backgroundColor, r)), this.updateFog(t.fog, r), this.updateAmbientLight(t.environment.ambientLight, r), this.activeCamera = this.personalCamera, t.publish.playCamera !== null) {
            let n = this.find(t.publish.playCamera);
            n instanceof Bn && this.switchActiveCamera(n);
        }
        this.traverse((n)=>{
            Lt(n) && n.recomputeBoolean();
        });
    }
    clearScene(t) {
        this.traverseEntity((r)=>{
            gA(r, t);
        });
        for (let r17 of this.children)Xn(r17) && r17.removeFromParent();
    }
    resetAfterClear(t, r) {
        this.init(t, r);
    }
    createPersonalCamera() {
        let t = Bn.createFromState(zv.PERSONAL_CAMERA_ID, xe(ie({}, lp.defaultData), {
            name: "Personal Camera"
        }));
        return t.enableHelper = !1, t.objectHelper.visible = !1, delete t.isEntity, this.registerObjectCreatedInLegacy(t), t;
    }
    raycast(t) {
        let r = [], n = (s)=>{
            for (let o of s.children)Xn(o) && !o.raycastLock && o.visible && ((er(o) || ms(o) && o.enableHelper && o.objectHelper.parent) && t.intersectObject(o, !1, r), n(o));
        };
        return n(this), r;
    }
    traverseEntity(t) {
        for (let r of this.children)Xn(r) && r.traverseEntity(t);
    }
    updateFog(t, r) {
        this.enableFog = t.enabled, this.fogUseBGColor = t.useBackgroundColor, t.useBackgroundColor ? this.backupFog.color.set(this.bgColor) : this.backupFog.color = pr(t.color, r), this.backupFog.near = t.near, this.backupFog.far = t.far;
    }
    toJSON(t) {
        return {};
    }
    fromJSON(t) {
        return this;
    }
    dispose() {
        this.clearScene(this.sharedAssetManager), this.sharedAssetManager.dispose();
    }
    updateAmbientLight(t, r) {
        F1(this.ambientLight, t, r), t.groundColor !== void 0 && (this.ambientLight.groundColor = pr(t.groundColor, r)), t.enabled !== void 0 && (this.ambientLight.visible = t.enabled);
    }
    switchActiveCamera(t) {
        this.activeCamera !== this.personalCamera && (this.activeCamera.enableHelper = !0), this.activeCamera = t, t.enableHelper = !1;
    }
    setBackgroundColor(t) {
        this.bgColor = t, this.alpha = t.a;
    }
    createChildrenObjects(t, r, n) {
        for (let s of t)this.createChildObject(s.id, s.data, s.children, r, n);
    }
    registerObjectCreatedInLegacy(t) {
        this.entityByUuid[t.uuid] = t;
    }
    unregisterObject(t) {
        delete this.entityByUuid[t.uuid];
        for (let r of t.children)this.unregisterObject(r);
    }
    createChildObject(t, r, n, s, o) {
        let a = dA(t, r, o);
        return a && (this.entityByUuid[t] = a, s.add(a), Lt(s) && er(a) && (a.prevBooleanObjectParent = s), this.createChildrenObjects(n, a, o)), a;
    }
    getCenter(t) {
        let r = [];
        for(let s = 0, o = t.length; s < o; ++s){
            let { id: a , recursive: l  } = t[s], c = this.find(a), h = l ? c.recursiveBBox : c.singleBBox;
            r.push(...h.vertices);
        }
        let n = new Kt;
        return n.setFromPoints(r), n.getCenter(yA), yA;
    }
    copyMatrixWorld(t, r) {
        if (t === null) {
            r.identity();
            return;
        }
        let n = this.find(t);
        n ? r.copy(n.matrixWorld) : r.identity();
    }
    copyParentMatrixWorld(t, r) {
        var s;
        if (t === null) {
            r.identity();
            return;
        }
        let n = (s = this.find(t)) == null ? void 0 : s.parent;
        n ? r.copy(n.matrixWorld) : r.identity();
    }
    traverseMaterial(t) {
        this.traverseEntity((r)=>{
            if (r instanceof kt) {
                if (Array.isArray(r.material)) for(let n = 0; n < r.material.length; n++)t(r.material[n]);
                else t(r.material);
            }
        });
    }
    updateCanvasSize(t, r) {
        this.activeCamera.setViewplaneSize(t, r);
        let n, s;
        t >= r ? (n = r / t, s = 1) : (n = 1, s = t / r), this.traverseMaterial((o)=>{
            o.layersList.getLayersOfType("transmission").forEach((l)=>{
                l.uniforms[`f${l.id}_aspectRatio`].value.x = n, l.uniforms[`f${l.id}_aspectRatio`].value.y = s;
            });
        });
    }
}, yu = zv;
yu.PERSONAL_CAMERA_ID = "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera";
var AA = {
    RED: 0,
    GREEN: 1,
    BLUE: 2,
    ALPHA: 3
};
var vu = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var sU = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`, Xp = class extends Mt {
    constructor(i = !1, e = !1){
        super({
            name: "BokehMaterial",
            defines: {
                PASS: i ? "2" : "1"
            },
            uniforms: {
                kernel64: new _e(null),
                kernel16: new _e(null),
                inputBuffer: new _e(null),
                cocBuffer: new _e(null),
                texelSize: new _e(new B),
                scale: new _e(1)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: sU,
            vertexShader: vu
        }), this.toneMapped = !1, e && (this.defines.FOREGROUND = "1"), this.generateKernel();
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    set cocBuffer(i) {
        this.uniforms.cocBuffer.value = i;
    }
    setCoCBuffer(i) {
        this.uniforms.cocBuffer.value = i;
    }
    get scale() {
        return this.uniforms.scale.value;
    }
    set scale(i) {
        this.uniforms.scale.value = i;
    }
    getScale(i) {
        return this.uniforms.scale.value = i;
    }
    setScale(i) {
        this.uniforms.scale.value = i;
    }
    generateKernel() {
        let i = 2.39996323, e = new Float32Array(128), t = new Float32Array(32), r = 0, n = 0;
        for(let a = 0; a < 80; ++a){
            let l = a * i, c = Math.sqrt(a) / Math.sqrt(80), h = c * Math.cos(l), u = c * Math.sin(l);
            a % 5 === 0 ? (t[n++] = h, t[n++] = u) : (e[r++] = h, e[r++] = u);
        }
        let s = [], o = [];
        for(let a11 = 0; a11 < 128;)s.push(new Je(e[a11++], e[a11++], e[a11++], e[a11++]));
        for(let a12 = 0; a12 < 32;)o.push(new Je(t[a12++], t[a12++], t[a12++], t[a12++]));
        this.uniforms.kernel64.value = s, this.uniforms.kernel16.value = o;
    }
    setTexelSize(i, e) {
        this.uniforms.texelSize.value.set(i, e);
    }
    setSize(i, e) {
        this.uniforms.texelSize.value.set(1 / i, 1 / e);
    }
};
function vA(i, e, t) {
    return i * (e - t) - e;
}
function Wv(i, e, t) {
    return Math.min(Math.max((i + e) / (e - t), 0), 1);
}
var oU = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`, aU = class extends Mt {
    constructor(i){
        super({
            name: "CircleOfConfusionMaterial",
            defines: {
                DEPTH_PACKING: "0"
            },
            uniforms: {
                depthBuffer: new _e(null),
                focusDistance: new _e(0),
                focusRange: new _e(0),
                cameraNear: new _e(.3),
                cameraFar: new _e(1e3)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: oU,
            vertexShader: vu
        }), this.toneMapped = !1, this.uniforms.focalLength = this.uniforms.focusRange, this.adoptCameraSettings(i);
    }
    get near() {
        return this.uniforms.cameraNear.value;
    }
    get far() {
        return this.uniforms.cameraFar.value;
    }
    set depthBuffer(i) {
        this.uniforms.depthBuffer.value = i;
    }
    set depthPacking(i) {
        this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0;
    }
    setDepthBuffer(i, e = Ir) {
        this.depthBuffer = i, this.depthPacking = e;
    }
    get focusDistance() {
        return this.uniforms.focusDistance.value;
    }
    set focusDistance(i) {
        this.uniforms.focusDistance.value = i;
    }
    get worldFocusDistance() {
        return -vA(this.focusDistance, this.near, this.far);
    }
    set worldFocusDistance(i) {
        this.focusDistance = Wv(-i, this.near, this.far);
    }
    getFocusDistance(i) {
        this.uniforms.focusDistance.value = i;
    }
    setFocusDistance(i) {
        this.uniforms.focusDistance.value = i;
    }
    get focalLength() {
        return this.focusRange;
    }
    set focalLength(i) {
        this.focusRange = i;
    }
    get focusRange() {
        return this.uniforms.focusRange.value;
    }
    set focusRange(i) {
        this.uniforms.focusRange.value = i;
    }
    get worldFocusRange() {
        return -vA(this.focusRange, this.near, this.far);
    }
    set worldFocusRange(i) {
        this.focusRange = Wv(-i, this.near, this.far);
    }
    getFocalLength(i) {
        return this.focusRange;
    }
    setFocalLength(i) {
        this.focusRange = i;
    }
    adoptCameraSettings(i) {
        i && (this.uniforms.cameraNear.value = i.near, this.uniforms.cameraFar.value = i.far, i instanceof sr ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
    }
}, lU = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`, cU = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", xA = class extends Mt {
    constructor(i = new B){
        super({
            name: "KawaseBlurMaterial",
            uniforms: {
                inputBuffer: new _e(null),
                texelSize: new _e(new B),
                halfTexelSize: new _e(new B),
                kernel: new _e(0),
                scale: new _e(1)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: lU,
            vertexShader: cU
        }), this.toneMapped = !1, this.setTexelSize(i.x, i.y);
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.inputBuffer = i;
    }
    get scale() {
        return this.uniforms.scale.value;
    }
    set scale(i) {
        this.uniforms.scale.value = i;
    }
    getScale() {
        return this.uniforms.scale.value;
    }
    setScale(i) {
        this.uniforms.scale.value = i;
    }
    getKernel() {
        return null;
    }
    get kernel() {
        return this.uniforms.kernel.value;
    }
    set kernel(i) {
        this.uniforms.kernel.value = i;
    }
    setKernel(i) {
        this.kernel = i;
    }
    setTexelSize(i, e) {
        this.uniforms.texelSize.value.set(i, e), this.uniforms.halfTexelSize.value.set(i, e).multiplyScalar(.5);
    }
    setSize(i, e) {
        let t = this.uniforms;
        t.texelSize.value.set(1 / i, 1 / e), t.halfTexelSize.value.copy(t.texelSize.value).multiplyScalar(.5);
    }
}, hU = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`, uU = class extends Mt {
    constructor(){
        super({
            name: "CopyMaterial",
            uniforms: {
                inputBuffer: new _e(null),
                opacity: new _e(1)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: hU,
            vertexShader: vu
        }), this.toneMapped = !1;
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    getOpacity(i) {
        return this.uniforms.opacity.value;
    }
    setOpacity(i) {
        this.uniforms.opacity.value = i;
    }
};
var fU = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`, dU = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`, Jp = {
    DEPTH: 0,
    LUMA: 1,
    COLOR: 2
}, qv = {
    DISABLED: 0,
    DEPTH: 1,
    CUSTOM: 2
}, pU = class extends Mt {
    constructor(i = new B, e = Jp.COLOR){
        super({
            name: "EdgeDetectionMaterial",
            defines: {
                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                EDGE_THRESHOLD: "0.1",
                DEPTH_THRESHOLD: "0.01",
                PREDICATION_MODE: "0",
                PREDICATION_THRESHOLD: "0.01",
                PREDICATION_SCALE: "2.0",
                PREDICATION_STRENGTH: "1.0",
                DEPTH_PACKING: "0"
            },
            uniforms: {
                inputBuffer: new _e(null),
                depthBuffer: new _e(null),
                predicationBuffer: new _e(null),
                texelSize: new _e(i)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: fU,
            vertexShader: dU
        }), this.toneMapped = !1, this.edgeDetectionMode = e;
    }
    set depthBuffer(i) {
        this.uniforms.depthBuffer.value = i;
    }
    set depthPacking(i) {
        this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0;
    }
    setDepthBuffer(i, e = Ir) {
        this.depthBuffer = i, this.depthPacking = e;
    }
    get edgeDetectionMode() {
        return Number(this.defines.EDGE_DETECTION_MODE);
    }
    set edgeDetectionMode(i) {
        this.defines.EDGE_DETECTION_MODE = i.toFixed(0), this.needsUpdate = !0;
    }
    getEdgeDetectionMode() {
        return this.edgeDetectionMode;
    }
    setEdgeDetectionMode(i) {
        this.edgeDetectionMode = i;
    }
    get localContrastAdaptationFactor() {
        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
    }
    set localContrastAdaptationFactor(i) {
        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = i.toFixed("6"), this.needsUpdate = !0;
    }
    getLocalContrastAdaptationFactor() {
        return this.localContrastAdaptationFactor;
    }
    setLocalContrastAdaptationFactor(i) {
        this.localContrastAdaptationFactor = i;
    }
    get edgeDetectionThreshold() {
        return Number(this.defines.EDGE_THRESHOLD);
    }
    set edgeDetectionThreshold(i) {
        this.defines.EDGE_THRESHOLD = i.toFixed("6"), this.defines.DEPTH_THRESHOLD = (i * .1).toFixed("6"), this.needsUpdate = !0;
    }
    getEdgeDetectionThreshold() {
        return this.edgeDetectionThreshold;
    }
    setEdgeDetectionThreshold(i) {
        this.edgeDetectionThreshold = i;
    }
    get predicationMode() {
        return Number(this.defines.PREDICATION_MODE);
    }
    set predicationMode(i) {
        this.defines.PREDICATION_MODE = i.toFixed(0), this.needsUpdate = !0;
    }
    getPredicationMode() {
        return this.predicationMode;
    }
    setPredicationMode(i) {
        this.predicationMode = i;
    }
    set predicationBuffer(i) {
        this.uniforms.predicationBuffer.value = i;
    }
    setPredicationBuffer(i) {
        this.uniforms.predicationBuffer.value = i;
    }
    get predicationThreshold() {
        return Number(this.defines.PREDICATION_THRESHOLD);
    }
    set predicationThreshold(i) {
        this.defines.PREDICATION_THRESHOLD = i.toFixed("6"), this.needsUpdate = !0;
    }
    getPredicationThreshold() {
        return this.predicationThreshold;
    }
    setPredicationThreshold(i) {
        this.predicationThreshold = i;
    }
    get predicationScale() {
        return Number(this.defines.PREDICATION_SCALE);
    }
    set predicationScale(i) {
        this.defines.PREDICATION_SCALE = i.toFixed("6"), this.needsUpdate = !0;
    }
    getPredicationScale() {
        return this.predicationScale;
    }
    setPredicationScale(i) {
        this.predicationScale = i;
    }
    get predicationStrength() {
        return Number(this.defines.PREDICATION_STRENGTH);
    }
    set predicationStrength(i) {
        this.defines.PREDICATION_STRENGTH = i.toFixed("6"), this.needsUpdate = !0;
    }
    getPredicationStrength() {
        return this.predicationStrength;
    }
    setPredicationStrength(i) {
        this.predicationStrength = i;
    }
    setSize(i, e) {
        this.uniforms.texelSize.value.set(1 / i, 1 / e);
    }
}, mU = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`, gU = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", xi = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
}, jv = class extends Mt {
    constructor(i, e, t, r, n = !1){
        super({
            name: "EffectMaterial",
            defines: {
                THREE_REVISION: Uo.replace(/\D+/g, ""),
                DEPTH_PACKING: "0",
                ENCODE_OUTPUT: "1"
            },
            uniforms: {
                inputBuffer: new _e(null),
                depthBuffer: new _e(null),
                resolution: new _e(new B),
                texelSize: new _e(new B),
                cameraNear: new _e(.3),
                cameraFar: new _e(1e3),
                aspect: new _e(1),
                time: new _e(0)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            dithering: n
        }), this.toneMapped = !1, i && this.setShaderParts(i), e && this.setDefines(e), t && this.setUniforms(t), this.adoptCameraSettings(r);
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    get depthBuffer() {
        return this.uniforms.depthBuffer.value;
    }
    set depthBuffer(i) {
        this.uniforms.depthBuffer.value = i;
    }
    get depthPacking() {
        return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(i) {
        this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0;
    }
    setDepthBuffer(i, e = Ir) {
        this.depthBuffer = i, this.depthPacking = e;
    }
    setShaderParts(i) {
        return this.fragmentShader = mU.replace(xi.FRAGMENT_HEAD, i.get(xi.FRAGMENT_HEAD)).replace(xi.FRAGMENT_MAIN_UV, i.get(xi.FRAGMENT_MAIN_UV)).replace(xi.FRAGMENT_MAIN_IMAGE, i.get(xi.FRAGMENT_MAIN_IMAGE)), this.vertexShader = gU.replace(xi.VERTEX_HEAD, i.get(xi.VERTEX_HEAD)).replace(xi.VERTEX_MAIN_SUPPORT, i.get(xi.VERTEX_MAIN_SUPPORT)), this.needsUpdate = !0, this;
    }
    setDefines(i) {
        for (let e of i.entries())this.defines[e[0]] = e[1];
        return this.needsUpdate = !0, this;
    }
    setUniforms(i) {
        for (let e of i.entries())this.uniforms[e[0]] = e[1];
        return this;
    }
    setExtensions(i) {
        this.extensions = {};
        for (let e of i)this.extensions[e] = !0;
        return this;
    }
    get encodeOutput() {
        return this.defines.ENCODE_OUTPUT !== void 0;
    }
    set encodeOutput(i) {
        this.encodeOutput !== i && (i ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0);
    }
    isOutputEncodingEnabled(i) {
        return this.encodeOutput;
    }
    setOutputEncodingEnabled(i) {
        this.encodeOutput = i;
    }
    get time() {
        return this.uniforms.time.value;
    }
    set time(i) {
        this.uniforms.time.value = i;
    }
    setDeltaTime(i) {
        this.uniforms.time.value += i;
    }
    adoptCameraSettings(i) {
        i && (this.uniforms.cameraNear.value = i.near, this.uniforms.cameraFar.value = i.far, i instanceof sr ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
    }
    setSize(i, e) {
        let t = this.uniforms;
        t.resolution.value.set(i, e), t.texelSize.value.set(1 / i, 1 / e), t.aspect.value = i / e;
    }
    static get Section() {
        return xi;
    }
};
var yU = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=linearToRelativeLuminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`, vU = class extends Mt {
    constructor(i = !1, e = null){
        super({
            name: "LuminanceMaterial",
            uniforms: {
                inputBuffer: new _e(null),
                threshold: new _e(0),
                smoothing: new _e(1),
                range: new _e(null)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: yU,
            vertexShader: vu
        }), this.toneMapped = !1, this.colorOutput = i, this.luminanceRange = e;
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    get threshold() {
        return this.uniforms.threshold.value;
    }
    set threshold(i) {
        this.smoothing > 0 || i > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = i;
    }
    getThreshold() {
        return this.threshold;
    }
    setThreshold(i) {
        this.threshold = i;
    }
    get smoothing() {
        return this.uniforms.smoothing.value;
    }
    set smoothing(i) {
        this.threshold > 0 || i > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = i;
    }
    getSmoothingFactor() {
        return this.smoothing;
    }
    setSmoothingFactor(i) {
        this.smoothing = i;
    }
    get useThreshold() {
        return this.threshold > 0 || this.smoothing > 0;
    }
    set useThreshold(i) {}
    get colorOutput() {
        return this.defines.COLOR !== void 0;
    }
    set colorOutput(i) {
        i ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0;
    }
    isColorOutputEnabled(i) {
        return this.colorOutput;
    }
    setColorOutputEnabled(i) {
        this.colorOutput = i;
    }
    get useRange() {
        return this.luminanceRange !== null;
    }
    set useRange(i) {
        this.luminanceRange = null;
    }
    get luminanceRange() {
        return this.uniforms.range.value;
    }
    set luminanceRange(i) {
        i !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = i, this.needsUpdate = !0;
    }
    getLuminanceRange() {
        return this.luminanceRange;
    }
    setLuminanceRange(i) {
        this.luminanceRange = i;
    }
}, xU = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`, TA = {
    DISCARD: 0,
    MULTIPLY: 1,
    MULTIPLY_RGB_SET_ALPHA: 2
}, bU = class extends Mt {
    constructor(i = null){
        super({
            name: "MaskMaterial",
            uniforms: {
                maskTexture: new _e(i),
                inputBuffer: new _e(null),
                strength: new _e(1)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: xU,
            vertexShader: vu
        }), this.toneMapped = !1, this.setColorChannel(AA.RED), this.setMaskFunction(TA.DISCARD);
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    set maskTexture(i) {
        this.uniforms.maskTexture.value = i, delete this.defines.MASK_PRECISION_HIGH, i.type !== qt && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0;
    }
    setMaskTexture(i) {
        this.maskTexture = i;
    }
    set colorChannel(i) {
        this.defines.COLOR_CHANNEL = i.toFixed(0), this.needsUpdate = !0;
    }
    setColorChannel(i) {
        this.colorChannel = i;
    }
    set maskFunction(i) {
        this.defines.MASK_FUNCTION = i.toFixed(0), this.needsUpdate = !0;
    }
    setMaskFunction(i) {
        this.maskFunction = i;
    }
    get inverted() {
        return this.defines.INVERTED !== void 0;
    }
    set inverted(i) {
        this.inverted && !i ? delete this.defines.INVERTED : i && (this.defines.INVERTED = "1"), this.needsUpdate = !0;
    }
    isInverted() {
        return this.inverted;
    }
    setInverted(i) {
        this.inverted = i;
    }
    get strength() {
        return this.uniforms.strength.value;
    }
    set strength(i) {
        this.uniforms.strength.value = i;
    }
    getStrength() {
        return this.strength;
    }
    setStrength(i) {
        this.strength = i;
    }
};
var wU = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`, SU = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}", MU = class extends Mt {
    constructor(i = new B, e = new B){
        super({
            name: "SMAAWeightsMaterial",
            defines: {
                MAX_SEARCH_STEPS_INT: "16",
                MAX_SEARCH_STEPS_FLOAT: "16.0",
                MAX_SEARCH_STEPS_DIAG_INT: "8",
                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                CORNER_ROUNDING: "25",
                CORNER_ROUNDING_NORM: "0.25",
                AREATEX_MAX_DISTANCE: "16.0",
                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
            },
            uniforms: {
                inputBuffer: new _e(null),
                searchTexture: new _e(null),
                areaTexture: new _e(null),
                resolution: new _e(e),
                texelSize: new _e(i)
            },
            blending: Ht,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: wU,
            vertexShader: SU
        }), this.toneMapped = !1;
    }
    set inputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    setInputBuffer(i) {
        this.uniforms.inputBuffer.value = i;
    }
    get searchTexture() {
        return this.uniforms.searchTexture.value;
    }
    set searchTexture(i) {
        this.uniforms.searchTexture.value = i;
    }
    get areaTexture() {
        return this.uniforms.areaTexture.value;
    }
    set areaTexture(i) {
        this.uniforms.areaTexture.value = i;
    }
    setLookupTextures(i, e) {
        this.searchTexture = i, this.areaTexture = e;
    }
    get orthogonalSearchSteps() {
        return Number(this.defines.MAX_SEARCH_STEPS_INT);
    }
    set orthogonalSearchSteps(i) {
        let e = Math.min(Math.max(i, 0), 112);
        this.defines.MAX_SEARCH_STEPS_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = e.toFixed("1"), this.needsUpdate = !0;
    }
    setOrthogonalSearchSteps(i) {
        this.orthogonalSearchSteps = i;
    }
    get diagonalSearchSteps() {
        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
    }
    set diagonalSearchSteps(i) {
        let e = Math.min(Math.max(i, 0), 20);
        this.defines.MAX_SEARCH_STEPS_DIAG_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = e.toFixed("1"), this.needsUpdate = !0;
    }
    setDiagonalSearchSteps(i) {
        this.diagonalSearchSteps = i;
    }
    get diagonalDetection() {
        return this.defines.DISABLE_DIAG_DETECTION === void 0;
    }
    set diagonalDetection(i) {
        i ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0;
    }
    isDiagonalDetectionEnabled() {
        return this.diagonalDetection;
    }
    setDiagonalDetectionEnabled(i) {
        this.diagonalDetection = i;
    }
    get cornerRounding() {
        return Number(this.defines.CORNER_ROUNDING);
    }
    set cornerRounding(i) {
        let e = Math.min(Math.max(i, 0), 100);
        this.defines.CORNER_ROUNDING = e.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (e / 100).toFixed("4"), this.needsUpdate = !0;
    }
    setCornerRounding(i) {
        this.cornerRounding = i;
    }
    get cornerDetection() {
        return this.defines.DISABLE_CORNER_DETECTION === void 0;
    }
    set cornerDetection(i) {
        i ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0;
    }
    isCornerRoundingEnabled() {
        return this.cornerDetection;
    }
    setCornerRoundingEnabled(i) {
        this.cornerDetection = i;
    }
    setSize(i, e) {
        let t = this.uniforms;
        t.texelSize.value.set(1 / i, 1 / e), t.resolution.value.set(i, e);
    }
};
var AU = new Gn, mo = null;
function TU() {
    if (mo === null) {
        let i = new Float32Array([
            -1,
            -1,
            0,
            3,
            -1,
            0,
            -1,
            3,
            0
        ]), e = new Float32Array([
            0,
            0,
            2,
            0,
            0,
            2
        ]);
        mo = new Le, mo.setAttribute !== void 0 ? (mo.setAttribute("position", new Ve(i, 3)), mo.setAttribute("uv", new Ve(e, 2))) : (mo.addAttribute("position", new Ve(i, 3)), mo.addAttribute("uv", new Ve(e, 2)));
    }
    return mo;
}
var ys = class {
    constructor(i = "Pass", e = new on, t = AU){
        this.name = i, this.renderer = null, this.scene = e, this.camera = t, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0;
    }
    get renderToScreen() {
        return !this.rtt;
    }
    set renderToScreen(i) {
        if (this.rtt === i) {
            let e = this.getFullscreenMaterial();
            e !== null && (e.needsUpdate = !0), this.rtt = !i;
        }
    }
    setRenderer(i) {
        this.renderer = i;
    }
    isEnabled() {
        return this.enabled;
    }
    setEnabled(i) {
        this.enabled = i;
    }
    get fullscreenMaterial() {
        return this.screen !== null ? this.screen.material : null;
    }
    set fullscreenMaterial(i) {
        let e = this.screen;
        e !== null ? e.material = i : (e = new Vt(TU(), i), e.frustumCulled = !1, this.scene === null && (this.scene = new on), this.scene.add(e), this.screen = e);
    }
    getFullscreenMaterial() {
        return this.fullscreenMaterial;
    }
    setFullscreenMaterial(i) {
        this.fullscreenMaterial = i;
    }
    getDepthTexture() {
        return null;
    }
    setDepthTexture(i, e = Ir) {}
    render(i, e, t, r, n) {
        throw new Error("Render method not implemented!");
    }
    setSize(i, e) {}
    initialize(i, e, t) {}
    dispose() {
        for (let i of Object.keys(this)){
            let e = this[i];
            if (e !== null && typeof e.dispose == "function") {
                if (e instanceof on || e === this.renderer) continue;
                this[i].dispose();
            }
        }
    }
}, Yv = class extends ys {
    constructor(i, e = !0){
        super("CopyPass"), this.fullscreenMaterial = new uU, this.needsSwap = !1, this.renderTarget = i, i === void 0 && (this.renderTarget = new mt(1, 1, {
            minFilter: ct,
            magFilter: ct,
            stencilBuffer: !1,
            depthBuffer: !1
        }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e;
    }
    get resize() {
        return this.autoResize;
    }
    set resize(i) {
        this.autoResize = i;
    }
    get texture() {
        return this.renderTarget.texture;
    }
    getTexture() {
        return this.renderTarget.texture;
    }
    setAutoResizeEnabled(i) {
        this.autoResize = i;
    }
    render(i, e, t, r, n) {
        this.fullscreenMaterial.inputBuffer = e.texture, i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera);
    }
    setSize(i, e) {
        this.autoResize && this.renderTarget.setSize(i, e);
    }
    initialize(i, e, t) {
        t !== void 0 && (this.renderTarget.texture.type = t, t !== qt ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : i.outputEncoding === je && (this.renderTarget.texture.encoding = je));
    }
};
var EU = class extends ys {
    constructor(){
        super("ClearMaskPass", null, null), this.needsSwap = !1;
    }
    render(i, e, t, r, n) {
        let s = i.state.buffers.stencil;
        s.setLocked(!1), s.setTest(!1);
    }
}, Gv = new be, Xv = class extends ys {
    constructor(i = !0, e = !0, t = !1){
        super("ClearPass", null, null), this.needsSwap = !1, this.color = i, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1;
    }
    setClearFlags(i, e, t) {
        this.color = i, this.depth = e, this.stencil = t;
    }
    getOverrideClearColor() {
        return this.overrideClearColor;
    }
    setOverrideClearColor(i) {
        this.overrideClearColor = i;
    }
    getOverrideClearAlpha() {
        return this.overrideClearAlpha;
    }
    setOverrideClearAlpha(i) {
        this.overrideClearAlpha = i;
    }
    render(i, e, t, r, n) {
        let s = this.overrideClearColor, o = this.overrideClearAlpha, a = i.getClearAlpha(), l = s !== null, c = o >= 0;
        l ? (Gv.copy(i.getClearColor(Gv)), i.setClearColor(s, c ? o : a)) : c && i.setClearAlpha(o), i.setRenderTarget(this.renderToScreen ? null : e), i.clear(this.color, this.depth, this.stencil), l ? i.setClearColor(Gv, a) : c && i.setClearAlpha(a);
    }
}, go = -1, bi = class extends Yt {
    constructor(i, e = go, t = go, r = 1){
        super(), this.resizable = i, this.base = new B(1, 1), this.preferred = new B(e, t), this.target = this.preferred, this.s = r;
    }
    get width() {
        let { base: i , preferred: e , scale: t  } = this, r;
        return e.width !== go ? r = e.width : e.height !== go ? r = Math.round(e.height * (i.width / Math.max(i.height, 1))) : r = Math.round(i.width * t), r;
    }
    set width(i) {
        this.preferredWidth = i;
    }
    get height() {
        let { base: i , preferred: e , scale: t  } = this, r;
        return e.height !== go ? r = e.height : e.width !== go ? r = Math.round(e.width / Math.max(i.width / Math.max(i.height, 1), 1)) : r = Math.round(i.height * t), r;
    }
    set height(i) {
        this.preferredHeight = i;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    get scale() {
        return this.s;
    }
    set scale(i) {
        this.s !== i && (this.s = i, this.preferred.setScalar(go), this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    getScale() {
        return this.scale;
    }
    setScale(i) {
        this.scale = i;
    }
    get baseWidth() {
        return this.base.width;
    }
    set baseWidth(i) {
        this.base.width !== i && (this.base.width = i, this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    getBaseWidth() {
        return this.base.width;
    }
    setBaseWidth(i) {
        this.base.width !== i && (this.base.width = i, this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    get baseHeight() {
        return this.base.height;
    }
    set baseHeight(i) {
        this.base.height !== i && (this.base.height = i, this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    getBaseHeight() {
        return this.baseHeight;
    }
    setBaseHeight(i) {
        this.baseHeight = i;
    }
    setBaseSize(i, e) {
        (this.base.width !== i || this.base.height !== e) && (this.base.set(i, e), this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    get preferredWidth() {
        return this.preferred.width;
    }
    set preferredWidth(i) {
        this.preferred.width !== i && (this.preferred.width = i, this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    getPreferredWidth() {
        return this.preferredWidth;
    }
    setPreferredWidth(i) {
        this.preferredWidth = i;
    }
    get preferredHeight() {
        return this.preferred.height;
    }
    set preferredHeight(i) {
        this.preferred.height !== i && (this.preferred.height = i, this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    getPreferredHeight() {
        return this.preferredHeight;
    }
    setPreferredHeight(i) {
        this.preferredHeight = i;
    }
    setPreferredSize(i, e) {
        (this.preferred.width !== i || this.preferred.height !== e) && (this.preferred.set(i, e), this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height));
    }
    copy(i) {
        this.base.set(i.getBaseWidth(), i.getBaseHeight()), this.preferred.set(i.getPreferredWidth(), i.getPreferredHeight()), this.dispatchEvent({
            type: "change"
        }), this.resizable.setSize(this.base.width, this.base.height);
    }
    static get AUTO_SIZE() {
        return go;
    }
}, kv = !1, bA = class {
    constructor(i = null){
        this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(i), this.meshCount = 0, this.replaceMaterial = (e)=>{
            if (e.isMesh) {
                let t;
                if (e.material.flatShading) switch(e.material.side){
                    case or:
                        t = this.materialsFlatShadedDoubleSide;
                        break;
                    case Pr:
                        t = this.materialsFlatShadedBackSide;
                        break;
                    default:
                        t = this.materialsFlatShaded;
                        break;
                }
                else switch(e.material.side){
                    case or:
                        t = this.materialsDoubleSide;
                        break;
                    case Pr:
                        t = this.materialsBackSide;
                        break;
                    default:
                        t = this.materials;
                        break;
                }
                this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount;
            }
        };
    }
    setMaterial(i) {
        if (this.disposeMaterials(), this.material = i, i !== null) {
            let e = this.materials = [
                i.clone(),
                i.clone(),
                i.clone()
            ];
            for (let t11 of e)t11.uniforms = Object.assign({}, i.uniforms), t11.side = ii;
            e[2].skinning = !0, this.materialsBackSide = e.map((t)=>{
                let r = t.clone();
                return r.uniforms = Object.assign({}, i.uniforms), r.side = Pr, r;
            }), this.materialsDoubleSide = e.map((t)=>{
                let r = t.clone();
                return r.uniforms = Object.assign({}, i.uniforms), r.side = or, r;
            }), this.materialsFlatShaded = e.map((t)=>{
                let r = t.clone();
                return r.uniforms = Object.assign({}, i.uniforms), r.flatShading = !0, r;
            }), this.materialsFlatShadedBackSide = e.map((t)=>{
                let r = t.clone();
                return r.uniforms = Object.assign({}, i.uniforms), r.flatShading = !0, r.side = Pr, r;
            }), this.materialsFlatShadedDoubleSide = e.map((t)=>{
                let r = t.clone();
                return r.uniforms = Object.assign({}, i.uniforms), r.flatShading = !0, r.side = or, r;
            });
        }
    }
    render(i, e, t) {
        let r = i.shadowMap.enabled;
        if (i.shadowMap.enabled = !1, kv) {
            let n = this.originalMaterials;
            this.meshCount = 0, e.traverse(this.replaceMaterial), i.render(e, t);
            for (let s of n)s[0].material = s[1];
            this.meshCount !== n.size && n.clear();
        } else {
            let n = e.overrideMaterial;
            e.overrideMaterial = this.material, i.render(e, t), e.overrideMaterial = n;
        }
        i.shadowMap.enabled = r;
    }
    disposeMaterials() {
        if (this.material !== null) {
            let i = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
            for (let e of i)e.dispose();
        }
    }
    dispose() {
        this.originalMaterials.clear(), this.disposeMaterials();
    }
    static get workaroundEnabled() {
        return kv;
    }
    static set workaroundEnabled(i) {
        kv = i;
    }
}, Qv = class extends ys {
    constructor(i, e, t = null){
        super("RenderPass", i, e), this.needsSwap = !1, this.clearPass = new Xv, this.overrideMaterialManager = t === null ? null : new bA(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null;
    }
    get renderToScreen() {
        return super.renderToScreen;
    }
    set renderToScreen(i) {
        super.renderToScreen = i, this.clearPass.renderToScreen = i;
    }
    get overrideMaterial() {
        let i = this.overrideMaterialManager;
        return i !== null ? i.material : null;
    }
    set overrideMaterial(i) {
        let e = this.overrideMaterialManager;
        i !== null ? e !== null ? e.setMaterial(i) : this.overrideMaterialManager = new bA(i) : e !== null && (e.dispose(), this.overrideMaterialManager = null);
    }
    getOverrideMaterial() {
        return this.overrideMaterial;
    }
    setOverrideMaterial(i) {
        this.overrideMaterial = i;
    }
    get clear() {
        return this.clearPass.enabled;
    }
    set clear(i) {
        this.clearPass.enabled = i;
    }
    getSelection() {
        return this.selection;
    }
    setSelection(i) {
        this.selection = i;
    }
    isBackgroundDisabled() {
        return this.ignoreBackground;
    }
    setBackgroundDisabled(i) {
        this.ignoreBackground = i;
    }
    isShadowMapDisabled() {
        return this.skipShadowMapUpdate;
    }
    setShadowMapDisabled(i) {
        this.skipShadowMapUpdate = i;
    }
    getClearPass() {
        return this.clearPass;
    }
    render(i, e, t, r, n) {
        let s = this.scene, o = this.camera, a = this.selection, l = o.layers.mask, c = s.background, h = i.shadowMap.autoUpdate, u = this.renderToScreen ? null : e;
        a !== null && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (i.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (s.background = null), this.clearPass.enabled && this.clearPass.render(i, e), i.setRenderTarget(u), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(i, s, o) : i.render(s, o), o.layers.mask = l, s.background = c, i.shadowMap.autoUpdate = h;
    }
};
var Zoe = new Float32Array([
    255 / 256 / 256 ** 3,
    255 / 256 / 65536,
    255 / 256 / 256,
    255 / 256
]);
var vt = {
    SKIP: 0,
    ADD: 1,
    ALPHA: 2,
    AVERAGE: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    EXCLUSION: 8,
    LIGHTEN: 9,
    MULTIPLY: 10,
    DIVIDE: 11,
    NEGATION: 12,
    NORMAL: 13,
    OVERLAY: 14,
    REFLECT: 15,
    SCREEN: 16,
    SOFT_LIGHT: 17,
    SUBTRACT: 18
}, _U = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}", CU = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}", DU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}", PU = "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", LU = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", IU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}", RU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}", BU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}", NU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}", OU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}", FU = "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", UU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}", zU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}", GU = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", kU = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", VU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}", HU = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", WU = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}", jU = new Map([
    [
        vt.SKIP,
        null
    ],
    [
        vt.ADD,
        _U
    ],
    [
        vt.ALPHA,
        CU
    ],
    [
        vt.AVERAGE,
        DU
    ],
    [
        vt.COLOR_BURN,
        PU
    ],
    [
        vt.COLOR_DODGE,
        LU
    ],
    [
        vt.DARKEN,
        IU
    ],
    [
        vt.DIFFERENCE,
        RU
    ],
    [
        vt.EXCLUSION,
        BU
    ],
    [
        vt.LIGHTEN,
        NU
    ],
    [
        vt.MULTIPLY,
        OU
    ],
    [
        vt.DIVIDE,
        FU
    ],
    [
        vt.NEGATION,
        UU
    ],
    [
        vt.NORMAL,
        zU
    ],
    [
        vt.OVERLAY,
        GU
    ],
    [
        vt.REFLECT,
        kU
    ],
    [
        vt.SCREEN,
        VU
    ],
    [
        vt.SOFT_LIGHT,
        HU
    ],
    [
        vt.SUBTRACT,
        WU
    ]
]), qU = class extends Yt {
    constructor(i, e = 1){
        super(), this.f = i, this.opacity = new _e(e);
    }
    getOpacity() {
        return this.opacity.value;
    }
    setOpacity(i) {
        this.opacity.value = i;
    }
    get blendFunction() {
        return this.f;
    }
    set blendFunction(i) {
        this.f = i, this.dispatchEvent({
            type: "change"
        });
    }
    getBlendFunction() {
        return this.blendFunction;
    }
    setBlendFunction(i) {
        this.blendFunction = i;
    }
    getShaderCode() {
        return jU.get(this.blendFunction);
    }
}, Hi = {
    NONE: 0,
    DEPTH: 1,
    CONVOLUTION: 2
};
var Wi = class extends Yt {
    constructor(i, e, { attributes: t = Hi.NONE , blendFunction: r = vt.SCREEN , defines: n = new Map , uniforms: s = new Map , extensions: o = null , vertexShader: a = null  } = {}){
        super(), this.name = i, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = a, this.defines = n, this.uniforms = s, this.extensions = o, this.blendMode = new qU(r), this.blendMode.addEventListener("change", (l)=>this.setChanged()
        );
    }
    getName() {
        return this.name;
    }
    setRenderer(i) {
        this.renderer = i;
    }
    getDefines() {
        return this.defines;
    }
    getUniforms() {
        return this.uniforms;
    }
    getExtensions() {
        return this.extensions;
    }
    getBlendMode() {
        return this.blendMode;
    }
    getAttributes() {
        return this.attributes;
    }
    setAttributes(i) {
        this.attributes = i, this.setChanged();
    }
    getFragmentShader() {
        return this.fragmentShader;
    }
    setFragmentShader(i) {
        this.fragmentShader = i, this.setChanged();
    }
    getVertexShader() {
        return this.vertexShader;
    }
    setVertexShader(i) {
        this.vertexShader = i, this.setChanged();
    }
    setChanged() {
        this.dispatchEvent({
            type: "change"
        });
    }
    setDepthTexture(i, e = Ir) {}
    update(i, e, t) {}
    setSize(i, e) {}
    initialize(i, e, t) {}
    dispose() {
        for (let i of Object.keys(this)){
            let e = this[i];
            if (e !== null && typeof e.dispose == "function") {
                if (e instanceof on || e === this.renderer) continue;
                this[i].dispose();
            }
        }
    }
};
function wA(i, e, t) {
    for (let r of e){
        let n = "$1" + i + r.charAt(0).toUpperCase() + r.slice(1), s = new RegExp("([^\\.])(\\b" + r + "\\b)", "g");
        for (let o of t.entries())o[1] !== null && t.set(o[0], o[1].replace(s, n));
    }
}
function YU(i, e, t, r, n, s, o) {
    let a = new Map([
        [
            "fragment",
            e.getFragmentShader()
        ],
        [
            "vertex",
            e.getVertexShader()
        ]
    ]), l = a.get("fragment") !== void 0 && /mainImage/.test(a.get("fragment")), c = a.get("fragment") !== void 0 && /mainUv/.test(a.get("fragment")), h = [], u = [], f = !1, d = !1;
    if (a.get("fragment") === void 0) console.error("Missing fragment shader", e);
    else if (c && (o & Hi.CONVOLUTION) !== 0) console.error("Effects that transform UV coordinates are incompatible with convolution effects", e);
    else if (!l && !c) console.error("The fragment shader contains neither a mainImage nor a mainUv function", e);
    else {
        let p = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g, m = jv.Section;
        if (c) {
            let v = `	${i}MainUv(UV);
`;
            t.set(m.FRAGMENT_MAIN_UV, t.get(m.FRAGMENT_MAIN_UV) + v), f = !0;
        }
        if (a.get("vertex") !== null && /mainSupport/.test(a.get("vertex"))) {
            let v = `	${i}MainSupport(`;
            v += /mainSupport *\([\w\s]*?uv\s*?\)/.test(a.get("vertex")) ? `vUv);
` : `);
`, t.set(m.VERTEX_MAIN_SUPPORT, t.get(m.VERTEX_MAIN_SUPPORT) + v), h = h.concat([
                ...a.get("vertex").matchAll(/(?:varying\s+\w+\s+(\w*))/g)
            ].map((y)=>y[1]
            )), u = u.concat(h).concat([
                ...a.get("vertex").matchAll(p)
            ].map((y)=>y[1]
            ));
        }
        u = u.concat([
            ...a.get("fragment").matchAll(p)
        ].map((v)=>v[1]
        )), u = u.concat([
            ...e.defines.keys()
        ].map((v)=>v.replace(/\([\w\s,]*\)/g, "")
        )), u = u.concat([
            ...e.uniforms.keys()
        ]), e.uniforms.forEach((v, y)=>s.set(i + y.charAt(0).toUpperCase() + y.slice(1), v)
        ), e.defines.forEach((v, y)=>n.set(i + y.charAt(0).toUpperCase() + y.slice(1), v)
        ), wA(i, u, n), wA(i, u, a);
        let g = e.blendMode;
        if (r.set(g.blendFunction, g), l) {
            let v = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/, y = `${i}MainImage(color0, UV, `;
            (o & Hi.DEPTH) !== 0 && v.test(a.get("fragment")) && (y += "depth, ", d = !0), y += `color1);
	`;
            let w = i + "BlendOpacity";
            s.set(w, g.opacity), y += `color0 = blend${g.blendFunction}(color0, color1, ${w});

	`, t.set(m.FRAGMENT_MAIN_IMAGE, t.get(m.FRAGMENT_MAIN_IMAGE) + y), y = `uniform float ${w};

`, t.set(m.FRAGMENT_HEAD, t.get(m.FRAGMENT_HEAD) + y);
        }
        t.set(m.FRAGMENT_HEAD, t.get(m.FRAGMENT_HEAD) + a.get("fragment") + `
`), a.get("vertex") !== null && t.set(m.VERTEX_HEAD, t.get(m.VERTEX_HEAD) + a.get("vertex") + `
`);
    }
    return {
        varyings: h,
        transformedUv: f,
        readDepth: d
    };
}
var Kp = class extends ys {
    constructor(i, ...e){
        super("EffectPass"), this.fullscreenMaterial = new jv(null, null, null, i), this.effects = e.sort((t, r)=>r.attributes - t.attributes
        ), this.skipRendering = !1, this.uniformCount = 0, this.varyingCount = 0, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY;
    }
    get encodeOutput() {
        return this.fullscreenMaterial.encodeOutput;
    }
    set encodeOutput(i) {
        this.fullscreenMaterial.encodeOutput = i;
    }
    get dithering() {
        return this.fullscreenMaterial.dithering;
    }
    set dithering(i) {
        let e = this.fullscreenMaterial;
        e.dithering = i, e.needsUpdate = !0;
    }
    verifyResources() {
        let i = this.renderer.capabilities, e = Math.min(i.maxFragmentUniforms, i.maxVertexUniforms);
        this.uniformCount > e && console.warn("The current rendering context doesn't support more than " + e + " uniforms, but " + this.uniformCount + " were defined"), e = i.maxVaryings, this.varyingCount > e && console.warn("The current rendering context doesn't support more than " + e + " varyings, but " + this.varyingCount + " were defined");
    }
    updateMaterial() {
        let i = jv.Section, e = new Map([
            [
                i.FRAGMENT_HEAD,
                ""
            ],
            [
                i.FRAGMENT_MAIN_UV,
                ""
            ],
            [
                i.FRAGMENT_MAIN_IMAGE,
                ""
            ],
            [
                i.VERTEX_HEAD,
                ""
            ],
            [
                i.VERTEX_MAIN_SUPPORT,
                ""
            ]
        ]), t = new Map, r = new Map, n = new Map, s = new Set, o = 0, a = 0, l = 0, c = !1, h = !1;
        for (let f22 of this.effects)if (f22.blendMode.blendFunction === vt.SKIP) l |= f22.getAttributes() & Hi.DEPTH;
        else if ((l & f22.getAttributes() & Hi.CONVOLUTION) !== 0) console.error("Convolution effects cannot be merged", f22);
        else {
            l |= f22.getAttributes();
            let d = "e" + o++, p = YU(d, f22, e, t, r, n, l);
            if (a += p.varyings.length, c = c || p.transformedUv, h = h || p.readDepth, f22.extensions !== null) for (let m of f22.extensions)s.add(m);
        }
        let u = /\bblend\b/g;
        for (let f21 of t.values()){
            let d = f21.getShaderCode().replace(u, `blend${f21.blendFunction}`);
            e.set(i.FRAGMENT_HEAD, e.get(i.FRAGMENT_HEAD) + d + `
`);
        }
        if ((l & Hi.DEPTH) !== 0) {
            if (h) {
                let f = `float depth = readDepth(UV);

	`;
                e.set(i.FRAGMENT_MAIN_IMAGE, f + e.get(i.FRAGMENT_MAIN_IMAGE));
            }
            this.needsDepthTexture = this.getDepthTexture() === null;
        } else this.needsDepthTexture = !1;
        if (c) {
            let f = `vec2 transformedUv = vUv;
`;
            e.set(i.FRAGMENT_MAIN_UV, f + e.get(i.FRAGMENT_MAIN_UV)), r.set("UV", "transformedUv");
        } else r.set("UV", "vUv");
        e.forEach((f, d, p)=>p.set(d, f.trim().replace(/^#/, `
#`))
        ), this.uniformCount = n.size, this.varyingCount = a, this.skipRendering = o === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderParts(e).setExtensions(s).setUniforms(n).setDefines(r);
    }
    recompile() {
        this.updateMaterial(), this.verifyResources();
    }
    getDepthTexture() {
        return this.fullscreenMaterial.depthBuffer;
    }
    setDepthTexture(i, e = Ir) {
        this.fullscreenMaterial.depthBuffer = i, this.fullscreenMaterial.depthPacking = e;
        for (let t of this.effects)t.setDepthTexture(i, e);
    }
    render(i, e, t, r, n) {
        for (let s of this.effects)s.update(i, e, r);
        if (!this.skipRendering || this.renderToScreen) {
            let s = this.fullscreenMaterial;
            s.inputBuffer = e.texture, s.time += r, i.setRenderTarget(this.renderToScreen ? null : t), i.render(this.scene, this.camera);
        }
    }
    setSize(i, e) {
        this.fullscreenMaterial.setSize(i, e);
        for (let t of this.effects)t.setSize(i, e);
    }
    initialize(i, e, t) {
        this.renderer = i;
        for (let r of this.effects)r.initialize(i, e, t), r.addEventListener("change", (n)=>this.handleEvent(n)
        );
        this.updateMaterial(), this.verifyResources(), t !== void 0 && t !== qt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
    }
    dispose() {
        super.dispose();
        for (let i of this.effects)i.dispose();
    }
    handleEvent(i) {
        switch(i.type){
            case "change":
                this.recompile();
                break;
        }
    }
}, XU = [
    new Float32Array([
        0,
        0
    ]),
    new Float32Array([
        0,
        1,
        1
    ]),
    new Float32Array([
        0,
        1,
        1,
        2
    ]),
    new Float32Array([
        0,
        1,
        2,
        2,
        3
    ]),
    new Float32Array([
        0,
        1,
        2,
        3,
        4,
        4,
        5
    ]),
    new Float32Array([
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        8,
        9,
        10
    ])
], EA = class extends ys {
    constructor({ resolutionScale: i = .5 , width: e = bi.AUTO_SIZE , height: t = bi.AUTO_SIZE , kernelSize: r = Jv.LARGE  } = {}){
        super("KawaseBlurPass"), this.renderTargetA = new mt(1, 1, {
            minFilter: ct,
            magFilter: ct,
            stencilBuffer: !1,
            depthBuffer: !1
        }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
        let n = this.resolution = new bi(this, e, t, i);
        n.addEventListener("change", (s)=>this.setSize(n.baseWidth, n.baseHeight)
        ), this.blurMaterial = new xA, this.ditheredBlurMaterial = new xA, this.ditheredBlurMaterial.uniforms.scale = this.blurMaterial.uniforms.scale, this.ditheredBlurMaterial.dithering = !0, this.dithering = !1, this.kernelSize = r;
    }
    getResolution() {
        return this.resolution;
    }
    get width() {
        return this.resolution.width;
    }
    set width(i) {
        this.resolution.preferredWidth = i;
    }
    get height() {
        return this.resolution.height;
    }
    set height(i) {
        this.resolution.preferredHeight = i;
    }
    get scale() {
        return this.blurMaterial.scale;
    }
    set scale(i) {
        this.blurMaterial.scale = i;
    }
    getScale() {
        return this.blurMaterial.scale;
    }
    setScale(i) {
        this.blurMaterial.scale = i;
    }
    getKernelSize() {
        return this.kernelSize;
    }
    setKernelSize(i) {
        this.kernelSize = i;
    }
    getResolutionScale() {
        return this.resolution.scale;
    }
    setResolutionScale(i) {
        this.resolution.scale = i;
    }
    render(i, e, t, r, n) {
        let s = this.scene, o = this.camera, a = this.renderTargetA, l = this.renderTargetB, c = XU[this.kernelSize], h = this.blurMaterial, u = e, f, d;
        for(this.fullscreenMaterial = h, f = 0, d = c.length - 1; f < d; ++f){
            let p = (f & 1) === 0 ? a : l;
            h.kernel = c[f], h.inputBuffer = u.texture, i.setRenderTarget(p), i.render(s, o), u = p;
        }
        this.dithering && (h = this.ditheredBlurMaterial, this.fullscreenMaterial = h), h.kernel = c[f], h.inputBuffer = u.texture, i.setRenderTarget(this.renderToScreen ? null : t), i.render(s, o);
    }
    setSize(i, e) {
        let t = this.resolution;
        t.setBaseSize(i, e);
        let r = t.width, n = t.height;
        this.renderTargetA.setSize(r, n), this.renderTargetB.setSize(r, n), this.blurMaterial.setSize(r, n), this.ditheredBlurMaterial.setSize(r, n);
    }
    initialize(i, e, t) {
        t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== qt ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : i.outputEncoding === je && (this.renderTargetA.texture.encoding = je, this.renderTargetB.texture.encoding = je));
    }
    static get AUTO_SIZE() {
        return bi.AUTO_SIZE;
    }
};
var QU = class extends ys {
    constructor({ width: i = bi.AUTO_SIZE , height: e = bi.AUTO_SIZE , renderTarget: t , luminanceRange: r , colorOutput: n  } = {}){
        super("LuminancePass"), this.fullscreenMaterial = new vU(n, r), this.needsSwap = !1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new mt(1, 1, {
            minFilter: ct,
            magFilter: ct,
            stencilBuffer: !1,
            depthBuffer: !1
        }), this.renderTarget.texture.name = "LuminancePass.Target", this.renderTarget.texture.generateMipmaps = !1);
        let s = this.resolution = new bi(this, i, e);
        s.addEventListener("change", (o)=>this.setSize(s.baseWidth, s.baseHeight)
        );
    }
    get texture() {
        return this.renderTarget.texture;
    }
    getTexture() {
        return this.renderTarget.texture;
    }
    getResolution() {
        return this.resolution;
    }
    render(i, e, t, r, n) {
        let s = this.fullscreenMaterial;
        s.inputBuffer = e.texture, i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera);
    }
    setSize(i, e) {
        let t = this.resolution;
        t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height);
    }
    initialize(i, e, t) {
        t !== void 0 && t !== qt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
    }
}, JU = class extends ys {
    constructor(i, e){
        super("MaskPass", i, e), this.needsSwap = !1, this.clearPass = new Xv(!1, !1, !0), this.inverse = !1;
    }
    get inverted() {
        return this.inverse;
    }
    set inverted(i) {
        this.inverse = i;
    }
    get clear() {
        return this.clearPass.enabled;
    }
    set clear(i) {
        this.clearPass.enabled = i;
    }
    getClearPass() {
        return this.clearPass;
    }
    isInverted() {
        return this.inverted;
    }
    setInverted(i) {
        this.inverted = i;
    }
    render(i, e, t, r, n) {
        let s = i.getContext(), o = i.state.buffers, a = this.scene, l = this.camera, c = this.clearPass, h = this.inverted ? 0 : 1, u = 1 - h;
        o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, h, 4294967295), o.stencil.setClear(u), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(i, null) : (c.render(i, e), c.render(i, t))), this.renderToScreen ? (i.setRenderTarget(null), i.render(a, l)) : (i.setRenderTarget(e), i.render(a, l), i.setRenderTarget(t), i.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0);
    }
};
var yo = class extends ys {
    constructor(i, e = "inputBuffer"){
        super("ShaderPass"), this.fullscreenMaterial = i, this.inputBufferUniform = null, this.setInput(e);
    }
    setInput(i) {
        if (this.inputBufferUniform = null, this.fullscreenMaterial !== null) {
            let e = this.fullscreenMaterial.uniforms;
            e !== void 0 && e[i] !== void 0 && (this.inputBufferUniform = e[i]);
        }
    }
    render(i, e, t, r, n) {
        this.inputBufferUniform !== null && e !== null && (this.inputBufferUniform.value = e.texture), i.setRenderTarget(this.renderToScreen ? null : t), i.render(this.scene, this.camera);
    }
    initialize(i, e, t) {
        t !== void 0 && t !== qt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
    }
}, Vv = 0.001, KU = 1e3, ZU = class {
    constructor(){
        this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1, this.autoReset = !1;
    }
    setFixedDeltaEnabled(i) {
        return this.fixedDeltaEnabled = i, this;
    }
    isAutoResetEnabled(i) {
        return this.autoReset;
    }
    setAutoResetEnabled(i) {
        return typeof document < "u" && document.hidden !== void 0 && (i ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this.autoReset = i), this;
    }
    getDelta() {
        return this.delta * Vv;
    }
    getFixedDelta() {
        return this.fixedDelta * Vv;
    }
    setFixedDelta(i) {
        return this.fixedDelta = i * KU, this;
    }
    getElapsed() {
        return this.elapsed * Vv;
    }
    getTimescale() {
        return this.timescale;
    }
    setTimescale(i) {
        return this.timescale = i, this;
    }
    update(i) {
        return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = i !== void 0 ? i : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.delta, this;
    }
    reset() {
        return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this;
    }
    handleEvent(i) {
        document.hidden || (this.currentTime = performance.now());
    }
    dispose() {
        this.setAutoResetEnabled(!1);
    }
}, _A = class {
    constructor(i = null, { depthBuffer: e = !0 , stencilBuffer: t = !1 , multisampling: r = 0 , frameBufferType: n  } = {}){
        this.renderer = null, this.inputBuffer = this.createBuffer(e, t, n, r), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new Yv, this.depthTexture = null, this.passes = [], this.timer = new ZU, this.autoRenderToScreen = !0, this.setRenderer(i);
    }
    get multisampling() {
        return this.inputBuffer.samples || 0;
    }
    set multisampling(i) {
        let e = this.inputBuffer, t = this.multisampling;
        t > 0 && i > 0 ? (this.inputBuffer.samples = i, this.outputBuffer.samples = i, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : t !== i && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, i), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone());
    }
    getTimer() {
        return this.timer;
    }
    getRenderer() {
        return this.renderer;
    }
    setRenderer(i) {
        if (this.renderer = i, i !== null) {
            let e = i.getSize(new B), t = i.getContext().getContextAttributes().alpha, r = this.inputBuffer.texture.type;
            r === qt && i.outputEncoding === je && (this.inputBuffer.texture.encoding = je, this.outputBuffer.texture.encoding = je, this.inputBuffer.dispose(), this.outputBuffer.dispose()), i.autoClear = !1, this.setSize(e.width, e.height);
            for (let n of this.passes)n.initialize(i, t, r);
        }
    }
    replaceRenderer(i, e = !0) {
        let t = this.renderer, r = t.domElement.parentNode;
        return this.setRenderer(i), e && r !== null && (r.removeChild(t.domElement), r.appendChild(i.domElement)), t;
    }
    createDepthTexture() {
        let i = this.depthTexture = new oi;
        return this.inputBuffer.depthTexture = i, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (i.format = Ns, i.type = Ls) : i.type = La, i;
    }
    deleteDepthTexture() {
        if (this.depthTexture !== null) {
            this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
            for (let i of this.passes)i.setDepthTexture(null);
        }
    }
    createBuffer(i, e, t, r) {
        let n = this.renderer, s = n === null ? new B : n.getDrawingBufferSize(new B), o = {
            minFilter: ct,
            magFilter: ct,
            stencilBuffer: e,
            depthBuffer: i,
            type: t
        }, a;
        return r > 0 ? (a = Number(Uo.replace(/\D+/g, "")) < 138 ? new Zf(s.width, s.height, o) : new mt(s.width, s.height, o), a.ignoreDepthForMultisampleCopy = !1, a.samples = r) : a = new mt(s.width, s.height, o), t === qt && n !== null && n.outputEncoding === je && (a.texture.encoding = je), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = !1, a;
    }
    addPass(i, e) {
        let t = this.passes, r = this.renderer, n = r.getDrawingBufferSize(new B), s = r.getContext().getContextAttributes().alpha, o = this.inputBuffer.texture.type;
        if (i.setRenderer(r), i.setSize(n.width, n.height), i.initialize(r, s, o), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), i.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, i) : t.push(i), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), i.needsDepthTexture || this.depthTexture !== null) {
            if (this.depthTexture === null) {
                let a = this.createDepthTexture();
                for (i of t)i.setDepthTexture(a);
            } else i.setDepthTexture(this.depthTexture);
        }
    }
    removePass(i) {
        let e = this.passes, t = e.indexOf(i);
        if (t !== -1 && e.splice(t, 1).length > 0) {
            if (this.depthTexture !== null) {
                let s = (a, l)=>a || l.needsDepthTexture
                ;
                e.reduce(s, !1) || (i.getDepthTexture() === this.depthTexture && i.setDepthTexture(null), this.deleteDepthTexture());
            }
            this.autoRenderToScreen && t === e.length && (i.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0));
        }
    }
    removeAllPasses() {
        let i = this.passes;
        this.deleteDepthTexture(), i.length > 0 && (this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !1), this.passes = []);
    }
    render(i) {
        let e = this.renderer, t = this.copyPass, r = this.inputBuffer, n = this.outputBuffer, s = !1, o, a, l;
        i === void 0 && (i = this.timer.update().getDelta());
        for (let c of this.passes)c.enabled && (c.render(e, r, n, i, s), c.needsSwap && (s && (t.renderToScreen = c.renderToScreen, o = e.getContext(), a = e.state.buffers.stencil, a.setFunc(o.NOTEQUAL, 1, 4294967295), t.render(e, r, n, i, s), a.setFunc(o.EQUAL, 1, 4294967295)), l = r, r = n, n = l), c instanceof JU ? s = !0 : c instanceof EU && (s = !1));
    }
    setSize(i, e, t) {
        let r = this.renderer;
        if (i === void 0 || e === void 0) {
            let s = r.getSize(new B);
            i = s.width, e = s.height;
        }
        r.setSize(i, e, t);
        let n = r.getDrawingBufferSize(new B);
        this.inputBuffer.setSize(n.width, n.height), this.outputBuffer.setSize(n.width, n.height);
        for (let s of this.passes)s.setSize(n.width, n.height);
    }
    reset() {
        let i = this.timer.isAutoResetEnabled();
        this.dispose(), this.autoRenderToScreen = !0, this.timer.setAutoResetEnabled(i);
    }
    dispose() {
        for (let i of this.passes)i.dispose();
        this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose();
    }
};
var Jv = {
    VERY_SMALL: 0,
    SMALL: 1,
    MEDIUM: 2,
    LARGE: 3,
    VERY_LARGE: 4,
    HUGE: 5
};
var $U = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`, CA = class extends Wi {
    constructor({ blendFunction: i = vt.SCREEN , luminanceThreshold: e = .9 , luminanceSmoothing: t = .025 , resolutionScale: r = .5 , intensity: n = 1 , width: s = bi.AUTO_SIZE , height: o = bi.AUTO_SIZE , kernelSize: a = Jv.LARGE  } = {}){
        super("BloomEffect", $U, {
            blendFunction: i,
            uniforms: new Map([
                [
                    "map",
                    new _e(null)
                ],
                [
                    "intensity",
                    new _e(n)
                ]
            ])
        }), this.renderTarget = new mt(1, 1, {
            minFilter: ct,
            magFilter: ct,
            stencilBuffer: !1,
            depthBuffer: !1
        }), this.renderTarget.texture.name = "Bloom.Target", this.renderTarget.texture.generateMipmaps = !1, this.uniforms.get("map").value = this.renderTarget.texture, this.luminancePass = new QU({
            renderTarget: this.renderTarget,
            colorOutput: !0
        }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothingFactor = t, this.blurPass = new EA({
            resolutionScale: r,
            width: s,
            height: o,
            kernelSize: a
        });
        let l = this.blurPass.getResolution();
        l.addEventListener("change", (c)=>this.setSize(l.baseWidth, l.baseHeight)
        );
    }
    get texture() {
        return this.renderTarget.texture;
    }
    getTexture() {
        return this.renderTarget.texture;
    }
    get resolution() {
        return this.blurPass.resolution;
    }
    getResolution() {
        return this.blurPass.resolution;
    }
    getBlurPass() {
        return this.blurPass;
    }
    getLuminancePass() {
        return this.luminancePass;
    }
    get luminanceMaterial() {
        return this.luminancePass.fullscreenMaterial;
    }
    getLuminanceMaterial() {
        return this.luminancePass.fullscreenMaterial;
    }
    get width() {
        return this.resolution.width;
    }
    set width(i) {
        this.resolution.preferredWidth = i;
    }
    get height() {
        return this.resolution.height;
    }
    set height(i) {
        this.resolution.preferredHeight = i;
    }
    get dithering() {
        return this.blurPass.dithering;
    }
    set dithering(i) {
        this.blurPass.dithering = i;
    }
    get kernelSize() {
        return this.blurPass.kernelSize;
    }
    set kernelSize(i) {
        this.blurPass.kernelSize = i;
    }
    get distinction() {
        return console.warn(this.name, "distinction was removed"), 1;
    }
    set distinction(i) {
        console.warn(this.name, "distinction was removed");
    }
    get intensity() {
        return this.uniforms.get("intensity").value;
    }
    set intensity(i) {
        this.uniforms.get("intensity").value = i;
    }
    getIntensity() {
        return this.intensity;
    }
    setIntensity(i) {
        this.intensity = i;
    }
    getResolutionScale() {
        return this.resolution.scale;
    }
    setResolutionScale(i) {
        this.resolution.scale = i;
    }
    update(i, e, t) {
        let r = this.renderTarget;
        this.luminancePass.enabled ? (this.luminancePass.render(i, e, r), this.blurPass.render(i, r, r)) : this.blurPass.render(i, e, r);
    }
    setSize(i, e) {
        let t = this.resolution;
        t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height), this.luminancePass.resolution.copy(t);
    }
    initialize(i, e, t) {
        this.blurPass.initialize(i, e, t), t !== void 0 && (this.renderTarget.texture.type = t, i.outputEncoding === je && (this.renderTarget.texture.encoding = je));
    }
};
var ez = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}", DA = class extends Wi {
    constructor({ blendFunction: i = vt.NORMAL , brightness: e = 0 , contrast: t = 0  } = {}){
        super("BrightnessContrastEffect", ez, {
            blendFunction: i,
            uniforms: new Map([
                [
                    "brightness",
                    new _e(e)
                ],
                [
                    "contrast",
                    new _e(t)
                ]
            ])
        });
    }
    get brightness() {
        return this.uniforms.get("brightness").value;
    }
    set brightness(i) {
        this.uniforms.get("brightness").value = i;
    }
    getBrightness(i) {
        return this.brightness;
    }
    setBrightness(i) {
        this.brightness = i;
    }
    get contrast() {
        return this.uniforms.get("contrast").value;
    }
    set contrast(i) {
        this.uniforms.get("contrast").value = i;
    }
    getContrast(i) {
        return this.contrast;
    }
    setContrast(i) {
        this.contrast = i;
    }
}, tz = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}", PA = class extends Wi {
    constructor(i = vt.NORMAL){
        super("ColorAverageEffect", tz, {
            blendFunction: i
        });
    }
};
var rz = "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}", nz = "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}", LA = class extends Wi {
    constructor({ blendFunction: i = vt.NORMAL , offset: e = new B(.001, 5e-4)  } = {}){
        super("ChromaticAberrationEffect", rz, {
            vertexShader: nz,
            blendFunction: i,
            attributes: Hi.CONVOLUTION,
            uniforms: new Map([
                [
                    "offset",
                    new _e(e)
                ]
            ])
        });
    }
    get offset() {
        return this.uniforms.get("offset").value;
    }
    set offset(i) {
        this.uniforms.get("offset").value = i;
    }
    getOffset() {
        return this.offset;
    }
    setOffset(i) {
        this.offset = i;
    }
};
var iz = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`, IA = class extends Wi {
    constructor(i, { blendFunction: e = vt.NORMAL , worldFocusDistance: t , worldFocusRange: r , focusDistance: n = 0 , focalLength: s = .1 , focusRange: o = s , bokehScale: a = 1 , width: l = bi.AUTO_SIZE , height: c = bi.AUTO_SIZE  } = {}){
        super("DepthOfFieldEffect", iz, {
            blendFunction: e,
            attributes: Hi.DEPTH,
            uniforms: new Map([
                [
                    "nearColorBuffer",
                    new _e(null)
                ],
                [
                    "farColorBuffer",
                    new _e(null)
                ],
                [
                    "nearCoCBuffer",
                    new _e(null)
                ],
                [
                    "scale",
                    new _e(1)
                ]
            ])
        }), this.camera = i, this.renderTarget = new mt(1, 1, {
            minFilter: ct,
            magFilter: ct,
            stencilBuffer: !1,
            depthBuffer: !1
        }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTarget.texture.generateMipmaps = !1, this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new yo(new aU(i));
        let h = this.cocMaterial;
        h.focusDistance = n, h.focusRange = o, t !== void 0 && (h.worldFocusDistance = t), r !== void 0 && (h.worldFocusRange = r), this.blurPass = new EA({
            kernelSize: Jv.MEDIUM,
            width: l,
            height: c
        });
        let u = this.blurPass.getResolution();
        u.addEventListener("change", (d)=>this.setSize(u.getBaseWidth(), u.getBaseHeight())
        ), this.maskPass = new yo(new bU(this.renderTargetCoC.texture));
        let f = this.maskPass.fullscreenMaterial;
        f.maskFunction = TA.MULTIPLY, f.colorChannel = AA.GREEN, this.bokehNearBasePass = new yo(new Xp(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new yo(new Xp(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new yo(new Xp(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new yo(new Xp(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null, this.bokehScale = a;
    }
    get cocTexture() {
        return this.renderTargetCoC.texture;
    }
    get cocMaterial() {
        return this.cocPass.fullscreenMaterial;
    }
    get circleOfConfusionMaterial() {
        return this.cocMaterial;
    }
    getCircleOfConfusionMaterial() {
        return this.circleOfConfusionMaterial;
    }
    getBlurPass() {
        return this.blurPass;
    }
    get resolution() {
        return this.blurPass.getResolution();
    }
    getResolution() {
        return this.blurPass.getResolution();
    }
    get bokehScale() {
        return this.uniforms.get("scale").value;
    }
    set bokehScale(i) {
        let e = [
            this.bokehNearBasePass,
            this.bokehNearFillPass,
            this.bokehFarBasePass,
            this.bokehFarFillPass
        ];
        for (let t of e)t.fullscreenMaterial.setScale(i);
        this.maskPass.fullscreenMaterial.setStrength(i), this.uniforms.get("scale").value = i;
    }
    getBokehScale() {
        return this.bokehScale;
    }
    setBokehScale(i) {
        this.bokehScale = i;
    }
    getTarget() {
        return this.target;
    }
    setTarget(i) {
        this.target = i;
    }
    calculateFocusDistance(i) {
        let e = this.camera, t = e.position.distanceTo(i);
        return Wv(-t, e.near, e.far);
    }
    setDepthTexture(i, e = Ir) {
        this.circleOfConfusionMaterial.depthBuffer = i, this.circleOfConfusionMaterial.depthPacking = e;
    }
    update(i, e, t) {
        let r = this.renderTarget, n = this.renderTargetCoC, s = this.renderTargetCoCBlurred, o = this.renderTargetMasked;
        if (this.target !== null) {
            let a = this.calculateFocusDistance(this.target);
            this.circleOfConfusionMaterial.focusDistance = a;
        }
        this.cocPass.render(i, null, n), this.blurPass.render(i, n, s), this.maskPass.render(i, e, o), this.bokehFarBasePass.render(i, o, r), this.bokehFarFillPass.render(i, r, this.renderTargetFar), this.bokehNearBasePass.render(i, e, r), this.bokehNearFillPass.render(i, r, this.renderTargetNear);
    }
    setSize(i, e) {
        let t = this.resolution;
        t.setBaseSize(i, e);
        let r = t.width, n = t.height, s = [
            this.cocPass,
            this.blurPass,
            this.maskPass,
            this.bokehNearBasePass,
            this.bokehNearFillPass,
            this.bokehFarBasePass,
            this.bokehFarFillPass
        ];
        s.push(this.renderTargetCoC, this.renderTargetMasked), s.forEach((a)=>a.setSize(i, e)
        ), s = [
            this.renderTarget,
            this.renderTargetNear,
            this.renderTargetFar,
            this.renderTargetCoCBlurred
        ], s.forEach((a)=>a.setSize(r, n)
        ), [
            this.bokehNearBasePass,
            this.bokehNearFillPass,
            this.bokehFarBasePass,
            this.bokehFarFillPass
        ].forEach((a)=>a.fullscreenMaterial.setSize(r, n)
        );
    }
    initialize(i, e, t) {
        [
            this.cocPass,
            this.maskPass,
            this.bokehNearBasePass,
            this.bokehNearFillPass,
            this.bokehFarBasePass,
            this.bokehFarFillPass
        ].forEach((n)=>n.initialize(i, e, t)
        ), this.blurPass.initialize(i, e, qt), t !== void 0 && (this.renderTarget.texture.type = t, this.renderTargetNear.texture.type = t, this.renderTargetFar.texture.type = t, this.renderTargetMasked.texture.type = t, i.outputEncoding === je && (this.renderTarget.texture.encoding = je, this.renderTargetNear.texture.encoding = je, this.renderTargetFar.texture.encoding = je, this.renderTargetMasked.texture.encoding = je));
    }
};
var hae = new M, uae = new Ae;
var sz = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", RA = class extends Wi {
    constructor({ blendFunction: i = vt.NORMAL , hue: e = 0 , saturation: t = 0  } = {}){
        super("HueSaturationEffect", sz, {
            blendFunction: i,
            uniforms: new Map([
                [
                    "hue",
                    new _e(new M)
                ],
                [
                    "saturation",
                    new _e(t)
                ]
            ])
        }), this.hue = e;
    }
    get saturation() {
        return this.uniforms.get("saturation").value;
    }
    set saturation(i) {
        this.uniforms.get("saturation").value = i;
    }
    getSaturation() {
        return this.saturation;
    }
    setSaturation(i) {
        this.saturation = i;
    }
    get hue() {
        let i = this.uniforms.get("hue").value;
        return Math.acos((i.x * 3 - 1) / 2);
    }
    set hue(i) {
        let e = Math.sin(i), t = Math.cos(i);
        this.uniforms.get("hue").value.set((2 * t + 1) / 3, (-Math.sqrt(3) * e - t + 1) / 3, (Math.sqrt(3) * e - t + 1) / 3);
    }
    getHue() {
        return this.hue;
    }
    setHue(i) {
        this.hue = i;
    }
};
var pae = new be;
var oz = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`, BA = class extends Wi {
    constructor({ blendFunction: i = vt.SCREEN , premultiply: e = !1  } = {}){
        super("NoiseEffect", oz, {
            blendFunction: i
        }), this.premultiply = e;
    }
    get premultiply() {
        return this.defines.has("PREMULTIPLY");
    }
    set premultiply(i) {
        this.premultiply !== i && (i ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged());
    }
    isPremultiplied() {
        return this.premultiply;
    }
    setPremultiplied(i) {
        this.premultiply = i;
    }
};
var az = "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}", NA = class extends Wi {
    constructor(i = 30){
        super("PixelationEffect", az, {
            uniforms: new Map([
                [
                    "active",
                    new _e(!1)
                ],
                [
                    "d",
                    new _e(new B)
                ]
            ])
        }), this.resolution = new B, this.d = 0, this.granularity = i;
    }
    get granularity() {
        return this.d;
    }
    set granularity(i) {
        let e = Math.floor(i);
        e % 2 > 0 && (e += 1), this.d = e, this.uniforms.get("active").value = e > 0, this.setSize(this.resolution.width, this.resolution.height);
    }
    getGranularity() {
        return this.granularity;
    }
    setGranularity(i) {
        this.granularity = i;
    }
    setSize(i, e) {
        this.resolution.set(i, e), this.uniforms.get("d").value.setScalar(this.d).divide(this.resolution);
    }
};
var yae = Math.PI * .5, vae = new M, xae = new M;
var SA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", MA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC", lz = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", cz = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", ta = {
    LOW: 0,
    MEDIUM: 1,
    HIGH: 2,
    ULTRA: 3
}, OA = class extends Wi {
    constructor({ preset: i = ta.MEDIUM , edgeDetectionMode: e = Jp.COLOR , predicationMode: t = qv.DISABLED  } = {}){
        super("SMAAEffect", lz, {
            vertexShader: cz,
            blendFunction: vt.NORMAL,
            attributes: Hi.CONVOLUTION | Hi.DEPTH,
            uniforms: new Map([
                [
                    "weightMap",
                    new _e(null)
                ]
            ])
        });
        let r, n;
        arguments.length > 1 && (r = arguments[0], n = arguments[1], arguments.length > 2 && (i = arguments[2]), arguments.length > 3 && (e = arguments[3])), this.renderTargetEdges = new mt(1, 1, {
            minFilter: ct,
            stencilBuffer: !1,
            depthBuffer: !1
        }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new Xv(!0, !1, !1), this.clearPass.overrideClearColor = new be(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new yo(new pU), this.edgeDetectionMaterial.edgeDetectionMode = e, this.edgeDetectionMaterial.predicationMode = t, this.weightsPass = new yo(new MU);
        let s = new No;
        s.onLoad = ()=>{
            let o = new Dt(r);
            o.name = "SMAA.Search", o.magFilter = hr, o.minFilter = hr, o.generateMipmaps = !1, o.needsUpdate = !0, o.flipY = !0, this.weightsMaterial.searchTexture = o;
            let a = new Dt(n);
            a.name = "SMAA.Area", a.magFilter = ct, a.minFilter = ct, a.generateMipmaps = !1, a.needsUpdate = !0, a.flipY = !1, this.weightsMaterial.areaTexture = a, this.dispatchEvent({
                type: "load"
            });
        }, s.itemStart("search"), s.itemStart("area"), r !== void 0 && n !== void 0 ? (s.itemEnd("search"), s.itemEnd("area")) : typeof Image < "u" && (r = new Image, n = new Image, r.addEventListener("load", ()=>s.itemEnd("search")
        ), n.addEventListener("load", ()=>s.itemEnd("area")
        ), r.src = SA, n.src = MA), this.applyPreset(i);
    }
    get edgesTexture() {
        return this.renderTargetEdges.texture;
    }
    getEdgesTexture() {
        return this.edgesTexture;
    }
    get weightsTexture() {
        return this.renderTargetWeights.texture;
    }
    getWeightsTexture() {
        return this.weightsTexture;
    }
    get edgeDetectionMaterial() {
        return this.edgeDetectionPass.fullscreenMaterial;
    }
    get colorEdgesMaterial() {
        return this.edgeDetectionMaterial;
    }
    getEdgeDetectionMaterial() {
        return this.edgeDetectionMaterial;
    }
    get weightsMaterial() {
        return this.weightsPass.fullscreenMaterial;
    }
    getWeightsMaterial() {
        return this.weightsMaterial;
    }
    setEdgeDetectionThreshold(i) {
        this.edgeDetectionMaterial.edgeDetectionThreshold = i;
    }
    setOrthogonalSearchSteps(i) {
        this.weightsMaterial.orthogonalSearchSteps = i;
    }
    applyPreset(i) {
        let e = this.edgeDetectionMaterial, t = this.weightsMaterial;
        switch(i){
            case ta.LOW:
                e.edgeDetectionThreshold = .15, t.orthogonalSearchSteps = 4, t.diagonalDetection = !1, t.cornerDetection = !1;
                break;
            case ta.MEDIUM:
                e.edgeDetectionThreshold = .1, t.orthogonalSearchSteps = 8, t.diagonalDetection = !1, t.cornerDetection = !1;
                break;
            case ta.HIGH:
                e.edgeDetectionThreshold = .1, t.orthogonalSearchSteps = 16, t.diagonalSearchSteps = 8, t.cornerRounding = 25, t.diagonalDetection = !0, t.cornerDetection = !0;
                break;
            case ta.ULTRA:
                e.edgeDetectionThreshold = .05, t.orthogonalSearchSteps = 32, t.diagonalSearchSteps = 16, t.cornerRounding = 25, t.diagonalDetection = !0, t.cornerDetection = !0;
                break;
        }
    }
    setDepthTexture(i, e = Ir) {
        this.edgeDetectionMaterial.depthBuffer = i, this.edgeDetectionMaterial.depthPacking = e;
    }
    update(i, e, t) {
        this.clearPass.render(i, this.renderTargetEdges), this.edgeDetectionPass.render(i, e, this.renderTargetEdges), this.weightsPass.render(i, this.renderTargetEdges, this.renderTargetWeights);
    }
    setSize(i, e) {
        this.edgeDetectionMaterial.setSize(i, e), this.weightsMaterial.setSize(i, e), this.renderTargetEdges.setSize(i, e), this.renderTargetWeights.setSize(i, e);
    }
    dispose() {
        let { searchTexture: i , areaTexture: e  } = this.weightsMaterial;
        i !== null && e !== null && (i.dispose(), e.dispose()), super.dispose();
    }
    static get searchImageDataURL() {
        return SA;
    }
    static get areaImageDataURL() {
        return MA;
    }
};
var hz = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`, Qp = {
    DEFAULT: 0,
    ESKIL: 1
}, FA = class extends Wi {
    constructor({ blendFunction: i = vt.NORMAL , technique: e = Qp.DEFAULT , eskil: t = !1 , offset: r = .5 , darkness: n = .5  } = {}){
        super("VignetteEffect", hz, {
            blendFunction: i,
            defines: new Map([
                [
                    "VIGNETTE_TECHNIQUE",
                    e.toFixed(0)
                ]
            ]),
            uniforms: new Map([
                [
                    "offset",
                    new _e(r)
                ],
                [
                    "darkness",
                    new _e(n)
                ]
            ])
        });
    }
    get technique() {
        return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
    }
    set technique(i) {
        this.technique !== i && (this.defines.set("VIGNETTE_TECHNIQUE", i.toFixed(0)), this.setChanged());
    }
    get eskil() {
        return this.technique === Qp.ESKIL;
    }
    set eskil(i) {
        this.technique = i ? Qp.ESKIL : Qp.DEFAULT;
    }
    getTechnique() {
        return this.technique;
    }
    setTechnique(i) {
        this.technique = i;
    }
    get offset() {
        return this.uniforms.get("offset").value;
    }
    set offset(i) {
        this.uniforms.get("offset").value = i;
    }
    getOffset() {
        return this.offset;
    }
    setOffset(i) {
        this.offset = i;
    }
    get darkness() {
        return this.uniforms.get("darkness").value;
    }
    set darkness(i) {
        this.uniforms.get("darkness").value = i;
    }
    getDarkness() {
        return this.darkness;
    }
    setDarkness(i) {
        this.darkness = i;
    }
}, Sae = [
    new Float32Array(3),
    new Float32Array(3)
], Mae = [
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3)
], Aae = [
    [
        new Float32Array([
            0,
            0,
            0
        ]),
        new Float32Array([
            1,
            0,
            0
        ]),
        new Float32Array([
            1,
            1,
            0
        ]),
        new Float32Array([
            1,
            1,
            1
        ])
    ],
    [
        new Float32Array([
            0,
            0,
            0
        ]),
        new Float32Array([
            1,
            0,
            0
        ]),
        new Float32Array([
            1,
            0,
            1
        ]),
        new Float32Array([
            1,
            1,
            1
        ])
    ],
    [
        new Float32Array([
            0,
            0,
            0
        ]),
        new Float32Array([
            0,
            0,
            1
        ]),
        new Float32Array([
            1,
            0,
            1
        ]),
        new Float32Array([
            1,
            1,
            1
        ])
    ],
    [
        new Float32Array([
            0,
            0,
            0
        ]),
        new Float32Array([
            0,
            1,
            0
        ]),
        new Float32Array([
            1,
            1,
            0
        ]),
        new Float32Array([
            1,
            1,
            1
        ])
    ],
    [
        new Float32Array([
            0,
            0,
            0
        ]),
        new Float32Array([
            0,
            1,
            0
        ]),
        new Float32Array([
            0,
            1,
            1
        ]),
        new Float32Array([
            1,
            1,
            1
        ])
    ],
    [
        new Float32Array([
            0,
            0,
            0
        ]),
        new Float32Array([
            0,
            0,
            1
        ]),
        new Float32Array([
            0,
            1,
            1
        ]),
        new Float32Array([
            1,
            1,
            1
        ])
    ]
];
var Tae = [
    new Float32Array(2),
    new Float32Array(2)
];
var Eae = new Float32Array([
    0,
    -0.25,
    .25,
    -0.125,
    .125,
    -0.375,
    .375
]), _ae = [
    new Float32Array([
        0,
        0
    ]),
    new Float32Array([
        .25,
        -0.25
    ]),
    new Float32Array([
        -0.25,
        .25
    ]),
    new Float32Array([
        .125,
        -0.125
    ]),
    new Float32Array([
        -0.125,
        .125
    ])
], Cae = [
    new Uint8Array([
        0,
        0
    ]),
    new Uint8Array([
        3,
        0
    ]),
    new Uint8Array([
        0,
        3
    ]),
    new Uint8Array([
        3,
        3
    ]),
    new Uint8Array([
        1,
        0
    ]),
    new Uint8Array([
        4,
        0
    ]),
    new Uint8Array([
        1,
        3
    ]),
    new Uint8Array([
        4,
        3
    ]),
    new Uint8Array([
        0,
        1
    ]),
    new Uint8Array([
        3,
        1
    ]),
    new Uint8Array([
        0,
        4
    ]),
    new Uint8Array([
        3,
        4
    ]),
    new Uint8Array([
        1,
        1
    ]),
    new Uint8Array([
        4,
        1
    ]),
    new Uint8Array([
        1,
        4
    ]),
    new Uint8Array([
        4,
        4
    ])
], Dae = [
    new Uint8Array([
        0,
        0
    ]),
    new Uint8Array([
        1,
        0
    ]),
    new Uint8Array([
        0,
        2
    ]),
    new Uint8Array([
        1,
        2
    ]),
    new Uint8Array([
        2,
        0
    ]),
    new Uint8Array([
        3,
        0
    ]),
    new Uint8Array([
        2,
        2
    ]),
    new Uint8Array([
        3,
        2
    ]),
    new Uint8Array([
        0,
        1
    ]),
    new Uint8Array([
        1,
        1
    ]),
    new Uint8Array([
        0,
        3
    ]),
    new Uint8Array([
        1,
        3
    ]),
    new Uint8Array([
        2,
        1
    ]),
    new Uint8Array([
        3,
        1
    ]),
    new Uint8Array([
        2,
        3
    ]),
    new Uint8Array([
        3,
        3
    ])
];
var Pae = new Map([
    [
        $r(0, 0, 0, 0),
        new Float32Array([
            0,
            0,
            0,
            0
        ])
    ],
    [
        $r(0, 0, 0, 1),
        new Float32Array([
            0,
            0,
            0,
            1
        ])
    ],
    [
        $r(0, 0, 1, 0),
        new Float32Array([
            0,
            0,
            1,
            0
        ])
    ],
    [
        $r(0, 0, 1, 1),
        new Float32Array([
            0,
            0,
            1,
            1
        ])
    ],
    [
        $r(0, 1, 0, 0),
        new Float32Array([
            0,
            1,
            0,
            0
        ])
    ],
    [
        $r(0, 1, 0, 1),
        new Float32Array([
            0,
            1,
            0,
            1
        ])
    ],
    [
        $r(0, 1, 1, 0),
        new Float32Array([
            0,
            1,
            1,
            0
        ])
    ],
    [
        $r(0, 1, 1, 1),
        new Float32Array([
            0,
            1,
            1,
            1
        ])
    ],
    [
        $r(1, 0, 0, 0),
        new Float32Array([
            1,
            0,
            0,
            0
        ])
    ],
    [
        $r(1, 0, 0, 1),
        new Float32Array([
            1,
            0,
            0,
            1
        ])
    ],
    [
        $r(1, 0, 1, 0),
        new Float32Array([
            1,
            0,
            1,
            0
        ])
    ],
    [
        $r(1, 0, 1, 1),
        new Float32Array([
            1,
            0,
            1,
            1
        ])
    ],
    [
        $r(1, 1, 0, 0),
        new Float32Array([
            1,
            1,
            0,
            0
        ])
    ],
    [
        $r(1, 1, 0, 1),
        new Float32Array([
            1,
            1,
            0,
            1
        ])
    ],
    [
        $r(1, 1, 1, 0),
        new Float32Array([
            1,
            1,
            1,
            0
        ])
    ],
    [
        $r(1, 1, 1, 1),
        new Float32Array([
            1,
            1,
            1,
            1
        ])
    ]
]);
function Hv(i, e, t) {
    return i + (e - i) * t;
}
function $r(i, e, t, r) {
    let n = Hv(i, e, .75), s = Hv(t, r, 0.75);
    return Hv(n, s, 0.875);
}
var gr = class {
    constructor(e, t){
        this.enabled = !1;
        this.effect = new e(t), Object.defineProperty(this, "opacity", {
            enumerable: !0,
            set (r) {
                this.effect.blendMode.opacity.value = r;
            },
            get () {
                return this.effect.blendMode.opacity.value;
            }
        }), Object.defineProperty(this, "blendFunction", {
            enumerable: !0,
            set (r) {
                this.effect.blendMode.setBlendFunction(Number(r));
            },
            get () {
                return this.effect.blendMode.blendFunction;
            }
        }), this.blendFunction = vt.NORMAL;
    }
    toJSON() {
        let e = [
            "constructor",
            "effect",
            "subscriptions"
        ], t = ie({}, this), r = Object.getPrototypeOf(this), n = Object.getOwnPropertyNames(r);
        for (let s10 of n){
            let o = Object.getOwnPropertyDescriptor(r, s10);
            o && typeof o.get == "function" && (t[s10] = this[s10]);
        }
        return e.forEach((s)=>delete t[s]
        ), t;
    }
};
var ac = class extends gr {
    constructor(){
        super(CA), this.blendFunction = vt.SCREEN;
    }
    set intensity(e) {
        this.effect.intensity = e;
    }
    get intensity() {
        return this.effect.intensity;
    }
    set luminanceThreshold(e) {
        this.effect.luminanceMaterial.threshold = e;
    }
    get luminanceThreshold() {
        return this.effect.luminanceMaterial.threshold;
    }
    set luminanceSmoothing(e) {
        this.effect.luminanceMaterial.smoothing = e;
    }
    get luminanceSmoothing() {
        return this.effect.luminanceMaterial.smoothing;
    }
    set blurScale(e) {
        this.effect.blurPass.scale = e;
    }
    get blurScale() {
        return this.effect.blurPass.scale;
    }
    set kernelSize(e) {
        this.effect.blurPass.kernelSize = e;
    }
    get kernelSize() {
        return this.effect.blurPass.kernelSize;
    }
};
var lc = class extends gr {
    constructor(){
        super(DA);
    }
    set contrast(e) {
        this.effect.uniforms.get("contrast").value = e;
    }
    get contrast() {
        return this.effect.uniforms.get("contrast").value;
    }
    set brightness(e) {
        this.effect.uniforms.get("brightness").value = e;
    }
    get brightness() {
        return this.effect.uniforms.get("brightness").value;
    }
};
var cc = class extends gr {
    constructor(){
        super(LA), this.effect.offset = new B(.01, .01);
    }
    set offset(e) {
        this.effect.offset.set(e[0] / 1e3, e[1] / 1e3);
    }
    get offset() {
        return [
            this.effect.offset.x * 1e3,
            this.effect.offset.y * 1e3
        ];
    }
};
var hc = class extends gr {
    constructor(){
        super(PA);
    }
};
var uc = class extends gr {
    constructor(){
        super(RA);
        this._hue = 0;
    }
    set hue(t) {
        this._hue = t, this.effect.setHue(t);
    }
    get hue() {
        return this._hue;
    }
    set saturation(t) {
        this.effect.uniforms.get("saturation").value = t;
    }
    get saturation() {
        return this.effect.uniforms.get("saturation").value;
    }
};
var fc = class extends gr {
    constructor(){
        super(BA), this.blendFunction = vt.OVERLAY;
    }
};
var dc = class extends gr {
    constructor(){
        super(FA);
    }
    get eskil() {
        return this.effect.eskil;
    }
    set eskil(e) {
        this.effect.eskil = e;
    }
    get darkness() {
        return this.effect.uniforms.get("darkness").value;
    }
    set darkness(e) {
        this.effect.uniforms.get("darkness").value = e;
    }
    get offset() {
        return this.effect.uniforms.get("offset").value;
    }
    set offset(e) {
        this.effect.uniforms.get("offset").value = e;
    }
};
var pc = class extends gr {
    constructor(e){
        super(IA, e);
    }
    set focalLength(e) {
        this.effect.circleOfConfusionMaterial.uniforms.focalLength.value = e;
    }
    get focalLength() {
        return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value;
    }
    set focusDistance(e) {
        this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value = e;
    }
    get focusDistance() {
        return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value;
    }
    get bokehScale() {
        return this.effect.bokehScale;
    }
    set bokehScale(e) {
        this.effect.bokehScale = e;
    }
};
var mc = class extends gr {
    constructor(){
        super(NA);
    }
    get granularity() {
        return this.effect.getGranularity();
    }
    set granularity(e) {
        this.effect.setGranularity(e);
    }
};
function UA(i, e) {
    return e && e.enabled && i.push(e.effect), i;
}
var xu = class extends Yt {
    constructor(){
        super();
        this._scene = new on;
        this._camera = new Bn;
        this.effects = new Map;
        this.loadingManager = new No;
        this.renderPass = new Qv;
        this._renderToScreen = !0;
        this._hasSmaa = !1;
        this.clock = new jf, this.enabled = !1, this.debug = !1, this.effects.set("bloom", new ac), this.effects.set("chromaticAberration", new cc), this.effects.set("vignette", new dc), this.effects.set("noise", new fc), this.effects.set("colorAverage", new hc), this.effects.set("hueSaturation", new uc), this.effects.set("brightnessContrast", new lc), this.effects.set("depthOfField", new pc), this.effects.set("pixelation", new mc);
    }
    get scene() {
        return this._scene;
    }
    set scene(t) {
        this._scene = t;
    }
    get camera() {
        return this._camera;
    }
    set camera(t) {
        this._camera = t;
    }
    _initSmaa() {
        if (!this.effectComposer) return;
        let t = this.effectComposer.passes.length, r = new OA({
            preset: ta.ULTRA,
            edgeDetectionMode: Jp.COLOR
        }), n = ()=>{
            r.removeEventListener("load", n), this.dispatchEvent({
                type: "smaaloaded"
            });
        };
        r.addEventListener("load", n), r.edgeDetectionMaterial.setPredicationMode(qv.DEPTH), r.edgeDetectionMaterial.setEdgeDetectionThreshold(.05), r.edgeDetectionMaterial.setPredicationThreshold(.002), r.edgeDetectionMaterial.setPredicationScale(1), this.effectComposer.addPass(new Kp(this.camera, r), t), this._hasSmaa = !0;
    }
    _initPasses() {
        if (!this.effectComposer || !this.renderer) return;
        let t;
        if (this.effectComposer.removeAllPasses(), this._hasSmaa = !1, this.renderPass = new Qv(this.scene, this.camera), this.enabled) {
            this.effectComposer.addPass(this.renderPass), this._initSmaa();
            let r = [
                this.effects.get("chromaticAberration"),
                this.effects.get("bloom"),
                this.effects.get("colorAverage"),
                this.effects.get("hueSaturation"),
                this.effects.get("brightnessContrast"),
                this.effects.get("vignette"),
                this.effects.get("noise")
            ].reduce(UA, []), n = [
                this.effects.get("pixelation")
            ].reduce(UA, []);
            n.length > 0 && this.effectComposer.addPass(new Kp(this.camera, ...n)), this.effectComposer.addPass(new Kp(this.camera, ...r));
        } else this.effectComposer.addPass(this.renderPass), (KS || Ho) && this._initSmaa();
        if (t) return t;
    }
    reinit() {
        if (!this.renderer) return Promise.all([]);
        this.effectComposer = new _A(this.renderer), this._initPasses();
    }
    init({ renderer: t , camera: r , scene: n  }) {
        this.renderer = t, this.scene = n, this.camera = r, this._initCopyPass(), this.reinit();
    }
    _initCopyPass() {
        if (this._savePass) return;
        let t = new B;
        this.renderer.getDrawingBufferSize(t), this._rt = new mt(t.x, t.y, {
            depthBuffer: !1,
            stencilBuffer: !1,
            wrapS: Ia,
            wrapT: Ia
        }), this._rt.samples = this.renderer.capabilities.isWebGL2 ? 4 : 0, this._savePass = new Yv(this._rt, !1), this._savePass.renderToScreen = !1;
    }
    get renderToScreen() {
        return this._renderToScreen;
    }
    set renderToScreen(t) {
        var n, s;
        let r = this.effectComposer;
        !r || (t === !0 ? ((n = this.renderer) != null && n.capabilities.isWebGL2 && (r.multisampling = 0), r.removePass(this._savePass), r.passes[r.passes.length - 1].renderToScreen = !0, r.autoRenderToScreen = !0) : (((s = this.renderer) == null ? void 0 : s.capabilities.isWebGL2) && !this._hasSmaa && (r.multisampling = 4), r.autoRenderToScreen = !1, r.passes[r.passes.length - 1].renderToScreen = !1, this._savePass.renderToScreen = !1, this.enabled || (this._savePass.needsDepthTexture = !0), r.addPass(this._savePass)), this._renderToScreen = t);
    }
    get texture() {
        return this._rt && this._rt.texture;
    }
    get renderTarget() {
        return this._rt;
    }
    fromJSON(t) {
        t && (Object.keys(t).forEach((r)=>{
            let n = t[r], s = this.effects.get(r);
            Object.keys(n).forEach((o)=>{
                s[o] = n[o];
            });
        }), this.enabled = t.enabled);
    }
    toJSON() {
        let t = {};
        return this.effects.forEach((r, n)=>{
            t[n] = r.toJSON();
        }, t), ie({
            enabled: this.enabled
        }, t);
    }
    render() {
        var t;
        (t = this.effectComposer) == null || t.render(this.clock.getDelta());
    }
    setScissor(t, r, n, s) {
        if (!this.effectComposer || !this.renderer) return;
        t instanceof Je ? (this.effectComposer.inputBuffer.scissor.set(t.x, t.y, t.z, t.w), this.effectComposer.outputBuffer.scissor.set(t.x, t.y, t.z, t.w)) : (this.effectComposer.inputBuffer.scissor.set(t, r, n, s), this.effectComposer.outputBuffer.scissor.set(t, r, n, s));
        let o = this.renderer.getPixelRatio();
        this.effectComposer.inputBuffer.scissor.multiplyScalar(o), this.effectComposer.outputBuffer.scissor.multiplyScalar(o), this.renderer.setScissor(t, r, n, s);
    }
    setScissorTest(t) {
        !this.effectComposer || !this.renderer || (this.effectComposer.inputBuffer.scissorTest = t, this.effectComposer.outputBuffer.scissorTest = t, this.renderer.setScissorTest(t));
    }
    setViewport(t, r, n, s) {
        !this.effectComposer || (t instanceof Je ? (this.effectComposer.inputBuffer.viewport.copy(t), this.effectComposer.outputBuffer.viewport.copy(t)) : (this.effectComposer.inputBuffer.viewport.set(t, r, n, s), this.effectComposer.outputBuffer.viewport.set(t, r, n, s)));
    }
    resize(t, r, n) {
        var s, o;
        if ((s = this.effectComposer) == null || s.setSize(t, r, n), this._rt) {
            let a = ((o = this.renderer) == null ? void 0 : o.getPixelRatio()) || window.devicePixelRatio;
            this._rt.setSize(t * a, r * a);
        }
    }
    dispose() {
        var t;
        this._listeners = void 0, (t = this.effectComposer) == null || t.dispose();
    }
};
var Zp = class extends yu {
    constructor(t, r){
        super(t, r);
        this.postprocessing = new xu;
        this.initPostprocessing(t.postprocessing);
    }
    resetAfterClear(t, r) {
        super.resetAfterClear(t, r), this.initPostprocessing(t.postprocessing);
    }
    initPostprocessing(t) {
        let s = t, { enabled: r  } = s, n = Eu(s, [
            "enabled"
        ]);
        for (let o of Object.entries(n)){
            let a = o[1], l = this.postprocessing.effects.get(o[0]);
            if (l) {
                l.enabled = a.enabled;
                for (let [c, h] of Object.entries(a))l[c] = h;
            }
        }
        this.postprocessing.enabled = r, this.postprocessing.reinit();
    }
    dispose() {
        super.dispose(), this.postprocessing.dispose();
    }
    switchActiveCamera(t) {
        super.switchActiveCamera(t), this.postprocessing && (this.postprocessing.camera = t);
    }
};
var Kv = new WeakMap, $p = class extends cn {
    constructor(e){
        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        };
    }
    setDecoderPath(e) {
        return this.decoderPath = e, this;
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e, this;
    }
    setWorkerLimit(e) {
        return this.workerLimit = e, this;
    }
    load(e, t, r, n) {
        let s = new as(this.manager);
        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (o)=>{
            let a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(t).catch(n);
        }, r, n);
    }
    decodeDracoFile(e, t, r, n) {
        let s = {
            attributeIDs: r || this.defaultAttributeIDs,
            attributeTypes: n || this.defaultAttributeTypes,
            useUniqueIDs: !!r
        };
        this.decodeGeometry(e, s).then(t);
    }
    decodeGeometry(e, t) {
        for(let l16 in t.attributeTypes){
            let c = t.attributeTypes[l16];
            c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l16] = c.name);
        }
        let r = JSON.stringify(t);
        if (Kv.has(e)) {
            let l = Kv.get(e);
            if (l.key === r) return l.promise;
            if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
        }
        let n, s = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(s, o).then((l)=>(n = l, new Promise((c, h)=>{
                n._callbacks[s] = {
                    resolve: c,
                    reject: h
                }, n.postMessage({
                    type: "decode",
                    id: s,
                    taskConfig: t,
                    buffer: e
                }, [
                    e
                ]);
            }))
        ).then((l)=>this._createGeometry(l.geometry)
        );
        return a.catch(()=>!0
        ).then(()=>{
            n && s && this._releaseTask(n, s);
        }), Kv.set(e, {
            key: r,
            promise: a
        }), a;
    }
    _createGeometry(e) {
        let t = new Le;
        e.index && t.setIndex(new Ve(e.index.array, 1));
        for(let r = 0; r < e.attributes.length; r++){
            let n = e.attributes[r], s = n.name, o = n.array, a = n.itemSize;
            t.setAttribute(s, new Ve(o, a));
        }
        return t;
    }
    _loadLibrary(e, t) {
        let r = new as(this.manager);
        return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((n, s)=>{
            r.load(e, n, void 0, s);
        });
    }
    preload() {
        return this._initDecoder(), this;
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        let e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((r)=>{
            let n = r[0];
            e || (this.decoderConfig.wasmBinary = r[1]);
            let s = fz.toString(), o = [
                "/* draco decoder */",
                n,
                "",
                "/* worker */",
                s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
            ].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([
                o
            ]));
        }), this.decoderPending;
    }
    _getWorker(e, t) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                let n = new Worker(this.workerSourceURL);
                n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), n.onmessage = function(s) {
                    let o = s.data;
                    switch(o.type){
                        case "decode":
                            n._callbacks[o.id].resolve(o);
                            break;
                        case "error":
                            n._callbacks[o.id].reject(o);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
                    }
                }, this.workerPool.push(n);
            } else this.workerPool.sort(function(n, s) {
                return n._taskLoad > s._taskLoad ? -1 : 1;
            });
            let r = this.workerPool[this.workerPool.length - 1];
            return r._taskCosts[e] = t, r._taskLoad += t, r;
        });
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
    }
    debug() {
        console.log("Task load: ", this.workerPool.map((e)=>e._taskLoad
        ));
    }
    dispose() {
        for(let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate();
        return this.workerPool.length = 0, this;
    }
};
function fz() {
    let i, e;
    onmessage = function(o) {
        let a = o.data;
        switch(a.type){
            case "init":
                i = a.decoderConfig, e = new Promise(function(h) {
                    i.onModuleLoaded = function(u) {
                        h({
                            draco: u
                        });
                    }, DracoDecoderModule(i);
                });
                break;
            case "decode":
                let l = a.buffer, c = a.taskConfig;
                e.then((h)=>{
                    let u = h.draco, f = new u.Decoder, d = new u.DecoderBuffer;
                    d.Init(new Int8Array(l), l.byteLength);
                    try {
                        let p = t(u, f, d, c), m = p.attributes.map((g)=>g.array.buffer
                        );
                        p.index && m.push(p.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: a.id,
                            geometry: p
                        }, m);
                    } catch (p) {
                        console.error(p), self.postMessage({
                            type: "error",
                            id: a.id,
                            error: p.message
                        });
                    } finally{
                        u.destroy(d), u.destroy(f);
                    }
                });
                break;
        }
    };
    function t(o, a, l, c) {
        let h = c.attributeIDs, u = c.attributeTypes, f, d, p = a.GetEncodedGeometryType(l);
        if (p === o.TRIANGULAR_MESH) f = new o.Mesh, d = a.DecodeBufferToMesh(l, f);
        else if (p === o.POINT_CLOUD) f = new o.PointCloud, d = a.DecodeBufferToPointCloud(l, f);
        else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!d.ok() || f.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
        let m = {
            index: null,
            attributes: []
        };
        for(let g in h){
            let v = self[u[g]], y, w;
            if (c.useUniqueIDs) w = h[g], y = a.GetAttributeByUniqueId(f, w);
            else {
                if (w = a.GetAttributeId(f, o[h[g]]), w === -1) continue;
                y = a.GetAttribute(f, w);
            }
            m.attributes.push(n(o, a, f, g, v, y));
        }
        return p === o.TRIANGULAR_MESH && (m.index = r(o, a, f)), o.destroy(f), m;
    }
    function r(o, a, l) {
        let h = l.num_faces() * 3, u = h * 4, f = o._malloc(u);
        a.GetTrianglesUInt32Array(l, u, f);
        let d = new Uint32Array(o.HEAPF32.buffer, f, h).slice();
        return o._free(f), {
            array: d,
            itemSize: 1
        };
    }
    function n(o, a, l, c, h, u) {
        let f = u.num_components(), p = l.num_points() * f, m = p * h.BYTES_PER_ELEMENT, g = s(o, h), v = o._malloc(m);
        a.GetAttributeDataArrayForAllPoints(l, u, g, m, v);
        let y = new h(o.HEAPF32.buffer, v, p).slice();
        return o._free(v), {
            name: c,
            array: y,
            itemSize: f
        };
    }
    function s(o, a) {
        switch(a){
            case Float32Array:
                return o.DT_FLOAT32;
            case Int8Array:
                return o.DT_INT8;
            case Int16Array:
                return o.DT_INT16;
            case Int32Array:
                return o.DT_INT32;
            case Uint8Array:
                return o.DT_UINT8;
            case Uint16Array:
                return o.DT_UINT16;
            case Uint32Array:
                return o.DT_UINT32;
        }
    }
}
var vo;
function dz() {
    return vo || (vo = new $p, vo.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()), vo.decoderPending;
}
async function pz(i) {
    if (vo) {
        let e = {
            attributeIDs: vo.defaultAttributeIDs,
            attributeTypes: vo.defaultAttributeTypes,
            useUniqueIDs: !1
        }, t;
        try {
            t = await vo.decodeGeometry(new Int8Array(i).buffer, e);
        } catch (r18) {
            console.error(r18);
        }
        if (t) return {
            index: t.index ? {
                array: t.index.array
            } : void 0,
            attributes: Object.entries(t.attributes).map(([r, n])=>({
                    name: r,
                    itemSize: n.itemSize,
                    array: n.array
                })
            )
        };
    }
    return null;
}
async function zA(i) {
    let [e, t] = Ay(tp.deserialize(new Uint8Array(i))), r = [];
    e.scene.objects.traverse((n, s)=>{
        s.type === "Mesh" && s.geometry.type === "NonParametricGeometry" && s.geometry.data.draco !== void 0 && r.push(s);
    }), r.length && await dz();
    for (let n of r){
        let s = await pz(Ey(n.geometry.data.draco));
        if (s) {
            s.index && (n.geometry.data.index = {
                array: s.index.array,
                itemSize: 1,
                normalized: !1,
                type: "Uint32Array"
            });
            let o = {};
            s.attributes.forEach(({ name: a , array: l , itemSize: c  })=>{
                o[a] = {
                    array: l,
                    itemSize: c,
                    type: "Float32Array",
                    normalized: !1
                };
            }), n.geometry.data.attributes = o, n.geometry.data.draco = void 0;
        }
    }
    return t.result().data;
}
var jA = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: "normal",
    autoplay: !0,
    timelineOffset: 0,
    rewind: !0
}, tx = {
    duration: 1e3,
    delay: 0,
    endDelay: 0,
    easing: "easeOutElastic(1, .5)",
    round: 0
}, mz = [
    "translateX",
    "translateY",
    "translateZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "matrix3d"
], tm = {
    CSS: {},
    springs: {}
};
function ji(i, e, t) {
    return Math.min(Math.max(i, e), t);
}
function bu(i, e) {
    return i.indexOf(e) > -1;
}
function Zv(i, e) {
    return i.apply(null, e);
}
var Xe = {
    arr: function(i) {
        return Array.isArray(i);
    },
    obj: function(i) {
        return bu(Object.prototype.toString.call(i), "Object");
    },
    pth: function(i) {
        return Xe.obj(i) && i.hasOwnProperty("totalLength");
    },
    svg: function(i) {
        return i instanceof SVGElement;
    },
    inp: function(i) {
        return i instanceof HTMLInputElement;
    },
    dom: function(i) {
        return !("isNode" in i) && (i.nodeType || Xe.svg(i));
    },
    str: function(i) {
        return typeof i == "string";
    },
    fnc: function(i) {
        return typeof i == "function";
    },
    und: function(i) {
        return typeof i > "u";
    },
    hex: function(i) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(i);
    },
    rgb: function(i) {
        return /^rgb/.test(i);
    },
    hsl: function(i) {
        return /^hsl/.test(i);
    },
    col: function(i) {
        return Xe.hex(i) || Xe.rgb(i) || Xe.hsl(i);
    },
    key: function(i) {
        return !jA.hasOwnProperty(i) && !tx.hasOwnProperty(i) && i !== "targets" && i !== "keyframes";
    }
};
function qA(i) {
    var e = /\(([^)]+)\)/.exec(i);
    return e ? e[1].split(",").map(function(t) {
        return parseFloat(t);
    }) : [];
}
function YA(i, e) {
    var t = qA(i), r = ji(Xe.und(t[0]) ? 1 : t[0], .1, 100), n = ji(Xe.und(t[1]) ? 100 : t[1], .1, 100), s = ji(Xe.und(t[2]) ? 10 : t[2], .1, 100), o = ji(Xe.und(t[3]) ? 0 : t[3], .1, 100), a = Math.sqrt(n / r), l = s / (2 * Math.sqrt(n * r)), c = l < 1 ? a * Math.sqrt(1 - l * l) : 0, h = 1, u = l < 1 ? (l * a + -o) / c : -o + a;
    function f(p) {
        var m = e ? e * p / 1e3 : p;
        return l < 1 ? m = Math.exp(-m * l * a) * (h * Math.cos(c * m) + u * Math.sin(c * m)) : m = (h + u * m) * Math.exp(-m * a), p === 0 || p === 1 ? p : 1 - m;
    }
    function d() {
        var p = tm.springs[i];
        if (p) return p;
        for(var m = 1 / 6, g = 0, v = 0;;)if (g += m, f(g) === 1) {
            if (v++, v >= 16) break;
        } else v = 0;
        var y = g * m * 1e3;
        return tm.springs[i] = y, y;
    }
    return e ? f : d;
}
function gz(i) {
    return i === void 0 && (i = 10), function(e) {
        return Math.ceil(ji(e, 1e-6, 1) * i) * (1 / i);
    };
}
var yz = function() {
    var i = 11, e = 1 / (i - 1);
    function t(h, u) {
        return 1 - 3 * u + 3 * h;
    }
    function r(h, u) {
        return 3 * u - 6 * h;
    }
    function n(h) {
        return 3 * h;
    }
    function s(h, u, f) {
        return ((t(u, f) * h + r(u, f)) * h + n(u)) * h;
    }
    function o(h, u, f) {
        return 3 * t(u, f) * h * h + 2 * r(u, f) * h + n(u);
    }
    function a(h, u, f, d, p) {
        var m, g, v = 0;
        do g = u + (f - u) / 2, m = s(g, d, p) - h, m > 0 ? f = g : u = g;
        while (Math.abs(m) > 1e-7 && ++v < 10)
        return g;
    }
    function l(h, u, f, d) {
        for(var p = 0; p < 4; ++p){
            var m = o(u, f, d);
            if (m === 0) return u;
            var g = s(u, f, d) - h;
            u -= g / m;
        }
        return u;
    }
    function c(h, u, f, d) {
        if (!(0 <= h && h <= 1 && 0 <= f && f <= 1)) return;
        var p = new Float32Array(i);
        if (h !== u || f !== d) for(var m = 0; m < i; ++m)p[m] = s(m * e, h, f);
        function g(v) {
            for(var y = 0, w = 1, b = i - 1; w !== b && p[w] <= v; ++w)y += e;
            --w;
            var S = (v - p[w]) / (p[w + 1] - p[w]), T = y + S * e, A = o(T, h, f);
            return A >= .001 ? l(v, T, h, f) : A === 0 ? T : a(v, y, y + e, h, f);
        }
        return function(v) {
            return h === u && f === d || v === 0 || v === 1 ? v : s(g(v), u, d);
        };
    }
    return c;
}(), XA = function() {
    var i = {
        linear: function() {
            return function(r) {
                return r;
            };
        }
    }, e = {
        Sine: function() {
            return function(r) {
                return 1 - Math.cos(r * Math.PI / 2);
            };
        },
        Circ: function() {
            return function(r) {
                return 1 - Math.sqrt(1 - r * r);
            };
        },
        Back: function() {
            return function(r) {
                return r * r * (3 * r - 2);
            };
        },
        Bounce: function() {
            return function(r) {
                for(var n, s = 4; r < ((n = Math.pow(2, --s)) - 1) / 11;);
                return 1 / Math.pow(4, 3 - s) - 7.5625 * Math.pow((n * 3 - 2) / 22 - r, 2);
            };
        },
        Elastic: function(r, n) {
            r === void 0 && (r = 1), n === void 0 && (n = .5);
            var s = ji(r, 1, 10), o = ji(n, .1, 2);
            return function(a) {
                return a === 0 || a === 1 ? a : -s * Math.pow(2, 10 * (a - 1)) * Math.sin((a - 1 - o / (Math.PI * 2) * Math.asin(1 / s)) * (Math.PI * 2) / o);
            };
        }
    }, t = [
        "Quad",
        "Cubic",
        "Quart",
        "Quint",
        "Expo"
    ];
    return t.forEach(function(r, n) {
        e[r] = function() {
            return function(s) {
                return Math.pow(s, n + 2);
            };
        };
    }), Object.keys(e).forEach(function(r) {
        var n = e[r];
        i["easeIn" + r] = n, i["easeOut" + r] = function(s, o) {
            return function(a) {
                return 1 - n(s, o)(1 - a);
            };
        }, i["easeInOut" + r] = function(s, o) {
            return function(a) {
                return a < .5 ? n(s, o)(a * 2) / 2 : 1 - n(s, o)(a * -2 + 2) / 2;
            };
        };
    }), i;
}();
function rx(i, e) {
    if (Xe.fnc(i)) return i;
    var t = i.split("(")[0], r = XA[t], n = qA(i);
    switch(t){
        case "spring":
            return YA(i, e);
        case "cubicBezier":
            return Zv(yz, n);
        case "steps":
            return Zv(gz, n);
        default:
            return Zv(r, n);
    }
}
function QA(i) {
    try {
        var e = document.querySelectorAll(i);
        return e;
    } catch  {
        return;
    }
}
function rm(i, e) {
    for(var t = i.length, r = arguments.length >= 2 ? arguments[1] : void 0, n = [], s = 0; s < t; s++)if (s in i) {
        var o = i[s];
        e.call(r, o, s, i) && n.push(o);
    }
    return n;
}
function nm(i) {
    return i.reduce(function(e, t) {
        return e.concat(Xe.arr(t) ? nm(t) : t);
    }, []);
}
function GA(i) {
    return Xe.arr(i) ? i : (Xe.str(i) && (i = QA(i) || i), i instanceof NodeList || i instanceof HTMLCollection ? [].slice.call(i) : [
        i
    ]);
}
function nx(i, e) {
    return i.some(function(t) {
        return t === e;
    });
}
function ix(i) {
    var e = {};
    for(var t in i)e[t] = i[t];
    return e;
}
function $v(i, e) {
    var t = ix(i);
    for(var r in i)t[r] = e.hasOwnProperty(r) ? e[r] : i[r];
    return t;
}
function im(i, e) {
    var t = ix(i);
    for(var r in e)t[r] = Xe.und(i[r]) ? e[r] : i[r];
    return t;
}
function vz(i) {
    var e = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(i);
    return e ? "rgba(" + e[1] + ",1)" : i;
}
function xz(i) {
    var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, t = i.replace(e, function(a, l, c, h) {
        return l + l + c + c + h + h;
    }), r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t), n = parseInt(r[1], 16), s = parseInt(r[2], 16), o = parseInt(r[3], 16);
    return "rgba(" + n + "," + s + "," + o + ",1)";
}
function bz(i) {
    var e = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(i) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(i), t = parseInt(e[1], 10) / 360, r = parseInt(e[2], 10) / 100, n = parseInt(e[3], 10) / 100, s = e[4] || 1;
    function o(f, d, p) {
        return p < 0 && (p += 1), p > 1 && (p -= 1), p < 1 / 6 ? f + (d - f) * 6 * p : p < 0.5 ? d : p < 2 / 3 ? f + (d - f) * (2 / 3 - p) * 6 : f;
    }
    var a, l, c;
    if (r == 0) a = l = c = n;
    else {
        var h = n < .5 ? n * (1 + r) : n + r - n * r, u = 2 * n - h;
        a = o(u, h, t + 1 / 3), l = o(u, h, t), c = o(u, h, t - 1 / 3);
    }
    return "rgba(" + a * 255 + "," + l * 255 + "," + c * 255 + "," + s + ")";
}
function wz(i) {
    if (Xe.rgb(i)) return vz(i);
    if (Xe.hex(i)) return xz(i);
    if (Xe.hsl(i)) return bz(i);
}
function vs(i) {
    var e = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(i);
    if (e) return e[1];
}
function Sz(i) {
    if (bu(i, "translate") || i === "perspective") return "px";
    if (bu(i, "rotate") || bu(i, "skew")) return "deg";
}
function ex(i, e) {
    return Xe.fnc(i) ? i(e.target, e.id, e.total) : i;
}
function qi(i, e) {
    return i.getAttribute(e);
}
function sx(i, e, t) {
    var r = vs(e);
    if (nx([
        t,
        "deg",
        "rad",
        "turn"
    ], r)) return e;
    var n = tm.CSS[e + t];
    if (!Xe.und(n)) return n;
    var s = 100, o = document.createElement(i.tagName), a = i.parentNode && i.parentNode !== document ? i.parentNode : document.body;
    a.appendChild(o), o.style.position = "absolute", o.style.width = s + t;
    var l = s / o.offsetWidth;
    a.removeChild(o);
    var c = l * parseFloat(e);
    return tm.CSS[e + t] = c, c;
}
function JA(i, e, t) {
    if (e in i.style) {
        var r = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), n = i.style[e] || getComputedStyle(i).getPropertyValue(r) || "0";
        return t ? sx(i, n, t) : n;
    }
}
function ox(i, e) {
    if (Xe.dom(i) && !Xe.inp(i) && (qi(i, e) || Xe.svg(i) && i[e])) return "attribute";
    if (Xe.dom(i) && nx(mz, e)) return "transform";
    if (Xe.dom(i) && e !== "transform" && JA(i, e)) return "css";
    if (i[e] != null) return "object";
}
function KA(i) {
    if (!!Xe.dom(i)) {
        for(var e = i.style.transform || "", t = /(\w+)\(([^)]*)\)/g, r = new Map, n; n = t.exec(e);)r.set(n[1], n[2]);
        return r;
    }
}
function Mz(i, e, t, r) {
    var n = bu(e, "scale") ? 1 : 0 + Sz(e), s = KA(i).get(e) || n;
    return t && (t.transforms.list.set(e, s), t.transforms.last = e), r ? sx(i, s, r) : s;
}
function ax(i, e, t, r) {
    switch(ox(i, e)){
        case "transform":
            return Mz(i, e, r, t);
        case "css":
            return JA(i, e, t);
        case "attribute":
            return qi(i, e);
        default:
            return i[e] || 0;
    }
}
function lx(i, e) {
    var t = /^(\*=|\+=|-=)/.exec(i);
    if (!t) return i;
    var r = vs(i) || 0, n = parseFloat(e), s = parseFloat(i.replace(t[0], ""));
    switch(t[0][0]){
        case "+":
            return n + s + r;
        case "-":
            return n - s + r;
        case "*":
            return n * s + r;
    }
}
function ZA(i, e) {
    if (Xe.col(i)) return wz(i);
    if (/\s/g.test(i)) return i;
    var t = vs(i), r = t ? i.substr(0, i.length - t.length) : i;
    return e ? r + e : r;
}
function cx(i, e) {
    return Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2));
}
function Az(i) {
    return Math.PI * 2 * qi(i, "r");
}
function Tz(i) {
    return qi(i, "width") * 2 + qi(i, "height") * 2;
}
function Ez(i) {
    return cx({
        x: qi(i, "x1"),
        y: qi(i, "y1")
    }, {
        x: qi(i, "x2"),
        y: qi(i, "y2")
    });
}
function $A(i) {
    for(var e = i.points, t = 0, r, n = 0; n < e.numberOfItems; n++){
        var s = e.getItem(n);
        n > 0 && (t += cx(r, s)), r = s;
    }
    return t;
}
function _z(i) {
    var e = i.points;
    return $A(i) + cx(e.getItem(e.numberOfItems - 1), e.getItem(0));
}
function eT(i) {
    if (i.getTotalLength) return i.getTotalLength();
    switch(i.tagName.toLowerCase()){
        case "circle":
            return Az(i);
        case "rect":
            return Tz(i);
        case "line":
            return Ez(i);
        case "polyline":
            return $A(i);
        case "polygon":
            return _z(i);
    }
}
function Cz(i) {
    var e = eT(i);
    return i.setAttribute("stroke-dasharray", e), e;
}
function Dz(i) {
    for(var e = i.parentNode; Xe.svg(e) && Xe.svg(e.parentNode);)e = e.parentNode;
    return e;
}
function tT(i, e) {
    var t = e || {}, r = t.el || Dz(i), n = r.getBoundingClientRect(), s = qi(r, "viewBox"), o = n.width, a = n.height, l = t.viewBox || (s ? s.split(" ") : [
        0,
        0,
        o,
        a
    ]);
    return {
        el: r,
        viewBox: l,
        x: l[0] / 1,
        y: l[1] / 1,
        w: o / l[2],
        h: a / l[3]
    };
}
function Pz(i, e) {
    var t = Xe.str(i) ? QA(i)[0] : i, r = e || 100;
    return function(n) {
        return {
            property: n,
            el: t,
            svg: tT(t),
            totalLength: eT(t) * (r / 100)
        };
    };
}
function Lz(i, e) {
    function t(a) {
        a === void 0 && (a = 0);
        var l = e + a >= 1 ? e + a : 0;
        return i.el.getPointAtLength(l);
    }
    var r = tT(i.el, i.svg), n = t(), s = t(-1), o = t(1);
    switch(i.property){
        case "x":
            return (n.x - r.x) * r.w;
        case "y":
            return (n.y - r.y) * r.h;
        case "angle":
            return Math.atan2(o.y - s.y, o.x - s.x) * 180 / Math.PI;
    }
}
function kA(i, e) {
    var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g, r = ZA(Xe.pth(i) ? i.totalLength : i, e) + "";
    return {
        original: r,
        numbers: r.match(t) ? r.match(t).map(Number) : [
            0
        ],
        strings: Xe.str(i) || e ? r.split(t) : []
    };
}
function rT(i) {
    var e = i ? nm(Xe.arr(i) ? i.map(GA) : GA(i)) : [];
    return rm(e, function(t, r, n) {
        return n.indexOf(t) === r;
    });
}
function nT(i) {
    var e = rT(i);
    return e.map(function(t, r) {
        return {
            target: t,
            id: r,
            total: e.length,
            transforms: {
                list: KA(t)
            }
        };
    });
}
function Iz(i, e) {
    var t = ix(e);
    if (/^spring/.test(t.easing) && (t.duration = YA(t.easing)), Xe.arr(i)) {
        var r = i.length, n = r === 2 && !Xe.obj(i[0]);
        n ? i = {
            value: i
        } : Xe.fnc(e.duration) || (t.duration = e.duration / r);
    }
    var s = Xe.arr(i) ? i : [
        i
    ];
    return s.map(function(o, a) {
        var l = Xe.obj(o) && !Xe.pth(o) ? o : {
            value: o
        };
        return Xe.und(l.delay) && (l.delay = a ? 0 : e.delay), Xe.und(l.endDelay) && (l.endDelay = a === s.length - 1 ? e.endDelay : 0), l;
    }).map(function(o) {
        return im(o, t);
    });
}
function Rz(i) {
    for(var e = rm(nm(i.map(function(s) {
        return Object.keys(s);
    })), function(s) {
        return Xe.key(s);
    }).reduce(function(s, o) {
        return s.indexOf(o) < 0 && s.push(o), s;
    }, []), t = {}, r = function(s) {
        var o = e[s];
        t[o] = i.map(function(a) {
            var l = {};
            for(var c in a)Xe.key(c) ? c == o && (l.value = a[c]) : l[c] = a[c];
            return l;
        });
    }, n = 0; n < e.length; n++)r(n);
    return t;
}
function Bz(i, e) {
    var t = [], r = e.keyframes;
    r && (e = im(Rz(r), e));
    for(var n in e)Xe.key(n) && t.push({
        name: n,
        tweens: Iz(e[n], i)
    });
    return t;
}
function Nz(i, e) {
    var t = {};
    for(var r in i){
        var n = ex(i[r], e);
        Xe.arr(n) && (n = n.map(function(s) {
            return ex(s, e);
        }), n.length === 1 && (n = n[0])), t[r] = n;
    }
    return t.duration = parseFloat(t.duration), t.delay = parseFloat(t.delay), t;
}
function Oz(i, e) {
    var t;
    return i.tweens.map(function(r) {
        var n = Nz(r, e), s = n.value, o = Xe.arr(s) ? s[1] : s, a = vs(o), l = ax(e.target, i.name, a, e), c = t ? t.to.original : l, h = Xe.arr(s) ? s[0] : c, u = vs(h) || vs(l), f = a || u;
        return Xe.und(o) && (o = c), n.from = kA(h, f), n.to = kA(lx(o, h), f), n.start = t ? t.end : 0, n.end = n.start + n.delay + n.duration + n.endDelay, n.easing = rx(n.easing, n.duration), n.isPath = Xe.pth(s), n.isColor = Xe.col(n.from.original), n.isColor && (n.round = 1), t = n, n;
    });
}
var iT = {
    css: function(i, e, t) {
        return i.style[e] = t;
    },
    attribute: function(i, e, t) {
        return i.setAttribute(e, t);
    },
    object: function(i, e, t) {
        return i[e] = t;
    },
    transform: function(i, e, t, r, n) {
        if (r.list.set(e, t), e === r.last || n) {
            var s = "";
            r.list.forEach(function(o, a) {
                s += a + "(" + o + ") ";
            }), i.style.transform = s;
        }
    }
};
function sT(i, e) {
    var t = nT(i);
    t.forEach(function(r) {
        for(var n in e){
            var s = ex(e[n], r), o = r.target, a = vs(s), l = ax(o, n, a, r), c = a || vs(l), h = lx(ZA(s, c), l), u = ox(o, n);
            iT[u](o, n, h, r.transforms, !0);
        }
    });
}
function Fz(i, e) {
    var t = ox(i.target, e.name);
    if (t) {
        var r = Oz(e, i), n = r[r.length - 1];
        return {
            type: t,
            property: e.name,
            animatable: i,
            tweens: r,
            duration: n.end,
            delay: r[0].delay,
            endDelay: n.endDelay
        };
    }
}
function Uz(i, e) {
    return rm(nm(i.map(function(t) {
        return e.map(function(r) {
            return Fz(t, r);
        });
    })), function(t) {
        return !Xe.und(t);
    });
}
function oT(i, e) {
    var t = i.length, r = function(s) {
        return s.timelineOffset ? s.timelineOffset : 0;
    }, n = {};
    return n.duration = t ? Math.max.apply(Math, i.map(function(s) {
        return r(s) + s.duration;
    })) : e.duration, n.delay = t ? Math.min.apply(Math, i.map(function(s) {
        return r(s) + s.delay;
    })) : e.delay, n.endDelay = t ? n.duration - Math.max.apply(Math, i.map(function(s) {
        return r(s) + s.duration - s.endDelay;
    })) : e.endDelay, n;
}
var VA = 0;
function zz(i) {
    var e = $v(jA, i), t = $v(tx, i), r = Bz(t, i), n = nT(i.targets), s = Uz(n, r), o = oT(s, t), a = VA;
    return VA++, im(e, {
        id: a,
        children: [],
        animatables: n,
        animations: s,
        duration: o.duration,
        delay: o.delay,
        endDelay: o.endDelay
    });
}
var Tn = [], HA = [], em, Gz = function() {
    function i() {
        em = requestAnimationFrame(e);
    }
    function e(t) {
        var r = Tn.length;
        if (r) {
            for(var n = 0; n < r;){
                var s = Tn[n];
                if (!s.paused) s.tick(t);
                else {
                    var o = Tn.indexOf(s);
                    o > -1 && (Tn.splice(o, 1), r = Tn.length);
                }
                n++;
            }
            i();
        } else em = cancelAnimationFrame(em);
    }
    return i;
}();
function kz() {
    document.hidden ? (Tn.forEach(function(i) {
        return i.pause();
    }), HA = Tn.slice(0), Sr.running = Tn = []) : HA.forEach(function(i) {
        return i.play();
    });
}
typeof document < "u" && document.addEventListener("visibilitychange", kz);
function Sr(i) {
    i === void 0 && (i = {});
    var e = 0, t = 0, r = 0, n, s = 0, o = null;
    function a(w) {
        var b = window.Promise && new Promise(function(S) {
            return o = S;
        });
        return w.finished = b, b;
    }
    var l = zz(i), c = a(l);
    function h() {
        var w = l.direction;
        w !== "alternate" && (l.direction = w !== "normal" ? "normal" : "reverse"), l.reversed = !l.reversed, n.forEach(function(b) {
            return b.reversed = l.reversed;
        });
    }
    function u(w) {
        return l.reversed ? l.duration - w : w;
    }
    function f() {
        e = 0, t = u(l.currentTime) * (1 / Sr.speed);
    }
    function d(w, b) {
        b && b.seek(w - b.timelineOffset);
    }
    function p(w) {
        if (l.reversePlayback) for(var S = s; S--;)d(w, n[S]);
        else for(var b = 0; b < s; b++)d(w, n[b]);
    }
    function m(w) {
        var b = 0, S = l.animations, T = S.length;
        for(l.reversePlayback === !0 && l.rewind === !1 && (w = l.duration - w); b < T;){
            var A = S[b], x = A.animatable, E = A.tweens, _ = E.length - 1, C = E[_];
            _ && (C = rm(E, function(oe) {
                return w < oe.end;
            })[0] || C);
            for(var I = ji(w - C.start - C.delay, 0, C.duration) / C.duration, N = isNaN(I) ? 1 : C.easing(I), R = C.to.strings, k = C.round, G = [], te = C.to.numbers.length, Q = void 0, Y = 0; Y < te; Y++){
                var F = void 0;
                if (l.reversePlayback === !0 && l.rewind === !1) var z = C.to.numbers[Y], O = C.from.numbers[Y] || 0;
                else var O = C.to.numbers[Y], z = C.from.numbers[Y] || 0;
                C.isPath ? F = Lz(C.value, N * O) : F = z + N * (O - z), k && (C.isColor && Y > 2 || (F = Math.round(F * k) / k)), G.push(F);
            }
            var j = R.length;
            if (!j) Q = G[0];
            else {
                Q = R[0];
                for(var q = 0; q < j; q++){
                    var J = R[q], W = R[q + 1], ge = G[q];
                    isNaN(ge) || (W ? Q += ge + W : Q += ge + " ");
                }
            }
            iT[A.type](x.target, A.property, Q, x.transforms), A.currentValue = Q, b++;
        }
    }
    function g(w) {
        l[w] && !l.passThrough && l[w](l);
    }
    function v() {
        l.remaining && l.remaining !== !0 && l.remaining--;
    }
    function y(w) {
        var b = l.duration, S = l.delay, T = b - l.endDelay, A = u(w);
        l.progress = ji(A / b * 100, 0, 100), l.reversePlayback = A < l.currentTime, n && p(A), !l.began && l.currentTime >= 0 && (l.began = !0, g("begin")), !l.loopBegan && l.currentTime > 0 && (l.loopBegan = !0, g("loopBegin")), A <= S && l.currentTime !== 0 && m(0), (A >= T && l.currentTime !== b || !b) && m(b), A > S && A < T ? (l.changeBegan || (l.changeBegan = !0, l.changeCompleted = !1, g("changeBegin")), g("change"), m(A)) : l.changeBegan ? (l.changeCompleted = !0, l.changeBegan = !1, g("change"), g("changeComplete")) : l.began && A > T && (g("change"), g("changeComplete")), l.currentTime = ji(A, 0, b), l.began && g("update"), w >= b && (t = 0, v(), l.remaining ? (e = r, g("loopComplete"), l.loopBegan = !1, l.direction === "alternate" && h()) : (l.paused = !0, l.completed || (l.completed = !0, g("loopComplete"), g("complete"), !l.passThrough && "Promise" in window && (o(), c = a(l)))));
    }
    return l.reset = function() {
        var w = l.direction;
        l.passThrough = !1, l.currentTime = 0, l.progress = 0, l.paused = !0, l.began = !1, l.loopBegan = !1, l.changeBegan = !1, l.completed = !1, l.changeCompleted = !1, l.reversePlayback = !1, l.reversed = w === "reverse", l.remaining = l.loop, n = l.children, s = n.length;
        for(var b = s; b--;)l.children[b].reset();
        (l.reversed && l.loop !== !0 || w === "alternate" && l.loop === 1) && l.remaining++, m(l.reversed ? l.duration : 0);
    }, l.set = function(w, b) {
        return sT(w, b), l;
    }, l.tick = function(w) {
        r = w, e || (e = r), y((r + (t - e)) * Sr.speed);
    }, l.seek = function(w) {
        y(u(w));
    }, l.pause = function() {
        l.paused = !0, f();
    }, l.play = function() {
        !l.paused || (l.completed && l.reset(), l.paused = !1, Tn.push(l), f(), em || Gz());
    }, l.reverse = function() {
        h(), l.completed = !l.reversed, f();
    }, l.restart = function() {
        l.reset(), l.play();
    }, l.reset(), l.autoplay && l.play(), l;
}
function WA(i, e) {
    for(var t = e.length; t--;)nx(i, e[t].animatable.target) && e.splice(t, 1);
}
function Vz(i) {
    for(var e = rT(i), t = Tn.length; t--;){
        var r = Tn[t], n = r.animations, s = r.children;
        WA(e, n);
        for(var o = s.length; o--;){
            var a = s[o], l = a.animations;
            WA(e, l), !l.length && !a.children.length && s.splice(o, 1);
        }
        !n.length && !s.length && r.pause();
    }
}
function Hz(i, e) {
    e === void 0 && (e = {});
    var t = e.direction || "normal", r = e.easing ? rx(e.easing) : null, n = e.grid, s = e.axis, o = e.from || 0, a = o === "first", l = o === "center", c = o === "last", h = Xe.arr(i), u = parseFloat(h ? i[0] : i), f = h ? parseFloat(i[1]) : 0, d = vs(h ? i[1] : i) || 0, p = e.start || 0 + (h ? u : 0), m = [], g = 0;
    return function(v, y, w) {
        if (a && (o = 0), l && (o = (w - 1) / 2), c && (o = w - 1), !m.length) {
            for(var b = 0; b < w; b++){
                if (!n) m.push(Math.abs(o - b));
                else {
                    var S = l ? (n[0] - 1) / 2 : o % n[0], T = l ? (n[1] - 1) / 2 : Math.floor(o / n[0]), A = b % n[0], x = Math.floor(b / n[0]), E = S - A, _ = T - x, C = Math.sqrt(E * E + _ * _);
                    s === "x" && (C = -E), s === "y" && (C = -_), m.push(C);
                }
                g = Math.max.apply(Math, m);
            }
            r && (m = m.map(function(N) {
                return r(N / g) * g;
            })), t === "reverse" && (m = m.map(function(N) {
                return s ? N < 0 ? N * -1 : -N : Math.abs(g - N);
            }));
        }
        var I = h ? (f - u) / g : u;
        return p + I * (Math.round(m[y] * 100) / 100) + d;
    };
}
function Wz(i) {
    i === void 0 && (i = {});
    var e = Sr(i);
    return e.duration = 0, e.add = function(t, r) {
        var n = Tn.indexOf(e), s = e.children;
        n > -1 && Tn.splice(n, 1);
        function o(f) {
            f.passThrough = !0;
        }
        for(var a = 0; a < s.length; a++)o(s[a]);
        var l = im(t, $v(tx, i));
        l.targets = l.targets || i.targets;
        var c = e.duration;
        l.autoplay = !1, l.direction = e.direction, l.timelineOffset = Xe.und(r) ? c : lx(r, c), o(e), l.rewind = e.rewind, e.seek(l.timelineOffset);
        var h = Sr(l);
        o(h), s.push(h);
        var u = oT(s, i);
        return e.delay = u.delay, e.endDelay = u.endDelay, e.duration = u.duration, e.seek(0), e.reset(), e.autoplay && e.play(), e;
    }, e;
}
Sr.version = "3.2.0";
Sr.speed = 1;
Sr.running = Tn;
Sr.remove = Vz;
Sr.get = ax;
Sr.set = sT;
Sr.convertPx = sx;
Sr.path = Pz;
Sr.setDashoffset = Cz;
Sr.stagger = Hz;
Sr.timeline = Wz;
Sr.easing = rx;
Sr.penner = XA;
Sr.random = function(i, e) {
    return Math.floor(Math.random() * (e - i + 1)) + i;
};
var aT = Sr;
function lT(i, e, t) {
    var n, s;
    let r = i.cameraType === "OrthographicCamera" ? (n = e.orthographic) == null ? void 0 : n.zoom : (s = e.perspective) == null ? void 0 : s.zoom;
    if (r !== void 0) {
        let o = i.zoom;
        o !== r && t.push({
            change: (a)=>{
                i.zoom = et.lerp(o, r, a), i.updateProjectionMatrix();
            }
        });
    }
    if (e.targetOffset !== void 0) {
        let o = i.targetOffset, a = e.targetOffset;
        o !== a && t.push({
            change: (l)=>{
                i.targetOffset = et.lerp(o, a, l);
            }
        });
    }
}
function cT(i, e, t) {
    if (e.width !== void 0 && e.height !== void 0 && e.depth !== void 0) {
        let { width: r , height: n , depth: s  } = i.geometry.userData.parameters, o = [
            r,
            n,
            s
        ], a = [
            e.width,
            e.height,
            e.depth
        ];
        !br.isEqual(o, a) && !Lt(i) && t.push({
            change: (l)=>{
                let [c, h, u] = br.lerp(o, a, l);
                i.updateGeometry({
                    parameters: {
                        width: c,
                        height: h,
                        depth: u
                    }
                }), i.invalidateDownstreamBooleanData();
            }
        });
    }
}
function hT(i, e, t, r) {
    if (e.intensity !== void 0) {
        let n = i.intensity, s = e.intensity;
        n !== s && t.push({
            change: (o)=>{
                i.intensity = et.lerp(n, s, o);
            }
        });
    }
    if (e.color !== void 0) {
        let n = i.color.clone(), s = typeof e.color == "string" ? r.getColor(e.color) : e.color;
        if (!Ar.equals(n, s)) {
            let o = n.clone();
            i.color = o, t.push({
                change: (a)=>{
                    let { r: l , g: c , b: h  } = Ar.lerp(n, s, a);
                    o.setRGB(l, c, h);
                }
            });
        }
    }
}
function uT(i, e, t, r) {
    var s, o;
    let n = i.layersList.head;
    for(; n;){
        let a = e.layers.data(n.uuid);
        if (a && ((s = n.visible) != null ? s : !0) && ((o = a.visible) != null ? o : !0)) {
            let l = n.getNames().filter((c)=>!_M.some((h)=>c.includes(h)
                )
            );
            for (let c14 of l)try {
                let h = n.getValue(c14);
                if (c14 === "steps") Jz(n, a, c14, t);
                else if (c14 === "colors") Kz(n, a, c14, t);
                else if (typeof h == "number") jz(n, a, c14, t);
                else {
                    if (typeof h == "boolean") continue;
                    "isVector2" in h ? qz(n, a, c14, t) : "isVector3" in h ? Yz(n, a, c14, t) : "isColorA" in h ? Qz(n, a, c14, t, r) : "isColor" in h ? Xz(n, a, c14, t, r) : "isTexture" in h && Zz(n, a, c14, t);
                }
            } catch (h) {
                console.error(`animateMaterial: unexpected material layer for ${c14}`, h);
            }
        }
        n = n.next;
    }
}
function jz(i, e, t, r) {
    if (!i.hasValue(t) || !(t in e)) return;
    let n = i.getValue(t), s = e[t];
    n !== s && r.push({
        change: (o)=>{
            i.setValue(t, et.lerp(n, s, o));
        }
    });
}
function qz(i, e, t, r) {
    if (!i.hasValue(t) || !(t in e)) return;
    let n = i.getValue(t), s = n.toArray(), o = e[t];
    us.isEqual(s, o) || r.push({
        change: (a)=>{
            n.fromArray(us.lerp(s, o, a));
        }
    });
}
function Yz(i, e, t, r) {
    if (!i.hasValue(t) || !(t in e)) return;
    let n = i.getValue(t), s = n.toArray(), o = e[t];
    br.isEqual(s, o) || r.push({
        change: (a)=>{
            n.fromArray(br.lerp(s, o, a));
        }
    });
}
function Xz(i, e, t, r, n) {
    if (!i.hasValue(t) || !(t in e)) return;
    let s = i.getValue(t).clone(), o = e[t], a = typeof o == "string" ? n.getColor(o) : o;
    if (Ar.equals(s, a)) return;
    let l = s.clone();
    i.setValue(t, l), r.push({
        change: (c)=>{
            let { r: h , g: u , b: f  } = Ar.lerp(s, a, c);
            l.setRGB(h, u, f);
        }
    });
}
function Qz(i, e, t, r, n) {
    if (!i.hasValue(t) || !(t in e)) return;
    let s = i.getValue(t).clone(), o = e[t], a = typeof o == "string" ? n.getColor(o) : o;
    if (Ln.equals(s, a)) return;
    let l = s.clone();
    i.setValue(t, l), r.push({
        change: (c)=>{
            let { r: h , g: u , b: f , a: d  } = Ln.lerp(s, a, c);
            l.setRGBA(h, u, f, d);
        }
    });
}
function Jz(i, e, t = "steps", r) {
    if (!i.hasValue(t) || !(t in e)) return;
    let n = [
        ...i.getValue(t)
    ], s = e[t];
    for(let o = 0; o < n.length; ++o){
        let a = n[o], l = s[o];
        a !== l && r.push({
            change: (c)=>{
                n[o] = et.lerp(a, l, c), i.setValue("steps", n);
            }
        });
    }
}
function Kz(i, e, t = "colors", r) {
    if (!i.hasValue(t) || !(t in e)) return;
    let n = i.getValue(t), s = e[t];
    for(let o = 0; o < n.length; ++o){
        let a = n[o].toArray(), l = s[o];
        Ch.isEqual(a, l) || r.push({
            change: (c)=>{
                n[o].fromArray(Ch.lerp(a, l, c));
            }
        });
    }
}
function Zz(i, e, t = "texture", r) {
    if (!i.hasValue(t) || !(t in e)) return;
    let n = i.getValue("texture"), s = e[t], o = n.repeat.toArray(), a = n.offset.toArray(), l = s.repeat, c = s.offset;
    (!us.isEqual(o, l) || !us.isEqual(a, c)) && r.push({
        change: (h)=>{
            n.repeat.fromArray(us.lerp(o, l, h)), n.offset.fromArray(us.lerp(a, c, h)), n.updateMatrix(), n.needsUpdate = !0;
        }
    });
}
function fT(i, e, t, r) {
    if (r === 0) return t.copy(i);
    if (r === 1) return t.copy(e);
    let n = i.w * e.w + i.x * e.x + i.y * e.y + i.z * e.z;
    if (n >= 1) return t.copy(i);
    let s = 1 - n * n;
    if (s <= Number.EPSILON) {
        let h = 1 - r;
        return t.w = h * i.w + r * e.w, t.x = h * i.x + r * e.x, t.y = h * i.y + r * e.y, t.z = h * i.z + r * e.z, t.normalize(), t;
    }
    let o = Math.sqrt(s), a = Math.atan2(o, n), l = Math.sin((1 - r) * a) / o, c = Math.sin(r * a) / o;
    return t.w = i.w * l + e.w * c, t.x = i.x * l + e.x * c, t.y = i.y * l + e.y * c, t.z = i.z * l + e.z * c, t;
}
function dT(i, e, t = 0) {
    let r = Array.isArray(i.material) ? i.material[t] : i.material, n;
    return "materials" in e ? n = e.materials[t] : "material" in e && (n = e.material), [
        r,
        n
    ];
}
var hx = new M, ux = new M, pT = new zt, $z = new yn, eG = new Ae;
function mT(i, e, t, r) {
    if (t.position !== void 0) {
        let n = i.position.toArray(), s = t.position;
        br.isEqual(n, s) || r.push({
            change: (o)=>{
                i.position.fromArray(br.lerp(n, s, o)), i.updateMatrix(), er(i) && Lt(i.parent) && i.invalidateDownstreamBooleanData(!0);
            }
        });
    }
    if (t.scale !== void 0) {
        let n = i.scale.toArray(), s = t.scale;
        br.isEqual(n, s) || r.push({
            change: (o)=>{
                i.scale.fromArray(br.lerp(n, s, o)), i.updateMatrix(), er(i) && Lt(i.parent) && i.invalidateDownstreamBooleanData(!0);
            }
        });
    }
    tG(i, e, t, r), rG(i, t, r);
}
function tG(i, e, t, r) {
    if (t.rotation === void 0) return;
    let n = hx.setFromEuler(i.rotation).toArray(), s = t.rotation;
    if (br.isEqual(n, s)) return;
    if (br.sub(t.rotation, e ? e.rotation : i.rotation).every((a)=>Math.abs(a) < 2 * Math.PI
    )) {
        let a = i.quaternion.clone(), l = new zt().setFromEuler($z.set(t.rotation[0], t.rotation[1], t.rotation[2]));
        r.push({
            change: (c)=>{
                fT(a, l, i.quaternion, c), i.updateMatrix(), er(i) && Lt(i.parent) && i.invalidateDownstreamBooleanData(!0);
            }
        });
    } else r.push({
        change: (a)=>{
            i.rotation.setFromVector3(ux.fromArray(br.lerp(n, s, a))), i.updateMatrix(), er(i) && Lt(i.parent) && i.invalidateDownstreamBooleanData(!0);
        }
    });
}
function rG(i, e, t) {
    if (e.hiddenMatrix !== void 0 && !Pi.isEqual(i.hiddenMatrix.toArray(), e.hiddenMatrix)) {
        let r = new M, n = new zt, s = new M;
        i.hiddenMatrix.decompose(r, n, s);
        let o = new M, a = new zt, l = new M;
        eG.fromArray(e.hiddenMatrix).decompose(o, a, l), t.push({
            change: (c)=>{
                pT.slerpQuaternions(n, a, c), hx.lerpVectors(r, o, c), ux.lerpVectors(s, l, c), i.hiddenMatrix.compose(hx, pT, ux), er(i) && Lt(i.parent) && i.invalidateDownstreamBooleanData(!0);
            }
        });
    }
}
function gT(i, e, t, r) {
    let n = [];
    if ((i.visible || Lt(i.parent)) && mT(i, e == null ? void 0 : e.objectState, t.objectState, n), er(i)) {
        if ((i.visible || Lt(i.parent)) && "geometry" in t.objectState && cT(i, t.objectState.geometry, n), i.visible && ("material" in t.objectState || "materials" in t.objectState)) {
            let [s, o] = dT(i, t.objectState, i.selectedMaterial);
            s && o && typeof o != "string" && uT(s, o, n, r);
        }
    } else i.visible && O1(i) ? hT(i, t.objectState, n, r) : N1(i) && lT(i, t.objectState, n);
    return n.length ? {
        change: (s)=>{
            n.forEach((o)=>{
                o.change && o.change(s);
            });
        }
    } : void 0;
}
function nG(i, e, t) {
    switch(i){
        case 0:
            return "cubicBezier( 0, 0, 1, 1 )";
        case 1:
            return "cubicBezier( .25, .1, .25, 1 )";
        case 2:
            return "cubicBezier( .42, 0, 1, 1 )";
        case 3:
            return "cubicBezier( 0, 0, .58, 1 )";
        case 4:
            return "cubicBezier( .42, 0, .58, 1 )";
        case 5:
            let { control1: r , control2: n  } = e != null ? e : ie({}, Fd.defaultData);
            return `cubicBezier( ${r[0]}, ${r[1]}, ${n[0]}, ${n[1]} )`;
        case 6:
            let { mass: s , stiffness: o , damping: a , velocity: l  } = t != null ? t : ie({}, Od.defaultData);
            return `spring( ${s}, ${o}, ${a}, ${l} )`;
    }
}
var sm = class {
    constructor(e, t){
        this.object = e;
        this.sharedAssets = t;
        this.uuid = et.generateUUID();
        this.states = [];
        this.events = {};
        this.animatingState = 0;
        this._scrollCounter = null;
    }
    get fromState() {
        return this._fromState;
    }
    get animation() {
        return this._animation;
    }
    start() {
        this._animation !== void 0 && (this._animation.pause(), this._animation = void 0, this._scrollCounter = null), this.states.length > 1 && (this.states[0].execute(this.object, this.sharedAssets), this._toState = this.states[0], this._fromState = void 0);
    }
    end() {
        this._animation !== void 0 && (this._animation.pause(), this._animation = void 0), this.states.length > 1 && this.states[0].execute(this.object, this.sharedAssets), this._toState = void 0, this._fromState = void 0;
    }
    seek(e, t, r, n, s) {
        var o;
        this._scrollCounter === null && (this.animate(e, n, s), this._scrollCounter = 0), this._scrollCounter += t, this._scrollCounter = Math.min(Math.max(this._scrollCounter, 0), r), (o = this._animation) == null || o.seek(this._scrollCounter / r * (n.duration ? n.duration : 1));
    }
    animate(e, s, n) {
        var o = s, { autoplay: t = !0  } = o, r = Eu(o, [
            "autoplay"
        ]);
        var a, l, c, h, u, f;
        if (this._fromState === e && ((a = this._animation) == null ? void 0 : a.reversed)) {
            let d = (c = (l = this._animation) == null ? void 0 : l.currentTime) != null ? c : 0;
            (h = this._animation) == null || h.reset(), (u = this._animation) == null || u.seek(d), (f = this._animation) == null || f.play();
        } else if (this._toState !== e) {
            this._animation !== void 0 && this._animation.pause(), this.animatingState = 0, this._fromState = this._toState, this._toState = e;
            let d = gT(this.object, this._fromState, e, this.sharedAssets);
            if (!d) return;
            let p = {
                t: 0
            };
            this._animation = aT({
                autoplay: t,
                loop: r.repeat ? !0 : r.cycle ? 1 : !1,
                direction: r.cycle ? "alternate" : "normal",
                rewind: r.rewind,
                delay: r.delay,
                endDelay: r.delay,
                duration: r.duration,
                easing: nG(r.easing, r.cubicControls, r.springParameters),
                targets: p,
                t: 1,
                change: ()=>{
                    d.change && d.change(p.t), n != null && n.change && n.change(p.t);
                },
                loopBegin: (m)=>{
                    if (this.animatingState === 0) {
                        this.animatingState = 1;
                        return;
                    }
                    m.reversed ? (this._toState = this._fromState, this._fromState = e) : (this._fromState = this._toState, this._toState = e);
                }
            }), t && this._animation.finished.then(()=>{
                this._animation = void 0, this.animatingState = 0;
            });
        }
    }
    emitEvent(e) {
        var t;
        if (e === "keyDown" || e === "keyUp" || e === "mouseDown" || e === "mouseUp" || e === "mouseHover" || e === "scroll" || e === "start") {
            let r = this.events[e];
            if (r) {
                for (let n of r)if ("targets" in n) for (let { object: s , state: o , params: a  } of n.targets)(t = s.interaction) == null || t.animate(o, a);
            }
        }
    }
    emitEventReverse(e) {
        if (e === "keyDown" || e === "keyUp" || e === "mouseDown" || e === "mouseUp" || e === "mouseHover" || e === "scroll" || e === "start") {
            let t = this.events[e];
            if (t) {
                for (let r of t)if ("targets" in r) for (let { object: n , params: s  } of r.targets){
                    let o = n.interaction;
                    (o == null ? void 0 : o._fromState) !== void 0 && o.animate(o._fromState, s);
                }
            }
        }
    }
};
var gc = class {
    static create(e, t) {
        if (e.object) {
            let r = t.find(e.object);
            if (r != null && r.interaction) {
                let n = e.state ? r.interaction.states.find((s)=>s.uuid === e.state
                ) : r.interaction.states[0];
                if (n) {
                    let s = {
                        cycle: e.cycle,
                        rewind: e.rewind,
                        repeat: e.repeat,
                        duration: e.duration,
                        delay: e.delay,
                        easing: e.easing
                    };
                    if (e.easing === 5) {
                        let o = e;
                        s.cubicControls = {
                            control1: [
                                ...o.control1
                            ],
                            control2: [
                                ...o.control2
                            ]
                        };
                    }
                    if (e.easing === 6) {
                        let o = e;
                        s.springParameters = {
                            mass: o.mass,
                            stiffness: o.stiffness,
                            damping: o.damping,
                            velocity: o.velocity
                        };
                    }
                    return new gc(r, n, s);
                }
            }
        }
    }
    constructor(e, t, r){
        this.object = e, this.state = t, this.params = r;
    }
};
var fx = new Map, wu = {
    url: "head",
    time: 0,
    data: null,
    next: null,
    prev: null
}, yc = {
    url: "tail",
    time: 1 / 0,
    data: null,
    next: null,
    prev: null
};
wu.next = yc;
yc.prev = wu;
var yT = 0;
function co(i) {
    if (typeof i == "string") return i;
    let e = Date.now(), t = fx.get(i);
    return t === void 0 ? (t = {
        url: URL.createObjectURL(new Blob([
            i
        ])),
        data: i,
        time: e,
        next: null,
        prev: null
    }, fx.set(i, t)) : (t.time = e, t.prev.next = t.next, t.next.prev = t.prev), t.prev = yc.prev, t.next = yc, yc.prev.next = t, yc.prev = t, e - yT > 10000 && (yT = e + 1e3, setTimeout(()=>{
        let r = Date.now(), n = wu.next;
        for(; n.time < r - 10000;)URL.revokeObjectURL(n.url), fx.delete(n.data), n = n.next, n.prev = wu, wu.next = n;
    }, 900)), t.url;
}
var vT = new Yr, ra = class extends Wr {
}, om = class {
    constructor(e){
        this.materials = {};
        this.images = {};
        this.colors = {};
        this.transmissionRenderTarget = new mt(2048, 2048, {
            generateMipmaps: !0,
            minFilter: js,
            magFilter: ct,
            wrapS: Dr,
            wrapT: Dr
        }), this.transmissionRenderTarget.depthTexture = new oi(2048, 2048), this.reset(e);
    }
    reset(e) {
        for (let [t, r] of Object.entries(e.images))this.addImage(t, r.data);
        for (let [t13, r20] of Object.entries(e.colors))this.addColor(t13, r20);
        for (let [t14, r21] of Object.entries(e.materials))this.addMaterial(t14, Tv(r21, this));
    }
    get transmissionSamplerMap() {
        return this.transmissionRenderTarget.texture;
    }
    get transmissionDepthMap() {
        return this.transmissionRenderTarget.depthTexture;
    }
    addMaterial(e, t) {
        t.uuid = e, this.materials[e] = t;
    }
    deleteMaterial(e) {
        this.materials[e] && (this.materials[e].dispose(), delete this.materials[e]);
    }
    isSharedMaterial(e) {
        return e.uuid in this.materials || e === vT;
    }
    getMaterial(e) {
        let t = this.materials[e];
        return t;
    }
    getMaterialOrDeletedPlaceholder(e) {
        var t;
        return (t = this.materials[e]) != null ? t : vT;
    }
    getMaterials() {
        return this.materials;
    }
    addImage(e, t) {
        if (this.images[e]) return this.images[e].onload = ()=>{
            this.onImageLoad && this.onImageLoad();
        }, this.images[e].src = co(t), !0;
        {
            let r = new Image;
            return r.src = co(t), r.onload = ()=>{
                this.onImageLoad && this.onImageLoad();
            }, this.images[e] = r, !1;
        }
    }
    deleteImage(e) {
        this.images[e] && delete this.images[e];
    }
    getDefaultImage() {
        return this.images.image_0;
    }
    getImage(e) {
        return this.images[e];
    }
    getImages() {
        return this.images;
    }
    addColor(e, t) {
        return this.colors[e] ? ("a" in t ? this.colors[e].setRGBA(t.r, t.g, t.b, t.a) : this.colors[e].setRGBA(t.r, t.g, t.b, 1), !0) : ("a" in t ? this.colors[e] = new ra(t.r, t.g, t.b, t.a) : this.colors[e] = new ra(t.r, t.g, t.b, 1), !1);
    }
    updateColor(e, t) {
        var r, n, s, o;
        if (this.colors[e]) {
            let a = this.colors[e];
            return this.colors[e].r = (r = t.r) != null ? r : a.r, this.colors[e].g = (n = t.g) != null ? n : a.g, this.colors[e].b = (s = t.b) != null ? s : a.b, this.colors[e].a = (o = t.a) != null ? o : a.a, !0;
        }
        return !1;
    }
    deleteColor(e) {
        this.colors[e] && delete this.colors[e];
    }
    getColor(e) {
        return this.colors[e];
    }
    dispose() {
        Object.keys(this.materials).forEach((t)=>this.deleteMaterial(t)
        ), this.transmissionRenderTarget.depthTexture.dispose(), this.transmissionRenderTarget.dispose(), this.onImageLoad = void 0;
    }
};
function iG(i, e) {
    switch(i.type){
        case "noise":
            return e === "noiseType";
        case "texture":
            return e === "projection" || e === "axis" || e === "side";
        case "displace":
            return e === "noiseType";
        case "depth":
            return e === "num" || e === "smooth" || e === "isWorldSpace" || e === "gradientType";
        default:
            return !1;
    }
}
function dx(i, e, t, r, n) {
    var o;
    let s = !1;
    for (let [a, l] of Object.entries(i)){
        if (!a || l === void 0 || Np(a, t, n)) continue;
        t.visible = n.visible;
        let c = t.uniforms[`f${t.id}_${a}`];
        if (!!c) switch(c.constructor){
            case Ot:
                if (typeof l == "string") {
                    let h = e.getColor(l);
                    h && (c.value = h);
                    break;
                } else {
                    let h = l;
                    c.value instanceof ra ? c.value = new Wr(h.r, h.g, h.b, h.a) : c.setRGBA(h);
                    break;
                }
            case fi:
                if (typeof l == "string") {
                    let h = e.getColor(l);
                    h && (c.value = h);
                    break;
                } else {
                    let h = l;
                    c.value instanceof ra ? c.value = new Wr(h.r, h.g, h.b, h.a) : c.value.setRGBA(h.r, h.g, h.b, h.a);
                    break;
                }
            case Nr:
                {
                    let h = l;
                    c.value.setX(h[0]), c.value.setY(h[1]);
                    break;
                }
            case Or:
                {
                    let h = l;
                    c.value.setX(h[0]), c.value.setY(h[1]), c.value.setZ(h[2]);
                    break;
                }
            case jr:
                {
                    let h = l;
                    if ("image" in h) {
                        let u = h.iamge;
                        if (typeof u == "string") {
                            let f = e.getImage(u);
                            f && (c.value.image = f);
                        } else {
                            let f = new Image;
                            f.src = co(u.data), c.value.image = f;
                        }
                    }
                    "wrapping" in h && (c.value.wrapS = c.value.wrapT = h.wrapping), "repeat" in h && c.value.repeat.fromArray(h.repeat), "offset" in h && c.value.offset.fromArray(h.offset), c.value.needsUpdate = !0;
                    break;
                }
            case ps:
                l.forEach((h, u)=>{
                    c.value[u].setX(h[0]), c.value[u].setY(h[1]), c.value[u].setZ(h[2]), c.value[u].setW(h[3]);
                });
                break;
            default:
                s = s || iG(t, a), c.value = l;
                break;
        }
    }
    if (s && n) {
        let a = Bp({
            id: "0",
            fi: 0,
            data: n
        }, e);
        (o = r.userData.layers) == null || o.changeLayer(t.id, ie({}, a)), r.dispose(), r.needsUpdate = !0;
    }
}
var px = new M, xT = new Gr, bT = new Ae, Su = {
    type: "follow",
    normal: new M,
    raycaster: new io
}, vc;
((t)=>{
    function i(r) {
        if (r.type === 10) return {
            type: "follow"
        };
    }
    t.create = i;
    function e({ target: r , normal: n , raycaster: s , begin: o , change: a  }) {
        !r || !n || !s || (o && o("follow", r.uuid), xT.setFromNormalAndCoplanarPoint(n, r.getWorldPosition(px)), s.ray.intersectPlane(xT, px), r.position.copy(px), r.parent !== null && r.position.applyMatrix4(bT.copy(r.parent.matrixWorld).invert()), r.position.applyMatrix4(bT.copy(r.hiddenMatrix).invert()), r.updateMatrix(), er(r) && Lt(r.parent) && r.invalidateDownstreamBooleanData(!0), a && a());
    }
    t.listener = e;
})(vc || (vc = {}));
var mx = new M, wT = new Gr, Mu = {
    type: "lookAt",
    normal: new M,
    raycaster: new io
}, xc;
((t)=>{
    function i(r) {
        if (r.type === 9 && r.distance) return {
            type: "lookAt",
            distance: r.distance
        };
    }
    t.create = i;
    function e({ target: r , normal: n , raycaster: s , begin: o , change: a  }) {
        var c, h, u;
        if (!((h = (c = r == null ? void 0 : r.interaction) == null ? void 0 : c.events.lookAt) != null && h.length) || !n || !s) return;
        o && o("lookAt", r.uuid);
        let l = r.interaction.events.lookAt[0].distance;
        wT.set(n, -l), s.ray.intersectPlane(wT, mx), r.lookAt(mx), r.updateMatrix(), (u = r.interaction.animation) == null || u.finished.then(()=>{
            r.lookAt(mx), r.updateMatrix(), er(r) && Lt(r.parent) && r.invalidateDownstreamBooleanData(!0);
        }), er(r) && Lt(r.parent) && r.invalidateDownstreamBooleanData(!0), a && a();
    }
    t.listener = e;
})(xc || (xc = {}));
var gx = {
    type: "start"
}, bc;
((t)=>{
    function i(r) {
        if (r.type === 7) return {
            type: "start",
            targets: []
        };
    }
    t.create = i;
    function e({ target: r , begin: n , change: s  }) {
        var a, l;
        if (!((l = (a = r == null ? void 0 : r.interaction) == null ? void 0 : a.events.start) != null && l.length)) return;
        n && n("start", r.uuid);
        let o = {
            change: s
        };
        r.interaction.events.start.forEach((c)=>{
            c.targets.forEach(({ object: h , state: u , params: f  })=>{
                var d;
                return (d = h.interaction) == null ? void 0 : d.animate(u, f, o);
            });
        });
    }
    t.listener = e;
})(bc || (bc = {}));
var am = {
    type: "scroll"
}, wc;
((t)=>{
    function i(r) {
        if (!(r.type !== 11 || r.steps === void 0)) return {
            type: "scroll",
            targets: [],
            steps: r.steps
        };
    }
    t.create = i;
    function e({ target: r , deltaY: n , begin: s , change: o  }) {
        var c, h;
        if (!((h = (c = r == null ? void 0 : r.interaction) == null ? void 0 : c.events.scroll) != null && h.length) || !n) return;
        s && s("scroll", r.uuid);
        let a = {
            change: o
        }, l = n > 0 ? 1 : -1;
        r.interaction.events.scroll.forEach((u)=>{
            u.targets.forEach(({ object: f , state: d , params: p  })=>{
                var g;
                let m = xe(ie({}, p), {
                    autoplay: !1,
                    cycle: !1,
                    rewind: !1,
                    repeat: !1
                });
                (g = f.interaction) == null || g.seek(d, l, u.steps, m, a);
            });
        });
    }
    t.listener = e;
})(wc || (wc = {}));
var Mc = {
    type: "mouseHover"
}, Sc;
((t)=>{
    function i(r) {
        if (r.type === 2) return {
            type: "mouseHover",
            targets: []
        };
    }
    t.create = i;
    function e({ target: r , begin: n , change: s , enter: o  }) {
        var l, c;
        if (!((c = (l = r == null ? void 0 : r.interaction) == null ? void 0 : l.events.mouseHover) != null && c.length) || o === void 0) return;
        n && n("mouseHover", r.uuid);
        let a = {
            change: s
        };
        o ? r.interaction.events.mouseHover.forEach((h)=>{
            h.targets.forEach(({ object: u , state: f , params: d  })=>{
                var p;
                (p = u.interaction) == null || p.animate(f, d, a);
            });
        }) : r.interaction.events.mouseHover.forEach((h)=>{
            h.targets.forEach(({ object: u , params: f  })=>{
                let d = u.interaction;
                (d == null ? void 0 : d.fromState) !== void 0 && d.animate(d.fromState, f, a);
            });
        });
    }
    t.listener = e;
})(Sc || (Sc = {}));
var yx = {
    type: "mouseDown"
}, vx = {
    type: "mouseUp"
}, lm = {
    type: "keyDown"
}, cm = {
    type: "keyUp"
}, xs;
((t)=>{
    function i(r) {
        var o, a;
        let n, s;
        if (r.type === 0) n = {
            type: "mousedown"
        }, s = "mouseDown";
        else if (r.type === 1) n = {
            type: "mouseup"
        }, s = "mouseUp";
        else if (r.type === 5) {
            if (!r.key) return;
            n = {
                type: "keydown",
                key: r.key
            }, s = "keyDown";
        } else if (r.type === 6) {
            if (!r.key) return;
            n = {
                type: "keyup",
                key: r.key
            }, s = "keyUp";
        } else return;
        return {
            type: s,
            domEvent: n,
            targets: [],
            url: (o = r.url) != null ? o : void 0,
            toggle: (a = r.toggle) != null ? a : !1,
            enable: !1
        };
    }
    t.create = i;
    function e({ target: r , interactionEvents: n , type: s , begin: o , change: a  }) {
        var c;
        if (!r) return;
        n || (n = (c = r.interaction) == null ? void 0 : c.events[s]), o && o(s, r.uuid);
        let l = {
            change: a
        };
        n.forEach((h)=>{
            if (h.toggle) {
                h.enable = !h.enable;
                for (let { object: u , state: f , params: d  } of h.targets){
                    let p = u.interaction;
                    if (p !== void 0) {
                        let m = xe(ie({}, d), {
                            cycle: !1,
                            rewind: !1,
                            repeat: !1
                        });
                        h.enable ? p.animate(f, m, l) : p.fromState !== void 0 && p.animate(p.fromState, m, l);
                    }
                }
            } else h.targets.forEach(({ object: u , state: f , params: d  })=>{
                var p;
                return (p = u.interaction) == null ? void 0 : p.animate(f, d, l);
            });
            h.url && (Ho ? window.location.assign(h.url) : window.open(h.url, "_blank"));
        });
    }
    t.listener = e;
})(xs || (xs = {}));
function sG(i) {
    let e, { type: t  } = i;
    return t === 10 ? e = vc.create(i) : t === 0 || t === 1 || t === 5 || t === 6 ? e = xs.create(i) : t === 9 ? e = xc.create(i) : t === 2 ? e = Sc.create(i) : t === 11 ? e = wc.create(i) : t === 7 && (e = bc.create(i)), e;
}
function ST(i, e, t) {
    let r = [];
    i.objects.traverse((n, s)=>{
        let o = e.find(n);
        if (delete o.interaction, !s.visible && !Lt(o.parent) || s.states === void 0) return;
        let a = new sm(o, t), l = a.states;
        l.push(na.create(n, s));
        for (let h of s.states){
            let u = Oh.patch(s, h.data);
            l.push(na.create(h.id, u));
        }
        let c = a.events;
        if (s.events) for (let { data: h9  } of s.events){
            let u = sG(h9);
            if (!u) continue;
            let f = u.type;
            c[f] ? c[f].push(u) : c[f] = [
                u
            ], "targets" in h9 && r.push([
                h9,
                u
            ]);
        }
        (l.length > 0 || Object.keys(c).length > 0) && (o.interaction = a, xx(o, s, null, t));
    });
    for (let [n19, s11] of r)if ("targets" in n19 && "targets" in s11) for (let { data: o10  } of n19.targets){
        let a = gc.create(o10, e);
        a && s11.targets.push(a);
    }
}
function xx(i, e, t, r, n = !1) {
    if (!n && e.states.length === 0) return;
    let s = t === null ? e : Oh.patch(e, e.states.data(t));
    if (Ev(i, s), i instanceof kt && s.type === "Mesh") {
        if (i instanceof po ? i.buildFromStore(s.geometry) : i.updateGeometry({
            parameters: s.geometry
        }), i.freeBooleanPointer(), Lt(i.parent) && i.parent.invalidateDownstreamBooleanData().recomputeBoolean(), "material" in s) {
            if (i.material instanceof Array) return;
            if (typeof s.material != "string") {
                let a = s.material.layers;
                for (let l of a){
                    let c = i.material.userData.layers.getLayerByUuid(l.id);
                    dx(l.data, r, c, i.material, l.data);
                }
            }
        } else if ("materials" in s) {
            if (!(i.material instanceof Array)) return;
            var o = 0;
            for (let a of s.materials){
                if (typeof a != "string") {
                    let l = a.layers;
                    for (let c of l){
                        let h = i.material[o].userData.layers.getLayerByUuid(c.id);
                        dx(c.data, r, h, i.material[o], c.data);
                    }
                }
                o++;
            }
        }
    } else if (s.type === "DirectionalLight") i.fromDirectionalLightState(s, r);
    else if (s.type === "PointLight") i.fromPointLightState(s, r);
    else if (s.type === "SpotLight") i.fromSpotLightState(s, r);
    else if (i instanceof Bn && eo.is(s.type)) {
        let a = s;
        i.setZoom("PerspectiveCamera", a.perspective.zoom), i.setZoom("OrthographicCamera", a.orthographic.zoom);
    }
}
var na = class {
    constructor(e){
        this.objectState = e;
        this.uuid = et.generateUUID();
    }
    static create(e, t) {
        let r = new na(t);
        return r.uuid = e, r;
    }
    execute(e, t) {
        xx(e, this.objectState, null, t, !0);
    }
};
var Yi = new io, Zn = new M, bx = {
    follow: vc.listener,
    keyDown: xs.listener,
    keyUp: xs.listener,
    lookAt: xc.listener,
    mouseDown: xs.listener,
    mouseUp: xs.listener,
    mouseHover: Sc.listener,
    scroll: wc.listener,
    start: bc.listener
}, MT = {
    follow: Su,
    keyDown: lm,
    keyUp: cm,
    lookAt: Mu,
    mouseDown: yx,
    mouseUp: vx,
    mouseHover: Mc,
    scroll: am,
    start: gx
};
function oG(i) {
    if (i.style.transform !== "") {
        let e = getComputedStyle(i).getPropertyValue("transform");
        if (e !== "none") {
            let t = e.replace("matrix(", "").split(",");
            return {
                x: parseFloat(t[0]),
                y: parseFloat(t[3])
            };
        }
    }
    return {
        x: 1,
        y: 1
    };
}
function AT(i) {
    let e = i.getViewport(new Je), t = oG(i.domElement);
    return {
        left: e.x * t.x,
        top: e.y * t.y,
        width: e.z * t.x,
        height: e.w * t.y
    };
}
function wx(i, e) {
    if (er(e)) {
        if (!e.raycastLock && e.visible) {
            let t = i.intersectObject(e, !1);
            return t.length ? t[0] : void 0;
        }
    } else if (e.objectType === "EmptyObject") return TT(i, e);
}
function TT(i, e) {
    if (er(e) && !e.raycastLock && e.visible) {
        let t = i.intersectObject(e, !1);
        if (t.length) return t[0];
    }
    for (let t of e.children)if (Zo(t)) {
        let r = TT(i, t);
        if (r) return r;
    }
}
var hm = class {
    constructor(e4, t, r, n){
        this.isEnable = !1;
        this.splineEvents = {};
        this._map = {};
        this._prevObjects = [];
        this._onMouseDown = (e)=>{
            Yi.setFromCamera(this._getPointer(e.clientX, e.clientY), this._camera), this._camera.getWorldDirection(Zn), Zn.negate(), this._handleMouseDownEvent(e);
        };
        this._onMouseUp = (e)=>{
            Yi.setFromCamera(this._getPointer(e.clientX, e.clientY), this._camera), this._camera.getWorldDirection(Zn), Zn.negate(), this._handleMouseUpEvent(e);
        };
        this._onMouseMove = (e)=>{
            Yi.setFromCamera(this._getPointer(e.clientX, e.clientY), this._camera), this._camera.getWorldDirection(Zn), Zn.negate(), this._handleMouseHoverEvent(e), this._handleLookAtEvent(e), this._handleFollowEvent(e);
        };
        this._onTouchStart = (e)=>{
            e.touches.length === 1 && (Yi.setFromCamera(this._getPointer(e.touches[0].clientX, e.touches[0].clientY), this._camera), this._camera.getWorldDirection(Zn), Zn.negate(), this._handleMouseDownEvent(e), this._handleMouseHoverEvent(e), this._handleLookAtEvent(e), this._handleFollowEvent(e));
        };
        this._onTouchEnd = (e)=>{
            this._handleMouseUpEvent(e), this._handleMouseHoverEvent(e, !0);
        };
        this._onTouchMove = (e)=>{
            e.touches.length === 1 && (Yi.setFromCamera(this._getPointer(e.touches[0].clientX, e.touches[0].clientY), this._camera), this._camera.getWorldDirection(Zn), Zn.negate(), this._handleMouseHoverEvent(e), this._handleLookAtEvent(e), this._handleFollowEvent(e));
        };
        this._onWheel = (e)=>{
            this._handleWheelEvent(e);
        };
        this._onKeyDown = (e)=>{
            this._handleKeyDownEvent(e);
        };
        this._onKeyUp = (e)=>{
            this._handleKeyUpEvent(e);
        };
        this._renderer = e4, this._domElement = e4.domElement, this._camera = r, this._scene = t, this._app = n, this._domRect = this._domElement.getBoundingClientRect(), this._viewRect = AT(e4);
    }
    activate() {
        var e, t, r, n, s, o, a, l, c, h, u, f, d, p, m, g, v, y;
        this.isEnable = !0, this._map = {}, this._scene.traverseEntity((w)=>{
            w.interaction !== void 0 && (w.interaction.start(), Object.keys(w.interaction.events).forEach((b)=>{
                let S = b;
                this._addDOMCustomEvent(S, w), (w.visible || S !== "mouseDown" && S !== "mouseUp" && S !== "mouseHover") && this._addSPEEvent(S, w);
            }));
        }), Bd ? ((((e = this._map.mouseDown) == null ? void 0 : e.length) || ((t = this._map.mouseHover) == null ? void 0 : t.length) || ((r = this._map.lookAt) == null ? void 0 : r.length) || ((n = this._map.follow) == null ? void 0 : n.length)) && this._domElement.addEventListener("touchstart", this._onTouchStart), (((s = this._map.mouseUp) == null ? void 0 : s.length) || ((o = this._map.mouseHover) == null ? void 0 : o.length)) && this._domElement.addEventListener("touchend", this._onTouchEnd), (((a = this._map.mouseHover) == null ? void 0 : a.length) || ((l = this._map.lookAt) == null ? void 0 : l.length) || ((c = this._map.follow) == null ? void 0 : c.length)) && this._domElement.addEventListener("touchmove", this._onTouchMove)) : ((h = this._map.mouseDown) != null && h.length && this._domElement.addEventListener("pointerdown", this._onMouseDown), (u = this._map.mouseUp) != null && u.length && this._domElement.addEventListener("pointerup", this._onMouseUp), (((f = this._map.mouseHover) == null ? void 0 : f.length) || ((d = this._map.lookAt) == null ? void 0 : d.length) || ((p = this._map.follow) == null ? void 0 : p.length)) && this._domElement.addEventListener("pointermove", this._onMouseMove)), (m = this._map.scroll) != null && m.length && this._domElement.addEventListener("wheel", this._onWheel), (g = this._map.keyDown) != null && g.length && document.addEventListener("keydown", this._onKeyDown), (v = this._map.keyUp) != null && v.length && document.addEventListener("keyup", this._onKeyUp), (y = this._map.start) != null && y.length && this._handleStartEvent(), this.resize();
    }
    deactivate() {
        this._scene.traverseEntity((e)=>{
            if (!e.interaction) return;
            e.interaction.end();
            let t = e;
            Object.keys(bx).forEach((r)=>{
                let n = r;
                t.removeEventListener(n, bx[n]);
            });
        }), this._domElement.removeEventListener("pointerdown", this._onMouseDown), this._domElement.removeEventListener("pointerup", this._onMouseUp), this._domElement.removeEventListener("pointermove", this._onMouseMove), this._domElement.removeEventListener("touchstart", this._onTouchStart), this._domElement.removeEventListener("touchend", this._onTouchEnd), this._domElement.removeEventListener("touchmove", this._onTouchMove), this._domElement.removeEventListener("wheel", this._onWheel), document.removeEventListener("keydown", this._onKeyDown), document.removeEventListener("keyup", this._onKeyUp), this._map = {}, this.isEnable = !1;
    }
    reset() {
        this._scene.traverseEntity((e)=>{
            var t;
            (t = e.interaction) == null || t.start();
        }), this._handleStartEvent();
    }
    resize() {
        this._domRect = this._domElement.getBoundingClientRect(), this._viewRect = AT(this._renderer);
    }
    _getPointer(e, t) {
        let r = this._domRect, n = this._viewRect, s = r.height - n.height, o = (e - n.left - r.left) * (r.width / n.width), a = (t - s + n.top - r.top) * (r.height / n.height);
        return {
            x: o / r.width * 2 - 1,
            y: -(a / r.height) * 2 + 1
        };
    }
    _handleStartEvent() {
        var e;
        (e = this._map.start) == null || e.forEach((t)=>{
            t.dispatchEvent(gx);
        });
    }
    _handleWheelEvent(e) {
        var t;
        (t = this._map.scroll) != null && t.length && (am.deltaY = e.deltaY, this._map.scroll.forEach((r)=>{
            r.dispatchEvent(am);
        }));
    }
    _handleMouseDownEvent(e) {
        var t;
        (t = this._map.mouseDown) == null || t.forEach((r)=>{
            wx(Yi, r) && r.dispatchEvent(yx);
        });
    }
    _handleMouseUpEvent(e) {
        var t;
        (t = this._map.mouseUp) == null || t.forEach((r)=>{
            wx(Yi, r) && r.dispatchEvent(vx);
        });
    }
    _handleMouseHoverEvent(e, t = !1) {
        var n;
        let r = [];
        t || (n = this._map.mouseHover) == null || n.forEach((s)=>{
            wx(Yi, s) && r.push(s);
        }), this._prevObjects.length && (Mc.enter = !1, this._prevObjects.forEach((s)=>{
            r.includes(s) || s.dispatchEvent(Mc);
        })), r.length && (Mc.enter = !0, r.forEach((s)=>{
            s.dispatchEvent(Mc);
        })), this._prevObjects = r;
    }
    _handleLookAtEvent(e) {
        var t;
        (t = this._map.lookAt) != null && t.length && (Mu.normal = Zn, Mu.raycaster = Yi, this._map.lookAt.forEach((r)=>{
            r.dispatchEvent(Mu);
        }));
    }
    _handleFollowEvent(e) {
        this._map.follow && (Su.normal = Zn, Su.raycaster = Yi, this._map.follow.forEach((t)=>t.dispatchEvent(Su)
        ));
    }
    _handleKeyDownEvent(e) {
        var t;
        (t = this._map.keyDown) == null || t.forEach((r)=>{
            var n, s, o;
            lm.interactionEvents = (o = (s = (n = r.interaction) == null ? void 0 : n.events) == null ? void 0 : s.keyDown) == null ? void 0 : o.filter((a)=>a.domEvent.type === "keydown" && a.domEvent.key === e.key
            ), r.dispatchEvent(lm);
        });
    }
    _handleKeyUpEvent(e) {
        var t;
        (t = this._map.keyUp) == null || t.forEach((r)=>{
            var n, s, o;
            cm.interactionEvents = (o = (s = (n = r.interaction) == null ? void 0 : n.events) == null ? void 0 : s.keyUp) == null ? void 0 : o.filter((a)=>a.domEvent.type === "keyup" && a.domEvent.key === e.key
            ), r.dispatchEvent(cm);
        });
    }
    _addSPEEvent(e, t) {
        var r;
        !t.interaction || (MT[e].begin = this._dispatchDOMCustomEvent.bind(this), MT[e].change = this._app.requestRender.bind(this), (r = t.interaction.events[e]) != null && r.length && (t.addEventListener(e, bx[e]), this._map[e] === void 0 ? this._map[e] = [
            t
        ] : this._map[e].push(t)));
    }
    _addDOMCustomEvent(e, t) {
        if (e) {
            let r = new CustomEvent(e, {
                bubbles: !0
            });
            Object.defineProperty(r, "target", {
                writable: !1,
                value: {
                    id: t.uuid,
                    name: t.name
                }
            }), this.splineEvents[e] ? this.splineEvents[e][t.uuid] = r : this.splineEvents[e] = {
                [t.uuid]: r
            };
        }
    }
    _dispatchDOMCustomEvent(e, t) {
        var n;
        let r = (n = this.splineEvents[e]) == null ? void 0 : n[t];
        r && this._domElement.dispatchEvent(r);
    }
};
var um = class {
    constructor(e, t, r, n, s){
        this._aspect = 1;
        this._renderer = e, this._camera = t, this._frameSize = new B().copy(r), this._editorSize = new B().copy(n), this._aspect = t.aspect, this._fov = s != null ? s : t.fov;
    }
    set frameSize(e) {
        this._frameSize.copy(e);
    }
    updateRenderer() {
        !this._renderer || this._renderer.setSize(this._frameSize.x, this._frameSize.y, !1);
    }
    updateViewportForImageExport() {
        if (!this._renderer || !this._camera || this._camera.cameraType !== "PerspectiveCamera") return;
        let e = this._frameSize.x, t = this._frameSize.y, r = this._editorSize.x, n = this._editorSize.y;
        this._aspect = e / t, this._camera.zoom *= Math.min(r / e, n / t), this._renderer.setViewport(0, 0, e, t);
    }
    updateViewport() {
        if (!this._renderer || !this._camera || this._camera.cameraType !== "PerspectiveCamera") return;
        let e = this._frameSize.x, t = this._frameSize.y, r = this._editorSize.x, n = this._editorSize.y, s = 0, o = 0, a = e, l = t;
        e < r && (s = (r - e) * .5, s = -s, a = r), t < n && (o = (n - t) * .5, o = -o, l = n), this._aspect = a / l, this._renderer.setViewport(s, o, a, l);
    }
    updateCamera() {
        if (!!this._camera) {
            if (this._camera.cameraType === "PerspectiveCamera") {
                let e = this._frameSize.y, t = this._editorSize.y, r = this._fov;
                if (e > t) {
                    let n = aG(e, 1080, 2160, 1, 15) / 100;
                    r *= e / t, r *= 1 - n;
                }
                this._camera.aspect = this._aspect, this._camera.fov = r, this._camera.updateProjectionMatrix();
            } else this._camera.setViewplaneSize(this._frameSize.x, this._frameSize.y);
        }
    }
    revert() {
        let e = window.innerWidth, t = window.innerHeight;
        this._renderer && (this._renderer.setViewport(0, 0, e, t), this._renderer.setSize(e, t, !1)), this._camera && (this._camera.aspect = e / t, this._camera.fov = this._fov, this._camera.setViewplaneSize(e, t), this._camera.updateProjectionMatrix());
    }
};
function aG(i, e, t, r, n) {
    return (i - e) / (t - e) * (n - r) + r;
}
var fm = class {
    constructor(e){
        this.sharedAssets = new om(e.shared), this.scene = new Zp(e.scene, this.sharedAssets), this.scene.switchActiveCamera(this.scene.activeCamera);
    }
    reset(e, t) {
        this.scene.clearScene(this.sharedAssets), this.sharedAssets.reset(e.shared), this.scene.resetAfterClear(e.scene, this.sharedAssets);
    }
    dispose() {
        this.scene.dispose();
    }
};
var dm = class {
    constructor({ x: e = 10 , y: t = 10  }){
        this._startTime = 0;
        let r = document.getElementById("spe-perfs");
        r ? this.element = r : (this.element = document.createElement("div"), document.body.appendChild(this.element), this.element.style.position = "absolute", this.element.style.zIndex = "10000", this.element.style.fontFamily = "monospace", this.element.style.background = "black", this.element.style.color = "white", this.element.style.padding = "10px", this.element.style.opacity = "0.5", this.element.style.fontSize = "11px", this.element.setAttribute("id", "spe-perfs")), this.element.style.left = `${e}px`, this.element.style.top = `${t}px`;
    }
    dispose() {
        var e;
        (e = this.element.parentElement) == null || e.removeChild(this.element);
    }
    start() {
        this._startTime = performance.now();
    }
    end() {
        let t = performance.now() - this._startTime;
        this.element.innerHTML = t.toFixed(3) + " ms";
    }
};
function lG(i) {
    let e;
    if (!!i.index) for(let t = 0; t < i.index.array.length; t += 3)e = i.index.array[t], i.index.array[t] = i.index.array[t + 2], i.index.array[t + 2] = e;
}
function Sx(i) {
    return i === "SubdivObject" || i === "NonParametric" ? i : "Mesh";
}
function cG(i, e) {
    let t = {};
    return i.traverseEntity((r)=>{
        var c;
        if (r.type !== "Mesh" || !("material" in r) || !r.visible || !(r instanceof kt) || Array.isArray(r.material) || r && r.interaction && r.interaction.states.length > 0) return;
        let n = r.parent;
        for(; n;){
            if (n instanceof kt && n.interaction && n.interaction.states.length > 1) return;
            n = n.parent;
        }
        let s = r.material.uuid, o = e.shared.materials[s];
        if (o) {
            if (!hi.isMergable(o)) return;
        } else {
            let h = (c = e.scene.objects.get(r.uuid)) == null ? void 0 : c.data;
            if (h && "material" in h && typeof h.material != "string") {
                if (!hi.isMergable(h.material)) return;
                s = hi.getHash(h.material);
            }
        }
        t[s] || (t[s] = {});
        let l = t[s][Sx(r.objectType)];
        if (l) {
            if (l.push(r), r.cloner) for (let h of r.cloner.children)l.push(h);
        } else if (t[s][Sx(r.objectType)] = [
            r
        ], r.cloner) for (let h of r.cloner.children)t[s][Sx(r.objectType)].push(h);
    }), t;
}
function hG(i) {
    let e = 0;
    return Object.values(i).forEach((t)=>{
        Object.values(t).forEach((r)=>{
            let n = r.length;
            n > e && (e = n);
        });
    }), e;
}
function ET(i, e) {
    let t = cG(e, i), r = hG(t), n = new Array(r), s = 0, o = new Array(r), a = 0, l = new Array(r), c = 0, h = new Array(r), u = 0;
    for (let f of Object.values(t))for (let d of Object.values(f)){
        if (a = 0, c = 0, d.forEach((m)=>{
            m instanceof kt && (o[a++] = m.geometry.clone(), l[c++] = m);
        }), c < 2) continue;
        for(let m6 = 0; m6 < c; m6++)l[m6].updateWorldMatrix(!0, !1), o[m6].applyMatrix4(l[m6].matrixWorld), l[m6].matrixWorld.determinant() < 0 && lG(o[m6]);
        let p = RM(o.slice(0, a), !1);
        if (p) {
            let m;
            switch(d[0].objectType){
                case "SubdivObject":
                    console.warn("Turning subdiv object into mesh"), m = new Vt(p, l[0].material);
                    break;
                default:
                    m = new Vt(p, l[0].material);
                    break;
            }
            m.castShadow = l[0].castShadow, m.receiveShadow = l[0].receiveShadow, e.add(m);
            let g = (v)=>{
                u = 0;
                for (let y of v)y.children && g(y.children), y instanceof kt && (Array.isArray(y.material) || t[y.material.uuid] && t[y.material.uuid][y.objectType] && t[y.material.uuid][y.objectType].length > 1 || (h[u++] = y));
                for(let y8 = 0; y8 < u; y8++)e.attach(h[y8]);
            };
            for(let v14 = 0; v14 < c; v14++){
                let y = l[v14];
                g(y.children), n[s++] = y;
            }
        }
    }
    for(let f23 = 0; f23 < s; f23++)n[f23].removeFromParent();
}
var uG = new B, _T = "The Spline Runtime only accepts .splinecode files that are generated from Spline export panel.", CT = class {
    constructor(e5, { autoRender: t15 = !1  } = {}){
        this._viewportMode = 1;
        this._viewportWidth = window.innerWidth;
        this._viewportHeight = window.innerHeight;
        this._proxyObjectCache = new Map;
        this._skipRender = !0;
        this.autoRender = !1;
        this.disposed = !1;
        this.requestRender = ()=>{
            this._skipRender = !1;
        };
        this.render = ()=>{
            var e, t, r;
            !this._renderer || (this._rafId = requestAnimationFrame(this.render), (e = this._perfs) == null || e.start(), !(!this.autoRender && this._skipRender) && (this._controls && (this._controls.enableDamping || this._controls.autoRotate) ? this._skipRender = !this._controls.update() : this._skipRender = !0, this._playmode && !this._playmode.isEnable && this._playmode.activate(), this._scene && this._camera && (this._renderer.autoClear = !1, this._transmissionRenderTarget && (this._renderer.setRenderTarget(this._transmissionRenderTarget), this._renderer.clear(), this._camera.layers.enable(0), this._camera.layers.disable(3), this._renderer.render(this._scene, this._camera), this._renderer.setRenderTarget(null), this._camera.layers.enable(3)), (t = this._scene.postprocessing) != null && t.enabled ? (this._renderer.autoClear = !1, this._scene.postprocessing.render()) : (this._renderer.autoClear = !0, this._renderer.render(this._scene, this._camera))), (r = this._perfs) == null || r.end()));
        };
        this.resize = Mh(()=>{
            var e, t, r, n, s;
            !this._renderer || (this._viewportMode === 1 && this._frameView && (this._frameView.frameSize = uG.set(this._viewportWidth, this._viewportHeight)), (e = this._frameView) == null || e.updateRenderer(), (t = this._scene) != null && t.postprocessing && this._scene.postprocessing.resize(this._viewportWidth, this._viewportHeight, !1), this._viewportMode !== 1 && ((r = this._frameView) == null || r.updateViewport()), this._camera && ((n = this._frameView) == null || n.updateCamera(), this._camera.cameraType === "PerspectiveCamera" && this._viewportMode === 1 && (this._camera.aspect = this._viewportWidth / this._viewportHeight), this._camera.updateProjectionMatrix()), (s = this._playmode) == null || s.resize(), this.requestRender());
        }, 10);
        this.canvas = e5, this.autoRender = t15, window.location.search.includes("perfs") && (this._perfs = new dm({
            x: 10,
            y: 10
        }));
    }
    async load(e) {
        e.endsWith(".spline") ? console.warn(_T + " The .spline files are only meant to be used by the Editor.") : e.endsWith(".splinecode") || console.warn(_T);
        let r = await (await fetch(e)).arrayBuffer();
        await this.start(r);
    }
    async start(e) {
        var l;
        if (this.disposed) return;
        let t = await zA(e);
        this._publishData = t.scene.publish, Rv(t) && await K1();
        let r = new fm(t);
        if (window.location.search.includes("merge-geometries")) {
            let c = performance.now();
            ET(t, r.scene);
            let h = performance.now();
            console.log("Merged geometries in ", h - c, " ms");
        }
        this._scene = r.scene, Rv(t) && this._scene.traverse((c)=>{
            Lt(c) && c.recomputeBoolean();
        }), this._sharedAssetsManager = r.sharedAssets, this._sharedAssetsManager.onImageLoad = ()=>{
            this.requestRender();
        }, ST(t.scene, this._scene, this._sharedAssetsManager), this._camera = this._scene.activeCamera;
        let n = Object.values(t.frames)[0], s, o;
        if (n) {
            if (n.preset === "fullscreen") {
                this._viewportMode = 1;
                let { width: c , height: h  } = window.getComputedStyle(this.canvas);
                this.canvas.parentElement && (c === "300px" || c === "auto") ? (this._viewportWidth = this.canvas.parentElement.clientWidth, this.canvas.style.width = "100%", s = this.canvas.style.width) : this._viewportWidth = this.canvas.clientWidth, this.canvas.parentElement && (h === "150px" || h === "auto") ? (this._viewportHeight = this.canvas.parentElement.clientHeight, this.canvas.style.height = "100%", o = this.canvas.style.height) : this._viewportHeight = this.canvas.clientHeight;
            } else this._viewportMode = 2, this._viewportWidth = n.size[0], this._viewportHeight = n.size[1], s = this._viewportWidth + "px", o = this._viewportHeight + "px";
        }
        (l = this._scene.postprocessing) != null && l.enabled ? (this._renderer = new Pt({
            canvas: this.canvas,
            antialias: !1,
            alpha: !0,
            stencil: !1,
            depth: !1,
            powerPreference: "high-performance"
        }), this._scene.postprocessing.init({
            renderer: this._renderer,
            camera: this._camera,
            scene: this._scene
        }), this._scene.postprocessing.addEventListener("smaaloaded", this.requestRender)) : this._renderer = new Pt({
            canvas: this.canvas,
            antialias: !0,
            alpha: !0,
            stencil: !0,
            depth: !0,
            powerPreference: "high-performance"
        }), s && (this.canvas.style.width = s), o && (this.canvas.style.height = o), this._scene.needsTransmission(void 0) && (this._transmissionRenderTarget = new mt(2048, 2048, {
            generateMipmaps: !0,
            minFilter: js,
            magFilter: ct,
            wrapS: Dr,
            wrapT: Dr
        }), this._transmissionRenderTarget.depthTexture = new oi(2048, 2048), this._scene.needsTransmission(this._transmissionRenderTarget)), this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.setSize(this._viewportWidth, this._viewportHeight, !1), this._scene.postprocessing && this._scene.postprocessing.resize(this._viewportWidth, this._viewportHeight, !1), this._renderer.shadowMap.enabled = !0, this._renderer.shadowMap.type = Zg, this._renderer.setClearColor(this._scene.bgColor, this._scene.alpha), this._frameView = new um(this._renderer, this._camera, new B(this._viewportWidth, this._viewportHeight), new B(window.innerWidth, window.innerHeight)), this._controls = new cp(this._camera, this._renderer.domElement), this._publishData && (this._controls.fromJSON(this._publishData.orbitControls), this._controls.useKeyEvents = !1), this._controls.addEventListener("change", this.requestRender), this._controls.addEventListener("start", this.requestRender), this._playmode = new hm(this._renderer, this._scene, this._camera, this), this.resize(), this.render(), this.canvas.parentElement && (await QS(0), this._resizeObserver = new ResizeObserver(()=>{
            this._viewportWidth = this.canvas.clientWidth, this._viewportHeight = this.canvas.clientHeight, this.resize();
        }), this._resizeObserver.observe(this.canvas.parentElement));
    }
    findObjectById(e) {
        var r;
        let t = (r = this._scene) == null ? void 0 : r.getObjectByProperty("uuid", e);
        return this._createProxyObject(t);
    }
    findObjectByName(e) {
        var r;
        let t = (r = this._scene) == null ? void 0 : r.getObjectByName(e);
        return this._createProxyObject(t);
    }
    getSplineEvents() {
        var e;
        return (e = this._playmode) == null ? void 0 : e.splineEvents;
    }
    emitEvent(e, t) {
        let r = this.findObjectById(t);
        r == null || r.emitEvent(e);
    }
    emitEventReverse(e, t) {
        let r = this.findObjectById(t);
        r == null || r.emitEventReverse(e);
    }
    addEventListener(e, t) {
        var r;
        (r = this._renderer) == null || r.domElement.addEventListener(e, t);
    }
    removeEventListener(e, t) {
        var r;
        (r = this._renderer) == null || r.domElement.removeEventListener(e, t);
    }
    setZoom(e) {
        var t;
        (t = this._controls) == null || t.zoomOut(e);
    }
    setSize(e, t) {
        this._viewportWidth = e, this._viewportHeight = t, this._viewportMode = 2, this.resize();
    }
    dispose() {
        var e, t, r, n, s, o, a;
        this.disposed = !0, (e = this._playmode) == null || e.deactivate(), (t = this._scene) == null || t.dispose(), this._rafId && cancelAnimationFrame(this._rafId), this._proxyObjectCache.forEach((l)=>{
            py.unsubscribe(l);
        }), (r = this._renderer) == null || r.dispose(), (n = this._transmissionRenderTarget) == null || n.dispose(), (o = (s = this._transmissionRenderTarget) == null ? void 0 : s.depthTexture) == null || o.dispose(), (a = this._sharedAssetsManager) == null || a.dispose(), this._resizeObserver && this._resizeObserver.disconnect();
    }
    _createProxyObject(e) {
        if (e == null) return;
        if (this._proxyObjectCache.has(e.uuid)) return this._proxyObjectCache.get(e.uuid);
        let t = {
            name: e.name,
            uuid: e.uuid,
            visible: e.visible,
            intensity: e.intensity,
            position: e.position,
            rotation: e.rotation,
            scale: e.scale,
            emitEvent (n) {
                var s;
                (s = e.interaction) == null || s.emitEvent(n);
            },
            emitEventReverse (n) {
                var s;
                (s = e.interaction) == null || s.emitEventReverse(n);
            }
        }, r = py(t, (n, s)=>{
            var a;
            typeof e[n] != "object" && ((a = Object.getOwnPropertyDescriptor(e, n)) == null ? void 0 : a.writable) && (e[n] = s), this.requestRender(), e.updateMatrix();
        });
        return this._proxyObjectCache.set(e.uuid, r), r;
    }
};

},{"buffer":"fCgem","process":"d5jf4","c4f428a88e5bff21":"dhvfp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require('base64-js');
const ieee754 = require('ieee754');
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i1;
    if (dir) {
        let foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength1 && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2];
    let mul = 1;
    while(byteLength2 > 0 && (mul *= 0x100))val += this[offset + --byteLength2] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength3 && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
    offset = offset >>> 0;
    byteLength4 = byteLength4 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength4, this.length);
    let i = byteLength4;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength5 = byteLength5 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength5) - 1;
        checkInt(this, value, offset, byteLength5, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength5 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength5;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength6) - 1;
        checkInt(this, value, offset, byteLength6, maxBytes, 0);
    }
    let i = byteLength6 - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength6;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength7 - 1);
        checkInt(this, value, offset, byteLength7, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength7 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength7;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength8 - 1);
        checkInt(this, value, offset, byteLength8, limit - 1, -limit);
    }
    let i = byteLength8 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength8;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength9) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength9] === undefined) boundsError(offset, buf.length - (byteLength9 + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength10) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength10 > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength10 + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength10 + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength10 + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength10);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"base64-js":"eIiSV","ieee754":"cO95r"}],"eIiSV":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len2; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i2 = start; i2 < end; i2 += 3){
        tmp = (uint8[i2] << 16 & 0xFF0000) + (uint8[i2 + 1] << 8 & 0xFF00) + (uint8[i2 + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len3 = uint8.length;
    var extraBytes = len3 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i3 = 0, len2 = len3 - extraBytes; i3 < len2; i3 += maxChunkLength)parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len3 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len3 - 2] << 8) + uint8[len3 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"dhvfp":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('j3yyQ') + "boolean.816716e8.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('iMvDs')
);

},{"./helpers/browser/js-loader":"61B45","./helpers/bundle-url":"lgJ39"}]},["kn9T2","1t1vh"], null, "parcelRequire656e")

//# sourceMappingURL=react-spline.es.6413ceda.js.map
